<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.io/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://ytliu.github.io/"/>
  <updated>2016-12-15T12:22:01+08:00</updated>
  <id>http://ytliu.github.io/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenSSL Authenticated Android Accessory Protocol]]></title>
    <link href="http://ytliu.github.io/blog/2015/12/05/openssl-authenticated-android-accessory-protocol/"/>
    <updated>2015-12-05T11:09:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/12/05/openssl-authenticated-android-accessory-protocol</id>
    <content type="html"><![CDATA[<p>前段时间在研究Android Auto（关于什么是Auto请自行google），里面涉及到两个比较关键的数据传输和加密协议：<code>Android Accessory Protocol</code>和<code>OpenSSL</code>。具体来说，auto和车载系统（之后称为headunit）之间数据的传输以及最初连接的建立是基于<a href="https://source.android.com/devices/accessories/protocol.html">Android Open Accessory （AOA）</a>协议的，而它们两个之间的认证过程以及数据的加密是基于<a href="https://www.openssl.org/">OpenSSL</a>的握手和加密协议。</p>

<p>在研究这两个协议的过程中，“如何将AOA协议和SSL协议结合起来”是一个很关键的问题。我在网上找了很多资料，但是并没有一个比较完整的教程，所以打算在这篇博客中做一个详细的介绍，并且将相关代码开源。</p>

<p><a href="https://github.com/ytliu/aoa-with-ssl">github上的源码</a></p>

<!-- more -->


<h3>关于Android Auto</h3>

<p>关于什么是<a href="https://www.android.com/auto/">Android Auto</a>，可以到google的官方网站上去查询。简单来说，就是Google开发的一套机制，可以将手机上的应用（包括地图、音乐、通话等）和车载系统进行交互，使得车载系统的功能更加丰富。如果要描述它的机制的话，可以用下面一张图来表示：</p>

<p><img src="http://ytliu.info/images/2015-12-05-1.png" title="Androi Auto Mechanism" alt="Androi Auto Mechanism" /></p>

<p>其中，负责和headunit进行交互的是GMS (Google Mobile Service)的Car Service，然后它会和Google开发的Auto应用联系，Auto应用负责和其它第三方应用程序交互，现在支持Android Auto的第三方应用程序有<a href="https://play.google.com/store/apps/collection/promotion_3001303_android_auto_all">这些</a>，可以看到大部分还是一些音乐和社交类的应用。这里有一个特殊的应用，那就是Google Map，它是直接整合在GMS里面的，可以直接和Car service进行交互，应该不需要经过Auto（当然这还仅仅是我的推测）。</p>

<h3>关于两个协议</h3>

<p>由于这篇博文主要介绍的是手机和车载的交互协议，因此我们主要关注的是GMS car service和headunit之间的交互，所以，我们把上面那张图简化一下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-2.png" title="AA and SSL Protocols" alt="AA and SSL Protocols" /></p>

<p>其中<code>Android Open Accessory（AOA）</code>协议发生在两台设备通过USB进行连接，其中一台作为<code>Accessory</code>，一台作为<code>Device</code>。在Auto的例子中，headunit的角色为<code>Accessory</code>，手机的角色为<code>Device</code>。<code>AOA</code>协议主要作用是关于<code>Accessory</code>和<code>Device</code>在初始化连接时候的互相识别，以及之后数据的传输。</p>

<p>关于<code>Accessory</code>和<code>Device</code>的概念可以看<a href="http://www.crifan.com/android_usb_usbaccessory_vs_usbdevice/">这篇博文</a>，这里就不详述了。</p>

<p>当<code>Accessory</code>和<code>Device</code>建立连接之后，两边就可以进行数据的传输了，但是由于一些隐私问题，传输的数据需要进行加密，因此就引入了<code>OpenSSL</code>协议。在OpenSSL协议中连接两端的实体被分为了<code>Server</code>和<code>Client</code>，这两个角色有什么区别会在之后提到。在这里我们只需要知道在Auto的例子中，headunit的角色为<code>Client</code>，手机的角色为<code>Server</code>。因此我们的图又被抽象为如下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-3.png" title="AA and SSL Protocols 2" alt="AA and SSL Protocols 2" /></p>

<p>好了，到现在为止，我们就完全和Auto撇清关系了，我们接下来要介绍的，就是两个实体，它们通过USB连接，一个作为AOA协议的<code>Accessory</code>和OpenSSL协议的<code>Client</code>，另一个作为AOA协议的<code>Device</code>和OpenSSL协议的<code>Server</code>。</p>

<h3>Android Open Accessory（AOA）协议</h3>

<p>当两个实体通过USB进行连接之后，最先做出反应的是<code>Accessory</code>，它会做以下几件事情：</p>

<h4>步骤1：获得和它连接的<code>Device</code>的VendorID和ProductID；</h4>

<h4>步骤2：判断它们是否匹配相应的数字；</h4>

<p>比如在Auto的例子中，headunit需要判断VendorID是否匹配<code>0x18D1</code>，ProductID是否匹配<code>0x2D00</code>或者<code>0x2D01</code>？）</p>

<ul>
<li>如果匹配，则表示该设备支持Android accessory模式，并且当前已经处于该模，所以<code>Accessory</code>可以直接和<code>Device</code>进行通信（直接跳到步骤5）；</li>
<li>否则，则表示该设备目前不处在Android accessory模式，但是不清楚其是否支持该模式，需要进行确认（继续执行步骤3~4）。</li>
</ul>


<h4>步骤3：Android accessory模式确认和重新连接；</h4>

<ul>
<li><p>通过USB发送一个请求：</p>

<pre><code>requestType:    USB_DIR_IN | USB_TYPE_VENDOR
request:        51
value:          0
index:          0
data:           protocol version number (16 bits little endian sent from the device to the accessory)
</code></pre></li>
<li><p>如果对方返回一个非零整数，则表示该设备支持Android accessory模式，该返回值表示支持的协议版本号；</p></li>
<li><p>发送另外的请求，该请求中包含一些字符串，用来表示<code>Device</code>中哪些应用程序可以来和<code>Accessory</code>进行交互：</p>

<pre><code>requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
request:        52
value:          0
index:          string ID
data            zero terminated UTF8 string sent from accessory to device
</code></pre></li>
<li><p>有效的string ID包含以下几类：</p>

<pre><code>manufacturer name:  0
model name:         1
description:        2
version:            3
URI:                4
serial number:      5
</code></pre></li>
<li><p>在Auto的例子中，headUnit在这个过程中会发送两个string ID：<code>manufacturer name = "Android"</code>，<code>model name = "Android Auto"</code>。该string ID会触发手机设备中<code>com.google.android.gms.car.FirstActivity</code>的<code>onCreate()</code>函数，从而使得GMS car service和headUnit进行accessory的连接；</p></li>
<li><p><code>Accessory</code>最后发送一个请求，告诉<code>Device</code>开始进入Android accessory模式，并且重新建立连接：</p>

<pre><code>requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
request:        53
value:          0
index:          0
data:           none
</code></pre></li>
</ul>


<h4>步骤4：重新检查；</h4>

<p>步骤3结束之后，<code>Device</code>会重新和<code>Accessory</code>进行连接，这时<code>Accessory</code>回到步骤1进行检查，如果检查通过，则进入步骤5，如果<code>Device</code>不支持Android accessory模式，或者没有匹配的应用程序，则<code>Device</code>会返回信息告诉<code>Accessory</code>，这时<code>Accessory</code>就只能等待下一个手机设备的接入。</p>

<h4>步骤5：开始通信.</h4>

<p>从这之后，<code>Accessory</code>和<code>Device</code>将通过Android Accessory协议进行通信，<code>Accessory</code>首先获得该USB连接中的一些配置元数据，包括接口类型（UsbInterface），端点信息（UsbEndpoint）等，从而获得对应的bulk endpoints，进行之后的通信过程。</p>

<p>在数据通信的过程中，<code>Accessory</code>通过<code>libusb</code>库提供的<code>libusb_control_transfer</code>和<code>libusb_bulk_transfer</code>接口进行数据的传输，其中，<code>libusb_control_transfer</code>用于传输一些指令数据，而<code>libusb_bulk_transfer</code>用于传输一些比较大的数据，比如音频数据，图像数据等；
而<code>Device</code>则通过Android <code>USBManager</code>提供的<code>openAccessory</code>接口获得一个文件描述符，然后通过其对应的<code>FileInputStream</code>和<code>FileOutputStream</code>进行数据的读写：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ParcelFileDescriptor</span> <span class="n">mFD</span> <span class="o">=</span> <span class="n">mUSBManager</span><span class="o">.</span><span class="na">openAccessory</span><span class="o">(</span><span class="n">acc</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">mFD</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">FileDescripter</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">mFD</span><span class="o">.</span><span class="na">getFileDescriptor</span><span class="o">();</span>
</span><span class='line'><span class="n">mIS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>  <span class="c1">// use this to receive messages</span>
</span><span class='line'><span class="n">mOS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span> <span class="c1">// use this to send commands</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<hr />

<h3>OpenSSL协议</h3>

<p>在<code>Accessory</code>和<code>Device</code>建立连接，并且可以传输数据之后，它们就要开始建立OpenSSL的连接，对数据进行加解密了。这里主要分为了两个过程：握手过程和数据加解密过程。这里简单介绍下握手协议：</p>

<h4>OpenSSL握手协议</h4>

<p>握手协议的作用是身份的认证，该过程由<code>Client</code>端发起，这个协议的过程如下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-4.png" title="OpenSSL Handshake Protocol" alt="OpenSSL Handshake Protocol" /></p>

<p>在这个过程中，<code>Client</code>首先会对<code>Server</code>提供的证书（Certificate）进行验证，<code>Server</code>也会对<code>Client</code>提供的证书进行验证。同时它们会用<code>Server</code>的公钥（包含在<code>Server</code>的证书中）和存在<code>Server</code>端的私钥进行秘钥的协商，最后通过这个协商好的秘钥（master key）对数据进行加解密。</p>

<p>这里推荐<a href="http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work">StackOverflow的一个帖子</a>，里面的前两个回答对OpenSSL握手协议进行了一个很棒的解释。</p>

<hr />

<h3>代码分析</h3>

<p>在进行了背景介绍之后，我们开始来分析下如何实现这整个过程。</p>

<p>源码可以在<a href="https://github.com/ytliu/aoa-with-ssl">这里</a>下载。</p>

<p>里面有两个目录：<code>aoa-dev-ssl-server</code>和<code>aoa-acc-ssl-client</code>，分别代表上面描述的两个实体。这两个目录是两个不同的Android应用，编译完之后可以通过<code>adb install</code>安装在Android平台的手机或者平板上。</p>

<h4>AOA协议的实现</h4>

<p>首先由<code>aoa-acc-ssl-client</code>发起，代码在<code>src/cn/sjtu/ipads/uas/UasTransport.java</code>文件中：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">usb_acc_string_send</span><span class="o">(</span><span class="n">UsbDeviceConnection</span> <span class="n">connection</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="o">(</span><span class="n">string</span> <span class="o">+</span> <span class="s">&quot;\0&quot;</span><span class="o">).</span><span class="na">getBytes</span><span class="o">();</span>
</span><span class='line'><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">controlTransfer</span><span class="o">(</span><span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_TYPE_VENDOR</span><span class="o">,</span>
</span><span class='line'>    <span class="n">OAP_SEND_STRING</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kt">void</span> <span class="n">usb_acc_strings_send</span><span class="o">()</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">usb_acc_string_send</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">,</span> <span class="n">OAP_STR_MANUFACTURE</span><span class="o">,</span> <span class="s">&quot;SJTU&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">usb_acc_string_send</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">,</span> <span class="n">OAP_STR_MODEL</span><span class="o">,</span> <span class="s">&quot;SJTU IPADS&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kt">void</span> <span class="n">acc_mode_switch</span><span class="o">()</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">acc_ver</span> <span class="o">=</span> <span class="n">usb_acc_version_get</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">);</span>
</span><span class='line'><span class="n">usb_acc_strings_send</span><span class="o">();</span>
</span><span class='line'><span class="n">m_usb_dev_conn</span><span class="o">.</span><span class="na">controlTransfer</span><span class="o">(</span><span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_TYPE_VENDOR</span><span class="o">,</span> <span class="n">OAP_START</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kt">void</span> <span class="n">usb_connect</span><span class="o">(</span><span class="n">UsbDevice</span> <span class="n">device</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">(</span><span class="n">usb_open</span><span class="o">(</span><span class="n">device</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">usb_disconnect</span><span class="o">();</span>
</span><span class='line'>  <span class="k">return</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kt">int</span> <span class="n">dev_vend_id</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="na">getVendorId</span><span class="o">();</span>
</span><span class='line'><span class="kt">int</span> <span class="n">dev_prod_id</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="na">getProductId</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">dev_vend_id</span> <span class="o">==</span> <span class="n">USB_VID_GOO</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="o">(</span><span class="n">dev_prod_id</span> <span class="o">==</span> <span class="n">USB_PID_OAP_NUL</span> <span class="o">||</span> <span class="n">dev_prod_id</span> <span class="o">==</span> <span class="n">USB_PID_OAP_ADB</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">acc_mode_connect</span><span class="o">();</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">return</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">acc_mode_switch</span><span class="o">();</span>
</span><span class='line'><span class="n">usb_disconnect</span><span class="o">();</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个可以参照我之前讲的AOA协议来对照，这里当调用<code>usb_acc_strings_send()</code>将两个字符串发送出去之后，在<code>Device</code>端就会有相应的应用被唤醒，因为在该应用中定义了如下内容（在<code>aoa-dev-ssl-server</code>目录的<code>res/xml/usb_accessory_filter</code>文件中）：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="ni">&amp;lt;</span>?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
</span><span class='line'><span class="nt">&lt;resources&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>usb-accessory manufacturer=&quot;SJTU&quot; model=&quot;SJTU IPADS&quot; /<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>而在<code>aoa-dev-ssl-server</code>目录的<code>AndroidManifest.xml</code>文件中定义如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="ni">&amp;lt;</span>?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
</span><span class='line'><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>  <span class="na">package=</span><span class="s">&quot;cn.sjtu.ipads.ual&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&quot;android.hardware.usb.accessory&quot;</span> <span class="na">android:required=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;application&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>uses-library android:name=&quot;com.android.future.usb.accessory&quot; /<span class="ni">&amp;gt;</span>
</span><span class='line'>...
</span><span class='line'><span class="ni">&amp;lt;</span>activity
</span><span class='line'>  android:name=&quot;UalTraActivity&quot;<span class="ni">&amp;gt;</span>
</span><span class='line'>  <span class="ni">&amp;lt;</span>intent-filter<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>action android:name=&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'>  <span class="ni">&amp;lt;</span>/intent-filter<span class="ni">&amp;gt;</span>
</span><span class='line'>  <span class="ni">&amp;lt;</span>meta-data
</span><span class='line'>    android:name=&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;
</span><span class='line'>    android:resource=&quot;@xml/usb_accessory_filter&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>/activity<span class="ni">&amp;gt;</span>
</span><span class='line'>...
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;/application&gt;</span>
</span><span class='line'><span class="nt">&lt;/manifest&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>所以，<code>aoa-dev-ssl-server</code>这个应用会被唤醒，进入<code>UalTraActivity</code>的<code>onCreate()</code>函数。在该类中，会进行USB accessory的连接：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">mDeviceHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="n">mUSBManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">UsbManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">USB_SERVICE</span><span class="o">);</span>
</span><span class='line'><span class="n">connectToAccessory</span><span class="o">();</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">public</span> <span class="kt">void</span> <span class="n">connectToAccessory</span><span class="o">()</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// bail out if we&#39;re already connected</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">mConnection</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>  <span class="k">return</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;connectToAccessory&quot;</span><span class="o">);</span>
</span><span class='line'><span class="c1">// assume only one accessory (currently safe assumption)</span>
</span><span class='line'><span class="n">UsbAccessory</span><span class="o">[]</span> <span class="n">accessories</span> <span class="o">=</span> <span class="n">mUSBManager</span><span class="o">.</span><span class="na">getAccessoryList</span><span class="o">();</span>
</span><span class='line'><span class="n">UsbAccessory</span> <span class="n">accessory</span> <span class="o">=</span> <span class="o">(</span><span class="n">accessories</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">accessories</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">accessory</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">mUSBManager</span><span class="o">.</span><span class="na">hasPermission</span><span class="o">(</span><span class="n">accessory</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">openAccessory</span><span class="o">(</span><span class="n">accessory</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;no permission for accessory&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;mAccessory is null&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kt">void</span> <span class="n">openAccessory</span><span class="o">(</span><span class="n">UsbAccessory</span> <span class="n">accessory</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;openAccessory&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">mConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UsbConnection</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">mUSBManager</span><span class="o">,</span> <span class="n">accessory</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="o">(</span><span class="n">mConnection</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;mConnection is null&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">finish</span><span class="o">();</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">performPostConnectionTasks</span><span class="o">();</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在<code>UsbConnection</code>这个类中会通过<code>UsbManager</code>的<code>openAccessory</code>接口得到一个文件描述符<code>mFileDescriptor</code>，之后的数据传输就是通过对这个<code>mFileDescriptor</code>的读写来进行的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">public</span> <span class="nf">UsbConnection</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">,</span> <span class="n">UsbManager</span> <span class="n">usbManager</span><span class="o">,&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">UsbAccessory</span> <span class="n">accessory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'><span class="n">mActivity</span> <span class="o">=</span> <span class="n">activity</span><span class="o">;</span>
</span><span class='line'><span class="n">mFileDescriptor</span> <span class="o">=</span> <span class="n">usbManager</span><span class="o">.</span><span class="na">openAccessory</span><span class="o">(</span><span class="n">accessory</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">mFileDescriptor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="s">&quot;UsbConnection&quot;</span><span class="o">,</span> <span class="s">&quot;mFileDescriptor&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="n">mAccessory</span> <span class="o">=</span> <span class="n">accessory</span><span class="o">;</span>
</span><span class='line'>  <span class="n">FileDescriptor</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">mFileDescriptor</span><span class="o">.</span><span class="na">getFileDescriptor</span><span class="o">();</span>
</span><span class='line'>  <span class="n">mInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>
</span><span class='line'>  <span class="n">mOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">IntentFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntentFilter</span><span class="o">(</span><span class="n">ACTION_USB_PERMISSION</span><span class="o">);</span>
</span><span class='line'><span class="n">filter</span><span class="o">.</span><span class="na">addAction</span><span class="o">(</span><span class="n">UsbManager</span><span class="o">.</span><span class="na">ACTION_USB_ACCESSORY_DETACHED</span><span class="o">);</span>
</span><span class='line'><span class="n">mActivity</span><span class="o">.</span><span class="na">registerReceiver</span><span class="o">(</span><span class="n">mUsbReceiver</span><span class="o">,</span> <span class="n">filter</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>到目前为止，<code>Accessory</code>和<code>Device</code>的连接已经建立，之后的数据传输就可以进行了。</p>

<p>在<code>Accessory</code>这端的数据读写是在jni层中，可以参阅<code>aoa-acc-ssl-client/jni/hu_usb.c</code>这个文件。</p>

<p>发数据的流程是这样的：</p>

<pre><code>hu_aap_usb_send() -&gt; hu_usb_send() -&gt; iusb_bulk_transfer(out)
</code></pre>

<p>接受数据的流程是这样的：</p>

<pre><code>hu_aap_usb_recv() -&gt; hu_usb_recv() -&gt; iusb_bulk_transfer(in)
</code></pre>

<p>具体代码这里不贴了，有兴趣自己去看。</p>

<p>在<code>Device</code>这端的数据读写是在java层，可以参阅<code>aoa-dev-ssl-server/src/cn/sjtu/ipads/ual/UalTraActivity.java</code>这个文件。</p>

<p>发数据就是调用了之前获得的<code>UsbConnection</code>类的这个接口：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">mConnection</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bufferLength</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>收数据类似：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">mConnection</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">bufferUsed</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">bufferUsed</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>AOA协议基本就实现完成了。</p>

<h4>OpenSSL握手协议</h4>

<p>握手协议由<code>aoa-acc-ssl-client</code>发起，在文件<code>aoa-acc-ssl-client/jni/hu_aap.c</code>中：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">hu_aap_start</span> <span class="p">(</span><span class="n">byte</span> <span class="n">ep_in_addr</span><span class="p">,</span> <span class="n">byte</span> <span class="n">ep_out_addr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">hu_ssl_handshake</span> <span class="p">();</span> <span class="c1">// Do SSL Client Handshake with AA SSL server</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>之后就会经历上面提到的整个握手过程。</p>

<p>这里需要注意的是，这个OpenSSL握手和加解密过程的实现，和我们平时通过socket传输数据时所涉及到的过程有点不一样。</p>

<p>我们在网络编程的时候，一般会调用下面两个API：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SSL</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">ssl</span> <span class="o">=</span> <span class="n">SSL_new</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>  <span class="o">/&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">get</span> <span class="n">new</span> <span class="n">SSL</span> <span class="n">state</span> <span class="n">with</span> <span class="n">context</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="n">SSL_set_fd</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>  <span class="o">/&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">set</span> <span class="n">connection</span> <span class="n">to</span> <span class="n">SSL</span> <span class="n">state</span> <span class="err">*/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>之后的网络数据读写直接通过<code>SSL_write(ssl)</code>和<code>SSL_read(ssl)</code>来做就行了。因为SSL和这个负责读写数据的文件描述符<code>sockfd</code>已经绑定在一起了，在网络库的内部帮我们实现了网络buffer到SSL内部buffer的映射。</p>

<p>然而，当我们需要通过USB进行传输数据的时候就没有那么简单了。我们前面说过，我们同样可以通过对某个文件描述的读写操作来传送和接受USB数据，但是USB的库并没有帮我们实现其buffer到SSL内部buffer的映射。因此这步操作需要我们自己来实现。这里就用到了<code>OpenSSL</code>+<code>Memory BIO</code>的机制。</p>

<p>先提供一个参考资料：<a href="http://www.roxlu.com/2014/042/using-openssl-with-memory-bios">Using OpenSSL with Memory BIO</a></p>

<p>简单来说步骤是这样的：</p>

<ul>
<li>首先，我们需要配置OpenSSL的数据结构：</li>
</ul>


<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">ual_ssl_ctx</span> <span class="o">=</span> <span class="n">SSL_CTX_new</span><span class="p">(</span><span class="n">ual_ssl_method</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_CTX_use_certificate</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">,</span> <span class="n">x509_cert</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_CTX_use_PrivateKey</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">,</span> <span class="n">priv_key</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">ual_ssl_ssl</span> <span class="o">=</span> <span class="n">SSL_new</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">ual_ssl_rm_bio</span> <span class="o">=</span> <span class="n">BIO_new</span><span class="p">(</span><span class="n">BIO_s_mem</span><span class="p">());</span>
</span><span class='line'>  <span class="n">ual_ssl_wm_bio</span> <span class="o">=</span> <span class="n">BIO_new</span><span class="p">(</span><span class="n">BIO_s_mem</span><span class="p">());</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">SSL_set_bio</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">ual_ssl_wm_bio</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我中间跳过了很多步，不过那些都不重要（可以去看源码），这里最重要的就是这句话：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SSL_set_bio</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">ual_ssl_wm_bio</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里将<code>ual_ssl_ssl</code>这个数据结构和两段内存联系在一起，这两段内存分别是<code>read BIO</code>和<code>write BIO</code>。</p>

<p>这有什么用呢？其实要解释清楚这个就需要先对OpenSSL的机制有一个初步的了解。</p>

<p>在SSL的所有操作中（比如证书验证，加密，解密等），说到底，就是从某段内存中读取数据，对其进行相应的操作，然后将结果写在另外一段内存中。因此这里的两段内存就分别对应了<code>read BIO</code>和<code>write BIO</code>。</p>

<p>似乎还是有点晕，那么我们来举个例子：</p>

<p>如果我们要进行数据加密，分解步骤是这样的：</p>

<ul>
<li>输入一段长度为<code>len</code>的明文数据<code>plain_buf</code>；</li>
<li>调用<code>SSL_write(ual_ssl_ssl, plain_buf, len)</code>，这时OpenSSL内部的逻辑就会对这段数据进行加密，并且将结果保存在<code>write BIO</code>中；</li>
<li>调用<code>BIO_read(ual_ssl_wm_bio, cipher_buf, DEFBUF)</code>，就可以将这段加密好的数据读出来保存在<code>cipher_buf</code>中；</li>
<li>最后，我们通过写USB对应的文件描述符就可以将这段加密的数据发送出去了。</li>
</ul>


<p>因此，整个加密的逻辑就可以是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_encrypt_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">plain_buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cipher_buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">bytes_written</span> <span class="o">=</span> <span class="n">SSL_write</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">BIO_read</span><span class="p">(</span><span class="n">ual_ssl_wm_bio</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">DEFBUF</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">bytes_read</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">ssl_encrypt_data</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">send_to_usb_fd</span><span class="p">(</span><span class="n">cipher_buf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>类似的，解密的分解步骤是这样的：</p>

<ul>
<li>通过读USB对应的文件描述符读取一段长度为<code>len</code>的密文数据<code>cipher_buf</code>；</li>
<li>调用<code>BIO_write(ual_ssl_ssl, cipher_buf, len)</code>，将这段密文写入和SSL相关联的<code>read BIO</code>的内存中；</li>
<li>调用<code>SSL_read(ual_ssl_ssl, plain_buf, DEFBUF)</code>，将<code>read BIO</code>的数据进行解密，并将结果保存在<code>plain_buf</code>中；</li>
<li>最后，我们就可以对这段明文数据进行处理了。</li>
</ul>


<p>其相应的逻辑就变成这样了：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_decrypt_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cipher_buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">plain_buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">bytes_written</span> <span class="o">=</span> <span class="n">BIO_write</span><span class="p">(</span><span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">SSL_read</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">DEFBUF</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">bytes_read</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">recv_from_usb_fd</span><span class="p">(</span><span class="n">cipher_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">ssl_decrypt_data</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">process</span><span class="p">(</span><span class="n">plain_buf</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>和加解密过程相比，握手的过程会比较复杂一些，但是相关原理是一样的。</p>

<p>不管在<code>Server</code>端还是在<code>Client</code>端，都需要调用<code>SSL_do_handshake(ual_ssl_ssl)</code>这个API，OpenSSL内部的逻辑就会根据当前的状态对<code>ual_ssl_rm_bio</code>的数据进行处理，并将结果写到<code>ual_ssl_wm_bio</code>中。在调用<code>SSL_do_handshake</code>这个API前，需要将相关的数据写到<code>read BIO</code>中（比如在<code>Server</code>端，第一次调用<code>SSL_do_handshake</code>前需要将<code>Client Hello</code>的数据通过<code>BIO_write</code>写进<code>ual_ssl_rm_bio</code>中）。所以说，一般情况下需要手动调用大于一次的<code>SSL_do_handshake</code>接口。</p>

<p>整个逻辑大概是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_hs_data_enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">BIO_write</span><span class="p">(</span><span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">ssl_hs_data_dequeue</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">BIO_read</span><span class="p">(</span><span class="n">ual_ssl_wm_bio</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">DEFBUF</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">ssl_handshake</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_do_handshake</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">while</span> <span class="p">(</span><span class="n">handshake</span> <span class="n">not</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">len</span> <span class="o">=</span> <span class="n">recv_from_usb_fd</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ssl_hs_data_enqueue</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ssl_handshake</span><span class="p">();</span>
</span><span class='line'>  <span class="n">length</span> <span class="o">=</span> <span class="n">ssl_hs_data_dequeue</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span><span class='line'>  <span class="n">send_to_usb_fd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>讲到这里，OpenSSL的整个流程也基本介绍完了。最后需要说明的一点，在<code>aoa-acc-ssl-client</code>中，数据的传输和加密都是在JNI层完成的，所以代码比较简单。但是在<code>aoa-dev-ssl-server</code>中，数据的传输是在Java层完成的，而加密是在JNI层实现的，所以中间有一个JNI调用的过程，会显得比较复杂。不过整体的原理是一样的。</p>

<p>关于JNI如何调用，网上有很多教程，也可以直接参照源码，这里就不详述了。</p>

<p>最后，关于整个项目的编译和运行，可以参照github中的<code>README.md</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转载】Sigreturn Oriented Programming (SROP) Attack - 攻击原理]]></title>
    <link href="http://ytliu.github.io/blog/2015/12/02/sigreturn-oriented-programming-srop-attack-gong-ji-yuan-li/"/>
    <updated>2015-12-02T18:43:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/12/02/sigreturn-oriented-programming-srop-attack-gong-ji-yuan-li</id>
    <content type="html"><![CDATA[<p>这篇文章我已经投稿在<a href="http://www.freebuf.com/">Freebuf</a>上，可以参看<a href="http://www.freebuf.com/articles/network/87447.html">这里</a>。所以版权肯定是算Freebuf的，虽然是我写的，但是也只得算是转载吧。</p>

<!-- more -->


<p>这次之所以选择把文章投在freebuf上，主要原因还是想要赚点稿费。不过不得不提的是，freebuf的阅读访问量还是很大的，仅仅过了一天就有10000+的点击，虽然我觉得可能大部分人点进来之后也不会细看，而且确实没有相关背景也很难理解。</p>

<p>在自己的博客中存个档，当然希望大家还是去freebuf上支持下~</p>

<hr />

<p>去年在Wooyun投了<a href="http://drops.wooyun.org/tips/3071">一篇文章</a>，介绍<a href="http://www.scs.stanford.edu/brop/">BROP攻击</a>。反响还挺好的，也帮助了很多人去理解这个非常smart的攻击原理。当然大家也可以去<a href="http://ytliu.info/blog/2014/06/01/blind-return-oriented-programming-brop-attack-er/">我的博客</a>看这个攻击的重现。
这次我想介绍另一个类ROP攻击，叫SROP，也是发表在<a href="http://www.ieee-security.org/TC/SP2014">Oakland 2014</a>，被评选为当年的<a href="http://www.ieee-security.org/TC/SP2014/awards.html">Best Student Papers</a>。论文的题目叫做<code>Framing Signals — A Return to Portable Shellcode</code>，作者是来自Vrije Universiteit Amsterdam的Erik Bosman，以下是相关paper和slides的链接：</p>

<p><a href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf">paper</a></p>

<p><a href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf">slides</a></p>

<p>首先，我觉得这也是一个非常有趣的攻击，虽然在去年就已经发表了，但是我在网上并没有找到太多相关的信息，在最近一年的研究领域也没有太多对它的<a href="https://scholar.google.com/scholar?cites=5919093237976555977&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN">引用</a>，所以我觉得很有必要推广一下。但是在我看完paper之后，觉得这篇paper写得并不是很容易让人理解，很多句子都晦涩难懂，不过这些都不重要，重要的是，这个攻击确实很有效，里面提到，在不同版本的Unix系统（如GNU Linux，BSD，iOS/Mac OS X等）中被使用了40多年的Signal机制，存在一个很容易被攻击者利用的设计缺陷，而这个缺陷所产生的相应的攻击，即文中所描述的SROP，和传统的ROP攻击相比显得更加简单，可靠，可移植。</p>

<p>接下来，我会从ROP攻击开始讲起，然后引入SROP的攻击原理，其中会涉及到Signal机制的相关背景，最后，我会介绍一些相应的防御措施。</p>

<h3>ROP背景介绍</h3>

<h4>ROP攻击的出现</h4>

<p><a href="https://zh.wikipedia.org/wiki/Stack_Overflow">Stack Overflow</a>和<a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">DEP (Data Execution Prevention)</a>我在这里就不介绍了，简单来说，就是最早的code injection攻击在现在的操作系统中基本上不能使用，因此出现了ROP，也就是所谓的Return Oriented Programming，其中也包括比较早期的Return-to-libc。ROP的主要思想就是攻击者不需要自己注入代码（因为在DEP的保护下，注入的代码不可执行），而是利用系统已有的代码片段来构造攻击。这里之所以叫ROP，是因为其改变控制流的方式是用系统中的return指令（比如x86中的<code>ret</code>）。</p>

<p>这里需要说明的是，在栈操作中，return指令是唯一一个可以通过控制栈上的数据改变指令流的指令，它的效果等同于：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pop</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">jmp</span> <span class="o">%</span><span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>即将IP设置成栈上的某个值。因此如果我们可以控制栈上的数据，就可以控制执行流。</p>

<h4>ROP攻击的原理</h4>

<p>这里举一个最简单的例子来说明如何利用ROP来实现一条内存赋值语句：<code>Mem[v2] = v1</code>，其中<code>v2</code>是一个内存地址，<code>v1</code>是一个值。</p>

<p><img src="http://ytliu.info/images/2015-11-27-1.png" title="Simple ROP Example" alt="ROP example" /></p>

<p>这里我们先把<code>Mem[v2] = v1</code>这条内存赋值语句转化成汇编代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">mov</span> <span class="o">%</span><span class="n">eax</span> <span class="n">v1</span><span class="p">;</span>
</span><span class='line'><span class="n">mov</span> <span class="o">%</span><span class="n">ebx</span> <span class="n">v2</span><span class="p">;</span>
</span><span class='line'><span class="n">mov</span> <span class="p">[</span><span class="o">%</span><span class="n">ebx</span><span class="p">],</span> <span class="o">%</span><span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>将<code>v1</code>的值赋给<code>%eax</code>，将<code>v2</code>的值（即内存地址）赋给<code>%ebx</code>，最后将<code>%eax</code>的值赋给<code>%ebx</code>地址指向的内存。</p>

<p>我们将这段代码翻译成可以通过ROP的方式执行的代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">addr1:</span> <span class="n">pop</span> <span class="n">eax</span><span class="p">;</span> <span class="n">ret</span>
</span><span class='line'><span class="nl">addr2:</span> <span class="n">pop</span> <span class="n">ebx</span><span class="p">;</span> <span class="n">ret</span>
</span><span class='line'><span class="nl">addr3:</span> <span class="n">mov</span> <span class="p">[</span><span class="n">ebx</span><span class="p">],</span> <span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中<code>addr1</code>、<code>addr2</code>、<code>addr3</code>都是相应指令的内存地址，我们将每一行称为一个“gadget”。通过像上图中那样构造栈上的数据就可以完成和上面汇编相同的效果。如果不清楚可以自己代入试一试，这里就不详述了。</p>

<p>你可能会问，单纯构造一个内存赋值语句有什么用呢？其中最广泛的应用就是为参数赋值。假设我们希望用ROP的方式调用一个system call，那么我们就可以用上面的这种方式为这个system call填上参数，最后在栈上填上<code>syscall</code>（或者<code>int 80</code>）指令的内存地址就可以了。</p>

<h4>ROP攻击的前提条件</h4>

<p>讲到这里，如果你对上面有了初步的理解，就可能会觉得好像ROP确实很厉害，能够随意调用system call（比如调用<code>execve</code>来开启一个shell；或者调用<code>mprotect</code>来将栈设置成可执行，等等）。然而事实上ROP并没有想象中的那么简单。要完成一个成功的ROP攻击，需要有很多前提条件，这里列举几个最重要的：</p>

<ul>
<li>首先必须要有一个buffer overflow的漏洞（当然这个前提基本上所有攻击都必须得有）；</li>
<li>攻击者需要事先决定好完成攻击过程的所有gadgets。对于上面提到的赋值操作，总共只需要3个gadgets，每个gadget最长两条指令，但是如果需要进行一些复杂的操作，就有可能需要有很多gadgets；除了gadgets的数量多之外，单个gadget的指令数也需要考虑；</li>
<li>攻击者需要在被攻击程序所在的进程地址空间中找到所有的这些gadgets的首地址，并且将其填在栈的合适位置上。</li>
</ul>


<p>这三个前提条件，造成了传统的ROP对于攻击者来说具备了一定的难度，加上现在操作系统中的一系列保护机制（比如ASLR），使得寻找gadgets的地址变得更难了。而且对于攻击者来说，他攻击每个不同的应用程序都需要单独精心构造大量的gadgets，这也使得ROP的可复用性变得很差。</p>

<p>以上的这些，都是我们接下来将要介绍的SROP所想要解决的问题。</p>

<h3>SROP攻击原理</h3>

<p>SROP的全称是Sigreturn Oriented Programming。在这里<code>sigreturn</code>是一个系统调用，它在unix系统发生signal的时候会被间接地调用。</p>

<p>在开始介绍SROP的攻击原理之前，我们需要先对signal的背景进行一个简单的说明。</p>

<h4>Signal in Unix-like System</h4>

<p>Signal这套机制在1970年代就被提出来并整合进了UNIX内核中，它在现在的操作系统中被使用的非常广泛，比如内核要杀死一个进程（<code>kill -9 $PID</code>），再比如为进程设置定时器，或者通知进程一些异常事件等等。</p>

<p>如下图所示，当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）。</p>

<p><img src="http://ytliu.info/images/2015-11-27-2.png" title="Process of Signal Handling" alt="Signal Process" /></p>

<p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p>

<p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p>

<p><img src="http://ytliu.info/images/2015-11-27-3.png" title="Signal Frame" alt="Signal Frame" /></p>

<p>我们将这段内存称为一个<code>Signal Frame</code>。</p>

<p>在内核<code>sigreturn</code>系统调用处理函数中，会根据当前的栈指针指向的<code>Signal Frame</code>对进程上下文进行恢复，并返回用户态，从挂起点恢复执行。</p>

<p>看到这里，你看出什么问题了吗？如果还没有，建议你再倒回去仔细想想，因为我马上就要揭晓答案了。</p>

<h4>Signal机制缺陷利用</h4>

<p>好了，我们先来看看内核在这个过程中扮演了什么角色？首先，内核替用户进程将其上下文保存在<code>Signal Frame</code>中，然后，内核利用这个<code>Signal Frame</code>恢复用户进程的上下文，done！那么，问题来了：</p>

<ul>
<li>第一，这个<code>Signal Frame</code>是被保存在用户进程的地址空间中的，是用户进程可读写的；</li>
<li>第二，内核并没有将保存的过程和恢复的过程进行一个比较，也就是说，在<code>sigreturn</code>这个系统调用的处理函数中，内核并没有判断当前的这个<code>Signal Frame</code>就是之前内核为用户进程保存的那个<code>Signal Frame</code>。</li>
</ul>


<p>按照作者slides里面的说法，“kernel agnostic about signal handlers”既是一个优点，因为内核不需要花精力来记录其发起的signal，但是，这也是一个缺点，正因为内核对其的不可知性，使得恶意的用户进程可以对其进行伪造！</p>

<h4>例子：一个最简单的攻击</h4>

<p>让我们先来假设一个攻击者可以控制用户进程的栈，那么它就可以伪造一个<code>Signal Frame</code>，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-4.png" title="Faked Signal Frame" alt="Fake Signal Frame" /></p>

<p>在这个伪造的<code>Signal Frame</code>中，将<code>rax</code>设置成59（即<code>execve</code>系统调用号），将<code>rdi</code>设置成字符串<code>/bin/sh</code>的地址（该字符串可以是攻击者写在栈上的），将<code>rip</code>设置成系统调用指令<code>syscall</code>的内存地址，最后，将<code>rt_sigreturn</code>手动设置成<code>sigreturn</code>系统调用的内存地址。那么，当这个伪造的<code>sigreturn</code>系统调用返回之后，相应的寄存器就被设置成了攻击者可以控制的值，在这个例子中，一旦<code>sigreturn</code>返回，就会去执行<code>execve</code>系统调用，打开一个shell。</p>

<p>这是一个最简单的攻击。在这个攻击中，有4个前提条件：</p>

<ul>
<li>第一，攻击者可以通过stack overflow等漏洞控制栈上的内容；</li>
<li>第二，需要知道栈的地址（比如需要知道自己构造的字符串<code>/bin/sh</code>的地址）；</li>
<li>第三，需要知道<code>syscall</code>指令在内存中的地址；</li>
<li>第四，需要知道<code>sigreturn</code>系统调用的内存地址；</li>
</ul>


<p>和传统的ROP相比，这个最简单的SROP攻击只需要找到两个gadgets就可以了。但是在这个攻击中，攻击者所产生的效果只能调用一个syscall，当syscall返回之后就失去了对执行流的控制了，显然不能满足大部分要求。</p>

<h4>利用SROP构造系统调用串（System Call Chains）</h4>

<p>那么，我们如何利用上面这套机制来连续地进行系统调用呢？其实方法很简单，除了上面的步骤之外，只需要再额外添加一个对栈指针<code>rsp</code>的控制就行了，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-5.png" title="Faked Signal Frame for System Call Chain" alt="System Call Chain" /></p>

<p>另外我们需要把原来单纯的<code>syscall</code> gadget换成<code>syscall; ret</code> gadget。在这个过程中，每次<code>syscall</code>返回之后，栈指针都会指向下一个<code>Signal Frame</code>，因此，在这个时候执行<code>ret</code>指令，就会再次调用<code>sigreturn</code>系统调用。这样就可以通过操作栈来达到连续进行系统调用的效果。</p>

<h4>两个重要的gadgets</h4>

<p>那么，我们在哪里能找到上面提到的这两个gadgets呢？</p>

<p>对于第一个gadget <code>sigreturn</code>，这里需要提一下，<code>sigreturn</code>这个系统调用和别的系统调用有一个不同的地方，即一般的应用程序不会主动调用它，而是像之前介绍的，由内核将相应地址填到栈上，使得应用进程被动地调用。因此在系统中一般会有一段代码专门用来调用<code>sigreturn</code>，论文作者发现，在不同的类UNIX系统中，这段代码会出现在不同的位置，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-6.png" title="sigreturn gadget in memory" alt="sigreturn gadget location" /></p>

<p>其中在<code>Linux &lt; 3.11 ARM</code>（也就是大部分现在Android所使用的内核），以及<code>FreeBSB 9.2 x86_64</code>，都可以在固定的内存地址中找到这个gadget，而在其它系统中，一般被保存在<code>libc</code>库的内存中，如果有ASLR保护的话似乎没有那么容易找到。</p>

<p>而对于第二个gadget <code>syscall; ret</code>，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-7.png" title="syscall ret gadget in memory" alt="syscall ret gadget location" /></p>

<p>如果是<code>Linux &lt; 3.3 x86_64</code>（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），则可以直接在固定地址[vsyscall]中找到这段代码片段。其中<code>vsyscall</code>是用来加速<code>time()</code>，<code>gettimeofday()</code>和<code>getcpu()</code>这三个系统调用的机制，虽然现在已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制所代替，但在稍微比较早一点的内核中依然是被默认支持的。具体可以看<a href="http://lwn.net">lwn</a>的<a href="https://lwn.net/Articles/446528/">这个post</a>。</p>

<p>除了上面提到的这两个可能存在在固定地址的gadgets之外，在其它系统中，这两个gadgets似乎并没有那么容易找到，特别是在有ALSR保护的系统中。但是，如果我们将其和传统的ROP来进行比较的话，就可以发现，它把整个攻击的代价拉低了一个档次，难怪作者认为SROP "is among the lowest hanging fruit available to an attacker."</p>

<h4><code>sigreturn</code>这个gadget是必须的吗？</h4>

<p>如果我们将<code>sigreturn</code>当做一个系统调用来看待的话，那么其实这个单独的gadget并不是必须的。因为我们可以将<code>rax</code>寄存器设置成15（sigreturn的系统调用号），然后调用一个<code>syscall</code>，效果和调用一个<code>sigreturn</code>是一样一样的。那么，问题就从“如何找到一个<code>sigreturn</code> gadget”变成了“如何控制寄存器<code>rax</code>的值”。而<code>rax</code>这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制<code>rax</code>寄存器的值。具体的做法因人而异，但是这为攻击者提供了另外一个思路，有兴趣可以去看论文。在论文中，简单来说，作者在受害者进程调用对网络文件描述符进行<code>read</code>系统调用的时候传输不同数量的字节数来控制<code>read</code>调用的返回值，来最终达到控制<code>rax</code>寄存器的效果的，非常smart的一个做法！</p>

<h4>SROP应用场景</h4>

<p>正如上文所说，利用SROP，我们可以构造一系列的系统调用串，利用这个方法，我们可以做很多事情。</p>

<h5>应用场景一：后门（Backdoor）</h5>

<p>首先，作者提出，可以通过这种方法构造一个后门（backdoor）。后门的意思就是攻击者在系统中隐藏一个可以被触发的点，当某些比较少见的特定操作发生之后，会触发一个动作，这个动作一般是打开一个端口让攻击者通过网络连接进系统，从而对系统进行控制。后门最重要的特点是隐蔽，不容易被杀毒软件检查出来。所以说如果后门是一段可执行代码，那么就很容易被杀毒软件检测到，而如果后门是隐藏在数据域中，那么就能做到非常隐蔽。SROP就为其提供了一个强有力的工具：system call chain。整个过程如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-8.png" title="SROP backdoor" alt="SROP backdoor" /></p>

<p>在这个过程中，攻击者利用<code>inotify API</code>来监控一个文件，当这个文件被访问（比如攻击者在发起的请求中读取这个文件的内容），则后续的系统调用链被触发，打开一个socket，等待连接。同时通过一个<code>alarm</code>系统调用设置一个定时器，如果在5秒钟没有人对这个socket发起连接请求，则将其关闭，否则建立连接，并调用<code>execve</code>系统调用打开一个shell。</p>

<p>这就是一个典型的后门，可以用SROP完成。</p>

<h5>应用场景二：系统调用代理（System call proxy）</h5>

<p>在这个应用场景中，作者提到了如何绕过诸如<code>iOS</code>、<code>Mac OS X</code>等系统进行的代码签名（code signing）保护机制。在代码签名保护机制下，程序中不能存在恶意代码片段（否则无法经过Apple官方的验证）。但是SROP可以解决这个问题，我们可以在代码中进行一个网络连接，然后通过构造特定的请求来执行一些恶意的操作。在这里，作者提出一种系统调用代理的机制，原理和我之前介绍的系统调用串的原理差不多，就是通过执行一系列的<code>read</code>系统调用来设置各个参数，最后利用这些参数构造一个特定的系统调用，如下如所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-9.png" title="SROP syscall proxy" alt="SROP syscall proxy" /></p>

<h3>SROP的防范</h3>

<p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p>

<h4>Gadgets Prevention</h4>

<p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p>

<p>当然这种方法并不能从本质上解决SROP的问题。</p>

<h4>Signal Frame Canaries</h4>

<p>这种方法借鉴于<a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p>

<p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p>

<h4>Break kernel agnostic</h4>

<p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p>

<h3>Proof of Concept（PoC）</h3>

<p>如果大家对这个攻击感兴趣，可以从这里下载一个非常简单的<a href="https://github.com/eQu1NoX/srop-poc">PoC</a>，当然按照其作者的说法，SROP已经被整合进<a href="https://binjitsu.readthedocs.org/">binjitsu</a>这个框架了。之后如果有时间，我也会对这个PoC以及binjitsu框架做一个介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hooking and Hijacking Android Native Code]]></title>
    <link href="http://ytliu.github.io/blog/2015/11/15/hooking-and-hijacking-android-native-code/"/>
    <updated>2015-11-15T15:04:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/11/15/hooking-and-hijacking-android-native-code</id>
    <content type="html"><![CDATA[<p>首先声明这是一篇中文博客。</p>

<p>先强烈推荐下<a href="http://appsrv.cse.cuhk.edu.hk/~mzheng/">Zheng Min</a>大神的<a href="http://drops.wooyun.org/author/%E8%92%B8%E7%B1%B3">安卓动态调试七种武器系列文章</a>，里面已经有两篇介绍我这次所要介绍的hooking的内容了，而且应该会比我这篇的内容更丰富。然而，任性的我还是要写这篇博客，原因除了自己太久没写博客了有点不好意思之外，更重要的是希望在写的过程中来理解这个技术。</p>

<p>当然了，这篇博文主要还是代码分析，采用的是<a href="http://www.mulliner.org/collin/">Collin Mulliner</a>的这个项目<a href="https://github.com/crmulliner/adbi">adbi</a>。当然他自己也有一个专门的<a href="http://www.mulliner.org/android/feed/binaryinstrumentationandroid_mulliner_summercon12.pdf">slide</a>来介绍里面用到的技术。</p>

<!-- more -->


<p>好了，开始进入正文。</p>

<p>首先clone这个项目：</p>

<pre><code>$ git clone https://github.com/crmulliner/adbi.git
</code></pre>

<p>在具体分析代码之前先简单介绍下这个项目的目的、用法、以及流程吧：</p>

<h4>目的</h4>

<p>对android中的某个进程所使用的某个native库<code>lib</code>中的某个函数<code>func</code>进行劫持，使得当这个进程调用到这个函数的时候，会首先进入我们的hook函数，在hook函数中做一些其它的事情，比如打印一些log之类的，然后再调用真正的函数<code>func</code>。</p>

<h4>用法</h4>

<ul>
<li><p>对项目进行编译，会生成一个可执行文件<code>hijack</code>和一个链接库文件<code>libexample.so</code>，将其放到<code>/data/local/tmp</code>目录下：</p>

<pre><code>$ adb push hijack/libs/armeabi/hijack /data/local/tmp/
$ adb push instruments/example/libs/armeabi/libexample.so /data/local/tmp/
</code></pre></li>
<li><p>然后进入android的adb shell里面，运行：</p>

<pre><code>$ adb shell
$ su
# cd /data/local/tmp
# ./hijack -d -p PID -l /data/local/tmp/libexample.so
</code></pre></li>
</ul>


<p>它的作用是劫持pid为<code>PID</code>的进程的<code>epoll_wait()</code>库函数调用，每当该函数被调用，就会进到<code>libexample.so</code>中的<code>my_epoll_wait()</code> hook函数，打印一行内容，并调用真正的<code>epoll_wait()</code>函数。</p>

<h4>流程</h4>

<p>上面这整个hijacking和hooking的流程是这样的：</p>

<ul>
<li>在hijack的过程中，会将一段<code>hijack code</code>放在目标进程的栈上，调用<code>mprotect</code>将栈设置为可执行，并且将<code>mprotect</code>调用的返回值设置成这段<code>hijack code</code>的地址，因此，在mprotect返回时，就开始执行这段<code>hijack code</code>；</li>
<li>这段<code>hijack code</code>所做的事情就是调用<code>dlopen</code>，加载<code>libexample.so</code>链接库；</li>
<li>在<code>libexample.so</code>库的初始化函数中，对目标进程所调用的<code>libc</code>库中的<code>epoll_wait</code>函数进行hook；</li>
<li>之后，只要目标进程一调用<code>epoll_wait</code>函数，就会首先进入hook函数。</li>
</ul>


<hr />

<p>好了，这个流程看上去很简单，但是里面用到了很多Linux相关的知识，是一个很不错的介绍如何对进程进行hook和hijack的实例，接下来的篇幅就主要来介绍这整个流程是如何通过几百行C代码实现的。</p>

<h4>代码结构</h4>

<p>这是adbi项目的代码结构：</p>

<pre><code>|-hijack
  |-jni
    |-Android.mk
  |-hijack.c
|-instruments
  |-base
    |-jni
      |-Android.mk
      |-Application.mk
    |-base.c
    |-base.h
    |-hook.c
    |-hook.h
    |-util.c
    |-util.h
  |-example
    |-jni
      |-Android.mk
    |-epoll.c
    |-epoll_arm.c
|-README.md
|-build.sh
|-clean.sh
</code></pre>

<p>可以看到，里面主要有两个目录：<code>hijack</code>和<code>instruments</code>。其中，<code>hijack</code>主要作用就是之前流程里面说的第一步，即：</p>

<ul>
<li>将一段<code>hijack code</code>放在目标进程的栈上，调用<code>mprotect</code>将栈设置为可执行，并且将<code>mprotect</code>调用的返回值设置成这段<code>hijack code</code>的地址，因此，在mprotect返回时，就开始执行这段<code>hijack code</code>。</li>
</ul>


<p>而<code>instruments</code>目录中包含了两个子目录，一个是<code>base</code>，主要是一些可以被调用的库函数，它最终会被编译成<code>libbase.a</code>静态链接库；另外一个是<code>example</code>，它用了一个非常简单的例子来展示如何利用<code>libbase.a</code>做hook，即之前流程里面的第三步：</p>

<ul>
<li>在<code>libexample.so</code>库的初始化函数中，对目标进程所调用的<code>libc</code>库中的<code>epoll_wait</code>函数进行hook。</li>
</ul>


<h4>hijack</h4>

<p>hijack目录中只有一个代码文件：<code>hijack.c</code>，以及一个和编译相关的文件：<code>jni/Android.mk</code>。</p>

<p>我们先来看这个<code>Android.mk</code>：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">hijack</span>
</span><span class='line'> <span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">hijack</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'> <span class="n">LOCAL_ARM_MODE</span> <span class="o">:=</span> <span class="n">arm</span>
</span><span class='line'> <span class="n">LOCAL_CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="n">g</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_EXECUTABLE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其实这就是一个很典型的Android应用的jni的编译文件，表示它要用<code>../hijack.c</code>这个源文件编译一个可执行文件（<code>$(BUILD_EXECUTABLE)</code>）<code>hijack</code>。</p>

<p>关于<code>hijack.c</code>这个文件，我们先来看一下<code>main</code>函数：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">while</span> <span class="p">((</span><span class="n">opt</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;p:l:dzms:Z:D:&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">...</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nomprotect</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;mprotect&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">mprotectaddr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">void</span> <span class="o">*</span><span class="n">ldl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libdl.so&quot;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ldl</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">dlopenaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">ldl</span><span class="p">,</span> <span class="s">&quot;dlopen&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dlclose</span><span class="p">(</span><span class="n">ldl</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">lkaddr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">lkaddr2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="n">lkaddr2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlopenaddr</span> <span class="o">-</span> <span class="n">lkaddr</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// Attach</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot attach to %d, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span><span class='line'><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">appname</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">zygote</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;/proc/%d/mem&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span><span class='line'>  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">regs</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">sc</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r3</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlopenaddr</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// push library name to stack</span>
</span><span class='line'>  <span class="n">libaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">libaddr</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">stack_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">stack_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class='line'><span class="n">stack_start</span> <span class="o">=</span> <span class="n">stack_start</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'><span class="n">stack_end</span> <span class="o">=</span> <span class="n">stack_start</span> <span class="o">+</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// write library name to stack</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">libaddr</span><span class="p">))</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write library name (%s) to stack, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// write code to stack</span>
</span><span class='line'>  <span class="n">codeaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">codeaddr</span><span class="p">))</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write code, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// calc stack pointer</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// call mprotect() to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span> <span class="o">=</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// want to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span> <span class="o">=</span> <span class="n">stack_end</span> <span class="o">-</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// stack size</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span> <span class="o">=</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">;</span> <span class="c1">// protections&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// normal mode, first call mprotect</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nomprotect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// points to loading and fixing code</span>
</span><span class='line'><span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">mprotectaddr</span><span class="p">;</span> <span class="c1">// execute mprotect()</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// no need to execute mprotect on old Android versions</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// just execute the &#39;shellcode&#39;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// detach and continue</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">regs</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">SIGCONT</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里主要有几个重要的步骤：</p>

<ul>
<li>parse传进来的参数，这个这里就不解释了；</li>
<li>定位目标进程中<code>mprotect</code>函数的内存地址；</li>
<li>定位目标进程中<code>dlopen</code>函数的内存地址；</li>
<li>利用<code>ptrace</code>调用attach目标进程；</li>
<li>构建hijack所需要的context，这里是一个数据结构<code>sc</code>；</li>
<li>将<code>sc</code>写到栈上；</li>
<li>利用之前得到的<code>mprotect</code>将栈设置成可执行，并将<code>mprotect</code>的返回值设置成<code>sc</code>数据结构中的code首地址；</li>
<li>利用<code>ptrace(PTRACE_SETREGS)</code>设置目标进程的寄存器，使得上面的所有修改生效。</li>
</ul>


<p>这个时候目标进程就开始执行<code>mprotect</code>和<code>sc</code>中的code代码了。</p>

<p>接下来我们来逐一介绍各个步骤：</p>

<h5>定位目标进程中<code>mprotect</code>函数的内存地址；</h5>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;mprotect&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">mprotectaddr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我们来看一下<code>find_name</code>：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span>
</span><span class='line'><span class="nf">find_name</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">addr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">load_memmap</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">nmm</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">find_libc</span><span class="p">(</span><span class="n">libc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">libc</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">libcaddr</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">nmm</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">load_symtab</span><span class="p">(</span><span class="n">libc</span><span class="p">);</span>
</span><span class='line'>  <span class="n">lookup_func_sym</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>里面主要分为四个步骤：</p>

<ul>
<li><code>load_memmap</code>：主要是通过读取特定<code>/proc/PID/maps</code>文件，获得该进程打开的所有动态链接库的地址和其它相关内存地址（如栈的地址），并将所有这些信息存储在<code>mm</code>这个数据结构中；</li>
<li><code>find_libc</code>：在mm中查找<code>libc</code>，并将其首地址填到<code>libcaddr</code>变量中；</li>
<li><code>load_symtab</code>：打开libc对应的库文件，根据elf格式将里面的symbol table解析出来，并且填入数据结构<code>symtab_t</code>中，并返回；</li>
<li><code>lookup_func_sym</code>：在这一堆的symbol table里面找到对应的函数名，并且写入变量<code>addr</code>中。</li>
</ul>


<p>通过以上四个步骤，即可得到进程中<code>mprotect</code>的内存地址。</p>

<h5>定位目标进程中<code>dlopen</code>函数的内存地址；</h5>

<p>获取<code>dlopen</code>的方法和之前获取<code>mprotect</code>的方法不太一样，主要原因是在于<code>dlopen</code>所在的库<code>libdl.so</code>在程序运行时是不会显示在该进程对应的<code>/proc/PID/maps</code>中的，因此需要先在本进程中先用<code>dlopen</code>开启<code>libdl.so</code>，然后通过相对地址的计算方法来获得目标进程中dlopen的内存地址，具体步骤如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ldl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libdl.so&quot;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ldl</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">dlopenaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">ldl</span><span class="p">,</span> <span class="s">&quot;dlopen&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">dlclose</span><span class="p">(</span><span class="n">ldl</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">lkaddr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">lkaddr2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="n">lkaddr2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlopenaddr</span> <span class="o">-</span> <span class="n">lkaddr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<ul>
<li>首先在本进程调用<code>dlopen</code>打开<code>libdl.so</code>（dlopen的用法可参照<a href="http://linux.die.net/man/3/dlopen">这里</a>)；</li>
<li>利用<code>dlsym</code>获得<code>libdl.so</code>中<code>dlopen</code>函数的内存地址；</li>
<li>分别获得本进程和目标进程中<code>linker</code>的地址；</li>
<li>通过<code>dlopen</code>和<code>linker</code>的相对偏移一样的原理来计算目标进程中<code>dlopen</code>的真正内存地址。</li>
</ul>


<p>获得linder的内存地址的方法和获得<code>mprotect</code>函数内存地址的方法类似，这里就不阐述了，主要代码在<code>find_linker_mem</code>和<code>find_linker</code>这两个函数中。</p>

<h5>利用<code>ptrace</code>调用attach目标进程；</h5>

<p>这个步骤就两句话：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class="c1">// Attach</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>至于什么是<code>ptrace</code>和<code>waitpid</code>，以及如何使用它们，请参考我之前的一篇博客：<a href="http://ytliu.info/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace/">系统调用学习笔记 - Ptrace和wait</a>，这里就不详细说了。</p>

<h5>构建hijack所需要的context，这里是一个数据结构<code>sc</code>；</h5>

<p>其实<code>sc</code>就是一个长度为20的<code>unsigned int</code>数组：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="mh">0xe59f0040</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #64]   ; 48 &amp;lt;.text+0x48&gt;</span>
</span><span class='line'><span class="mh">0xe3a01000</span><span class="p">,</span> <span class="c1">//        mov     r1, #0  ; 0x0</span>
</span><span class='line'><span class="mh">0xe1a0e00f</span><span class="p">,</span> <span class="c1">//        mov     lr, pc</span>
</span><span class='line'><span class="mh">0xe59ff038</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #56]   ; 4c &amp;lt;.text+0x4c&gt;</span>
</span><span class='line'><span class="mh">0xe59fd02c</span><span class="p">,</span> <span class="c1">//        ldr     sp, [pc, #44]   ; 44 &amp;lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe59f0010</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #16]   ; 30 &amp;lt;.text+0x30&gt;</span>
</span><span class='line'><span class="mh">0xe59f1010</span><span class="p">,</span> <span class="c1">//        ldr     r1, [pc, #16]   ; 34 &amp;lt;.text+0x34&gt;</span>
</span><span class='line'><span class="mh">0xe59f2010</span><span class="p">,</span> <span class="c1">//        ldr     r2, [pc, #16]   ; 38 &amp;lt;.text+0x38&gt;</span>
</span><span class='line'><span class="mh">0xe59f3010</span><span class="p">,</span> <span class="c1">//        ldr     r3, [pc, #16]   ; 3c &amp;lt;.text+0x3c&gt;</span>
</span><span class='line'><span class="mh">0xe59fe010</span><span class="p">,</span> <span class="c1">//        ldr     lr, [pc, #16]   ; 40 &amp;lt;.text+0x40&gt;</span>
</span><span class='line'><span class="mh">0xe59ff010</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #16]   ; 44 &amp;lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r0</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r1</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r2</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r3</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     lr</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     pc</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     sp</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     addr of libname</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     dlopenaddr</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中，<code>sc[0]</code>~<code>sc[10]</code>是一段汇编指令，而<code>sc[11]</code>~<code>sc[19]</code>则是保存了<code>r0~r3</code>、<code>lr</code>、<code>pc</code>和<code>sp</code>这六个寄存器的值，以及需要加载的库libname的地址，和<code>dlopen</code>函数的内存地址。</p>

<p>其中，这六个寄存器的值是通过：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">regs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>从目标进程中获得的，而<code>dlopenaddr</code>就是之前获得的<code>dlopen</code>的地址。<code>libaddr</code>的获得是通过这段代码获得的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">libaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'><span class="n">sc</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">libaddr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中<code>n*4</code>是需要加载的库（即<code>/data/local/tmp/libexample.so</code>）的文件名长度，所以，<code>/data/local/tmp/libexample.so</code>这个字符串就被放在了<code>sc</code>数据结构的下方。</p>

<p>有了以上的值，我们来具体看看这段汇编指令到底在做什么：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe59f0040</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #64]   ; 48 &amp;lt;.text+0x48&gt;</span>
</span><span class='line'><span class="mh">0xe3a01000</span><span class="p">,</span> <span class="c1">//        mov     r1, #0  ; 0x0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里有一个trick需要先解释一下，即如何通过<code>pc</code>来进行寻址。<code>pc</code>即表示当前程序运行指令的内存地址，<code>[pc, #n]</code>则表示<code>pc+n</code>指针所指向的那个地址。但是这里有一点需要注意的，在我们执行这条语句的时候：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ldr</span>     <span class="n">r0</span><span class="p">,</span> <span class="p">[</span><span class="n">pc</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>pc</code>已经不再是当前指令的内存地址了，而是自动被加了8，即这里的<code>pc</code>其实是<code>pc+8</code>那条指令的内存地址，所以<code>[pc, #64]</code>其实指向的是和当前指令内存地址偏移72 bytes的地址，如果你算一下会发现是</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     addr of libname</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>所以，<code>r0</code>的值就是指向<code>/data/local/tmp/libexample.so</code>这个字符串的地址。而<code>r1</code>的值是1，即<code>RTLD_LAZY</code>的值。</p>

<p>而接下来的这两条指令：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe1a0e00f</span><span class="p">,</span> <span class="c1">//        mov     lr, pc</span>
</span><span class='line'><span class="mh">0xe59ff038</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #56]   ; 4c &amp;lt;.text+0x4c&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>首先将<code>pc</code>值（<code>pc+8</code>的地址）付给了<code>lr</code>，即调用完函数之后的返回值，然后同样利用<code>pc</code>的寻址方式将<code>dlopenaddr</code>的值赋给了<code>pc</code>，因此，接下来就会调用<code>dlopen</code>函数，第一个参数是<code>r0</code>的值，即指向<code>/data/local/tmp/libexample.so</code>字符串的指针，第二个参数是<code>r1</code>的值，即<code>RTLD_LAZY</code>。</p>

<p>当<code>dlopen</code>返回之后，程序的执行流会跳到<code>lr</code>指向的内存地址，即接下来的这段代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe59fd02c</span><span class="p">,</span> <span class="c1">//        ldr     sp, [pc, #44]   ; 44 &amp;lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe59f0010</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #16]   ; 30 &amp;lt;.text+0x30&gt;</span>
</span><span class='line'><span class="mh">0xe59f1010</span><span class="p">,</span> <span class="c1">//        ldr     r1, [pc, #16]   ; 34 &amp;lt;.text+0x34&gt;</span>
</span><span class='line'><span class="mh">0xe59f2010</span><span class="p">,</span> <span class="c1">//        ldr     r2, [pc, #16]   ; 38 &amp;lt;.text+0x38&gt;</span>
</span><span class='line'><span class="mh">0xe59f3010</span><span class="p">,</span> <span class="c1">//        ldr     r3, [pc, #16]   ; 3c &amp;lt;.text+0x3c&gt;</span>
</span><span class='line'><span class="mh">0xe59fe010</span><span class="p">,</span> <span class="c1">//        ldr     lr, [pc, #16]   ; 40 &amp;lt;.text+0x40&gt;</span>
</span><span class='line'><span class="mh">0xe59ff010</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #16]   ; 44 &amp;lt;.text+0x44&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>它的作用就是恢复这6个寄存器，最后会恢复<code>pc</code>，因此程序重新回到原来的执行流中。</p>

<p>总结一下，<code>sc</code>里面的<code>hijack code</code>的主要作用就是调用一下<code>dlopen</code>加载<code>/data/local/tmp/libexample.so</code>，然后回到正常的执行流中。</p>

<h5>将<code>sc</code>写到栈上；</h5>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// write code to stack</span>
</span><span class='line'>  <span class="n">codeaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">codeaddr</span><span class="p">))</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write code, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中，<code>write_mem</code>的实现非常简单，就是调用了<code>ptrace(PTRACE_POKETEXT)</code>将数据写到目标进程的内存空间中：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Write</span> <span class="n">NLONG</span> <span class="mi">4</span> <span class="n">byte</span> <span class="n">words</span> <span class="n">from</span> <span class="n">BUF</span> <span class="n">into</span> <span class="n">PID</span> <span class="n">starting</span>
</span><span class='line'>   <span class="n">at</span> <span class="n">address</span> <span class="n">POS</span><span class="p">.</span>  <span class="n">Calling</span> <span class="n">process</span> <span class="n">must</span> <span class="n">be</span> <span class="n">attached</span> <span class="n">to</span> <span class="n">PID</span><span class="p">.</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span>
</span><span class='line'><span class="n">write_mem</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlong</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">nlong</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKETEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">pos</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h5>利用之前得到的<code>mprotect</code>将栈设置成可执行，并将<code>mprotect</code>的返回值设置成<code>sc</code>数据结构中的code首地址；</h5>

<p>代码如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// calc stack pointer</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// call mprotect() to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span> <span class="o">=</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// want to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span> <span class="o">=</span> <span class="n">stack_end</span> <span class="o">-</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// stack size</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span> <span class="o">=</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">;</span> <span class="c1">// protections&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// normal mode, first call mprotect</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nomprotect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// points to loading and fixing code</span>
</span><span class='line'><span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">mprotectaddr</span><span class="p">;</span> <span class="c1">// execute mprotect()</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// no need to execute mprotect on old Android versions</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// just execute the &#39;shellcode&#39;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>主要就是计算出栈的首地址和长度，然后将目标进程的<code>pc</code>设置成<code>mprotectaddr</code>，将返回地址<code>lr</code>设置成<code>sc</code>中<code>hijack code</code>的起始地址。这样在调用完<code>mprotect</code>之后就能直接执行<code>hijack code</code>了。</p>

<h5>利用<code>ptrace(PTRACE_SETREGS)</code>设置目标进程的寄存器，使得上面的所有修改生效。</h5>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// detach and continue</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">regs</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">SIGCONT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>至此，hijack的全部功能就实现了，现在<code>/data/local/tmp/libexample.so</code>已经被加载到了目标进程的内存空间中，接下来就要看下这个库里面到底是如何实现特定函数的hook的。</p>

<h4>hook</h4>

<p>在<code>instruments</code>这个目录下有两个子目录，其中<code>base</code>相当于是一个函数库，它会被编译成静态链接库<code>libbase.a</code>，我们可以看下<code>instruments/base/jni/Android.mk</code>这个文件：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">util</span><span class="p">.</span><span class="n">c</span> <span class="p">..</span><span class="o">/</span><span class="n">hook</span><span class="p">.</span><span class="n">c</span> <span class="p">..</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">LOCAL_ARM_MODE</span> <span class="o">:=</span> <span class="n">arm</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_STATIC_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>而<code>example</code>里面的代码会将<code>libbase.a</code>静态链接进来，然后生成一个动态链接库<code>libexample.so</code>，可以从其编译文件<code>instruments/example/jni/Android.mk</code>看出来：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'><span class="n">LOCAL_MODULE</span> <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">base</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">libbase</span><span class="p">.</span><span class="n">a</span>
</span><span class='line'><span class="n">LOCAL_EXPORT_C_INCLUDES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">base</span>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">PREBUILT_STATIC_LIBRARY</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">libexample</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">epoll</span><span class="p">.</span><span class="n">c</span>  <span class="p">..</span><span class="o">/</span><span class="n">epoll_arm</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">arm</span>
</span><span class='line'><span class="n">LOCAL_CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="n">g</span>
</span><span class='line'><span class="n">LOCAL_SHARED_LIBRARIES</span> <span class="o">:=</span> <span class="n">dl</span>
</span><span class='line'><span class="n">LOCAL_STATIC_LIBRARIES</span> <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_SHARED_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个example非常简单，它也只有一个文件（<code>epoll.c</code>），里面只有几十行代码，我们先来看下这个库的初始化函数<code>my_init</code>，这个函数会在该库被加载的时候运行一次：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">counter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">log</span><span class="p">(</span><span class="s">&quot;%s started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="kt">FILE</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">set_logfunction</span><span class="p">(</span><span class="n">my_log</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">eph</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="s">&quot;libc.&quot;</span><span class="p">,</span> <span class="s">&quot;epoll_wait&quot;</span><span class="p">,</span> <span class="n">my_epoll_wait_arm</span><span class="p">,</span> <span class="n">my_epoll_wait</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>里面主要是调用了<code>libbase.a</code>提供的<code>hook</code>函数（源文件为<code>instruments/base/hook.c</code>）：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">libname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">funcname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">hook_arm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hook_thumb</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">libname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">addr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strncpy</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">thumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">hook_arm</span><span class="p">;</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe59ff000</span><span class="p">;</span> <span class="c1">// LDR pc, [pc, #0]</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个函数其实是区分了ARM指令集和THUMB指令集的，为了简化，我们暂时只考虑ARM指令，即这里的<code>(addr % 4 == 0)</code>的情况。</p>

<p>首先，这里先找到需要被hook的目标库（<code>libname</code>）的目标函数（<code>funcname</code>）的内存地址，这里需要注意的，由于<code>libexample.so</code>这个库已经是在目标进程的进程空间中运行了，所以其获得的地址即为目标函数在目标进程中的地址。这里的<code>find_name</code>所用到的技术和<code>hijack.c</code>里面用到的技术基本是一样的，这里就不详述了。</p>

<p>在获得目标函数代码的首地址之后，将其赋值给<code>h-&gt;orig</code>这个变量，将这个该函数的前三条指令保存在<code>h-&gt;store</code>这个数组中，并将以下三条指令覆盖（overwrite）目标函数的前三条指令：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe59ff000</span><span class="p">;</span> <span class="c1">// LDR pc, [pc, #0]</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中，<code>h-&gt;patch</code>即为hook函数的地址，在example里面是<code>my_epoll_wait</code>。同样的，这里又一次用到了利用<code>pc</code>进行寻址的技术，可以看前面的内容，这里也不详述了。</p>

<p>最后，调用了一个<code>hook_cacheflush</code>函数：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个函数的主要作用就是刷新指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了，再执行的话，CPU可能会优先执行缓存中的指令，使得修改的指令得不到执行。所以我们需要使用一个隐藏的系统调用来刷新一下缓存。</p>

<p>至此，目标进程目标函数的hook工作也就完成了。最后我们来看一下这个hook函数<code>my_epoll_wait</code>做了什么：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">my_epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">orig_epoll_wait</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">eph</span><span class="p">.</span><span class="n">orig</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">hook_precall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">eph</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">orig_epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">counter</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">hook_postcall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">eph</span><span class="p">);</span>
</span><span class='line'><span class="n">log</span><span class="p">(</span><span class="s">&quot;epoll_wait() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">counter</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">counter</span><span class="p">)</span>
</span><span class='line'>  <span class="n">log</span><span class="p">(</span><span class="s">&quot;removing hook for epoll_wait()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其实这个函数非常简单，就是在前<code>count</code>次调用<code>epoll_wait</code>的时候打印一下。这里面有两个<code>libbase.a</code>中的函数：<code>hook_precall</code>和<code>hook_postcall</code>。我们来分别看一下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">hook_precall</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">storet</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">store</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>hook_precall</code>的主要作用是恢复目标函数的前三条指令，这里同样对ARM指令和THUMB指令做了区分。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">hook_postcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jumpt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">jump</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>而<code>hook_postcall</code>则是重新用hook函数覆盖目标函数的前三条指令。</p>

<hr />

<p>好了，到这里，adbi里面的代码基本上就分析完了。最后简单描述下什么是ARM指令和THUMB指令吧。</p>

<h4>ARM vs. THUMB</h4>

<p>在传统的RISC模式的指令集中，指令都是定长的，比如ARM指令的长度都是32-bits。定长的好处在于处理器处理起来效率高，但是缺点也是显而易见的，即浪费空间。所以又引入了THUMB指令。</p>

<p>THUMB指令可以看作是ARM指令压缩形式的子集，所谓子集，即THUMB指令集中的所有指令都可以被32-bits的ARM指令所替代，而并非所有ARM指令都有对应的THUMB指令。</p>

<p>所以可以说THUMB模式是ARM在时间和空间中的一个权衡，因此，在普通的ARM可执行文件中，ARM指令和THUMB指令是同时存在的，所以在做诸如分析、攻击等操作的时候需要同时考虑两种模式的存在，这也是adbi为什么会需要区分对待ARM和THUMB的原因吧。</p>

<p>ARM和THUMB的具体区别这里就不介绍了，网上这种资料一搜一大堆，有兴趣的还是自己慢慢研究吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Wifi Pineapple]]></title>
    <link href="http://ytliu.github.io/blog/2015/09/03/chu-shi-wifi-pineapple/"/>
    <updated>2015-09-03T15:45:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/09/03/chu-shi-wifi-pineapple</id>
    <content type="html"><![CDATA[<p>前段时间乃正回国的时候叫他帮我带回来一个“大菠萝”——Wifi Pineapple！不过时隔了好久到现在才有时间和心情开始玩它：</p>

<p><img src="http://ytliu.info/images/2015-09-03-1.png" title="wifi pineapple" alt="wifi pineapple" /></p>

<p>这是干嘛的呢？用专业术语来说，它是一个专门用来做无线安全渗透测试的小机器，这个小机器内置了一个重度修改的OpenWRT网络操作系统，其拥有者可以让它成为一个对外提供无线网络信号的系统，然后通过一系列配置来对连接上它的客户端进行渗透测试。如果换个说法，这就是一个可以伪装成无线信号点的攻击利器，当你在一些公共场合（如学校、咖啡店）的时候如果不小心（有意或者无意）连上了这个无线信号，那不好意思，你上网的所有隐私都会被攻击者获取。</p>

<p>很直观的来说，如果你将这个大菠萝连上电源，启动之后（绿灯和蓝灯亮起）：</p>

<p><img src="http://ytliu.info/images/2015-09-03-2.png" title="wifi pineapple boot" alt="wifi boot" /></p>

<p>就可以在你其它设备（如手机、电脑）的无线信号中搜索出一个新的信号：</p>

<p><img src="http://ytliu.info/images/2015-09-03-7.png" title="new wifi result" alt="wifi search" /></p>

<p>如果你连接上这个信号，则你所有的流量就会走大菠萝这个系统，从而攻击者就可以通过一些中间人攻击的方法获取你所有隐私，或者植入恶意软件之类的了。</p>

<p>具体的可以看<a href="http://wiki.wifipineapple.com/#!pineapple.md">这里</a>，<a href="http://www.freebuf.com/tools/9265.html">这里</a>，以及<a href="http://www.freebuf.com/articles/wireless/30874.html">这里</a>。这里就不详述了。</p>

<!-- more -->


<h4>硬件接口</h4>

<p>Wifi pineapple有如下几个接口：</p>

<ul>
<li>如下图，从左到右依次为：以太网口，USB接口，电源接口；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-3.png" title="wifi pineapple interface 1" alt="wifi pineapple interface 1" /></p>

<p>其中以太网口可以用于连接计算机来<a href="http://wiki.wifipineapple.com/#!ics.md">共享计算机的无线网络</a>，USB接口可以用来连接Android手机来<a href="http://wiki.wifipineapple.com/#!ics.md#Android_ICS">共享手机的无线网络</a>，电源接口就是用来插电源线或者电池的。</p>

<ul>
<li>如下图：串口；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-4.png" title="wifi pineapple interface 2" alt="wifi pineapple interface 2" /></p>

<p>我们可以利用串口连接线（比如下图的CP2012模块）和计算机连接，然后通过串口这个通道来连Wifi pineapple，从而进行对其的配置：</p>

<p><img src="http://ytliu.info/images/2015-09-03-8.png" title="usb to ttl" alt="usb to ttl" /></p>

<ul>
<li>如下图：DIP switches；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-5.png" title="wifi pineapple interface 3" alt="wifi pineapple interface 3" /></p>

<p>用于控制启动的模式，比如可以对机器进行出厂值重置等。</p>

<ul>
<li>如下图：MicroUSB插槽。</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-6.png" title="wifi pineapple interface 4" alt="wifi pineapple interface 4" /></p>

<p>这相当于一个外部存储。</p>

<p>具体的这些硬件配置怎么用可以看<a href="http://wiki.wifipineapple.com/#">wifi pineapple的Wiki</a>。</p>

<p>另外，<a href="http://wiki.wifipineapple.com/#!pineapple_university.md#Hardware_Overview">这个视频</a>介绍的超级详细，强烈推荐！</p>

<h4>Wifi pineapple的启动</h4>

<p>当你插上电源，大菠萝就会自动启动。在第一次启动的时候会等比较久，因为它要进行初始化，比如找到查找文件，刷firmware之类的，在这个时候你可以看到各种颜色的灯一直闪着，不要着急，你可以参看下图来了解各个颜色的灯闪烁模式分别代表什么意思：</p>

<p><img src="http://ytliu.info/images/2015-09-03-9.png" title="wifi pineapple boot" alt="pineapple boot" /></p>

<p>也就是说在绿灯和蓝灯都完全亮起来（不再闪烁）的时候，就代表启动成功了。这个时候你查看你的wifi信号应该就可以看到大菠萝发出的信号了。</p>

<h4>连接和配置Wifi pineapple</h4>

<p>这个是最重要的，因为我希望对其具有完全的掌控权，所以我要能进到这个系统。最理想的方法是通过ssh登录进去，然后“为所欲为”。</p>

<p>其中Linux和Windows可以很方便的登录进去，如果你有一根网线的话。方法可以参看<a href="http://wiki.wifipineapple.com/#!ics.md">这里</a>。不过最方便的是用Android的USB Tether了，把大菠萝和android用USB连起来，然后在Android的<code>设置-&gt;无线和网络-&gt;网络共享和便携式热点</code>里面把<code>USB网络共享</code>打开就行了。然后就可以通过<code>ssh root@172.16.42.1</code>连接进去了。</p>

<p><img src="http://ytliu.info/images/2015-09-03-10.png" title="wifi pineapple ssh" alt="pineapple ssh" /></p>

<p>另外，当你知道wifi pineapple的IP之后，你也可以通过浏览器输入<code>172.16.42.1:1471</code>来访问其Web UI：</p>

<p><img src="http://ytliu.info/images/2015-09-03-11.png" title="wifi pineapple web ui" alt="pineapple web ui" /></p>

<p>有了这些之后，就可以干很多很多事啦！这些就是后话了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XSM-FLASK学习笔记]]></title>
    <link href="http://ytliu.github.io/blog/2015/06/10/xsm-flaskxue-xi-bi-ji/"/>
    <updated>2015-06-10T10:40:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/06/10/xsm-flaskxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>XSM-FLASK全称为：<strong>X</strong>en <strong>S</strong>ecurity <strong>M</strong>odules - <strong>FL</strong>ux <strong>A</strong>dvanced <strong>S</strong>ecurity <strong>K</strong>ernel。这篇博文对其进行一个简单的介绍，资料主要翻译自<a href="http://wiki.xen.org/wiki/Xen_Security_Modules_:_XSM-FLASK">这里</a>。</p>

<p>XSM是Xen提供的一个安全框架，允许管理者对整个系统进行细粒度的控制，换句话说，即运行管理者定义一套规则来管理虚拟机之间，虚拟机与Xen之间的交互，以及对系统资源（memory，device）的访问。</p>

<p>FLASK是XSM中的一个模块实现，当然，之后可能还有其他的模块，那就是后话了。下面是一些例子，列举了XSM-FLASK可以做的几件事：</p>

<ul>
<li>禁止两台虚拟机之间通过event channel和grant table进行通信；</li>
<li>将一些需要特权级别的操作安全地grant给某些非特权级虚拟机；</li>
<li>控制哪些虚拟机能使用device passthrough；</li>
<li>限制或者审计特权虚拟机中进行的某些特定操作；</li>
<li>限制特权虚拟机对其他虚拟机的任意内存映射；</li>
<li>将hypervisor中的不同模块（比如qemu和xenstore）进行隔离，防止它们之间互相影响。</li>
</ul>


<p>以上是一些基本说明，下面会具体介绍如何使用FLASK，以及FLASK中规则的一些语法定义。</p>

<!-- more -->


<hr />

<h3>FLASK及其policy的编译流程</h3>

<p>在Xen 4.3之后的版本都对FLASK进行了比较全面的支持，如果要开启FLASK，需要在编译Xen之前修改<code>Config.mk</code>文件，将<code>XSM_ENABLE</code>和<code>FLASK_ENABLE</code>设成<code>y</code>，然后再开始编译。</p>

<p>编译完Xen之后，需要编译FLASK的policy，在这之前需要先安装checkpolicy：</p>

<pre><code>$ aptitude install checkpolicy
</code></pre>

<p>然后编译：</p>

<pre><code>$ cd $XEN
$ make -C tools/flask/policy
</code></pre>

<p>之后会在<code>$XEN/tools/flask/policy</code>目录下生成一个叫做<code>xenpolicy-$XEN_FULLVESION</code>的文件，这个就是生成的flask policy。</p>

<hr />

<h3>启动Xen（with FLASK）</h3>

<p>在重启机器之前，我们需要在grub的配置中加上flask的选项，修改<code>/etc/default/grub</code>文件：</p>

<pre><code>GRUB_CMDLINE_XEN_DEFAULT="flask=&lt;OPTION&gt;"
</code></pre>

<p>其中，OPTIONs包括：</p>

<ul>
<li><code>permissive</code>表示：如果在bootloader阶段找到了一个policy，则会被加载；如果没有，或者发生错误，错误报告会被写到一个buffer，但是不会阻止系统启动。该模式可以通过<code>xl setenforce</code>改为<code>enforcing</code>模式；</li>
<li><code>enforcing</code>表示：在创建domain0之前会强制要求提供一个policy，否则无法启动系统；</li>
<li><code>late</code>表示：在bootloader阶段不会load相关的policy，可以在系统启动之后通过<code>xl loadpolicy</code>加载相应的policy，一旦policy被加载则进入enforcing模式；</li>
<li><code>disabled</code>表示：XSM会被设成dummy module，该模块和没有编译XSM所产生的效果是一样的，另外，一旦采用这个模式之后，FLASK是无法被重新加载的。</li>
</ul>


<p>需要注意的一点是，FLASK的policy需要被放在一个grub可以访问的目录下，如<code>/boot/flask/</code>，否则FLASK不会开启。另外，该policy选项需要写入grub的配置中，放在multiboot下面，如下所示：</p>

<pre><code>multiboot /boot/xen-VERSION.gz dom0_mem=1024M,max:1024M flask=enforcing
module /boot/vmlinuz-X.Y-amd64 root=/dev/mapper/vg_system-root ro quiet
module /boot/initrd.img-X.Y
module /boot/flask/xenpolicy-VERSION
</code></pre>

<hr />

<h3>利用XSM security label创建虚拟机</h3>

<p>当通过上面所提到的方式启动Xen之后，FLASK也就开启了，那么我们在创建虚拟机的时候就需要在其配置中增加一个security label（安全标签），否则，该虚拟机会被标记为“unlabeled”，例子如下所示：</p>

<pre><code>seclabel='system_u:system_r:domU_t'
</code></pre>

<p>安全标签有<code>user</code>,<code>role</code>和<code>type</code>表示，这些会在之后进行介绍。另外我们需要在policy中对相应的主体进行正确的权限设置。对于“unlabeled”的虚拟机，如果FLASK并没进入enforcing模式，或者进入了enforcing模式但定义了相关标签的权限，则不会有问题，否则，在其调用某些操作的时候会被禁止。</p>

<p>通过<code>xl list -Z</code>命令可以查看当前虚拟机所具有的安全标签。</p>

<p>通过<code>xl dmesg | grep avc</code>命令可以查看FLASK相关的log记录。</p>

<hr />

<h3>FLASK policies</h3>

<h4>增加一个security module</h4>

<p>我们可以把<strong>security module（安全模块）</strong>当做将一系列规则进行封装所产生的集合，如果要增加一个自定义的安全模块，我们需要在<code>$XEN/tools/flask/policy/policy/modules.conf</code>文件中加一行：</p>

<pre><code>&lt;module_name&gt; = on
</code></pre>

<p>同时在<code>$XEN/tools/flask/policy/policy/modules/&lt;module_name&gt;</code>目录下增加两个文件：</p>

<pre><code>&lt;module_name&gt;.te
&lt;module_name&gt;.if
</code></pre>

<p>其中<code>.te</code>文件定义了相应规则的的描述，而<code>.if</code>文件定义了一系列在<code>.te</code>文件中会被用到的宏（macros）。</p>

<p>在XSM-FLASK中有一个默认的模块：xen。如果存在多个模块（比如用户自己定义了多个模块），那么这些模块中不能有重复的<code>type</code>和<code>role</code>的定义。当模块定义好之后，可以参照'FLASK policy的编译流程'进行编译，并将其放在目标目录中（如<code>/boot/flask</code>)，这样在xen启动的时候就会加载，或者通过<code>xl loadpolicy</code>进行手动加载。</p>

<h4>定义Types, roles, users和attributes</h4>

<p>在安全模块中会定义许多规则，对于一个特定的规则，说白了就是规定了某个主体（source subject）对另一个主体（target subject）进行的一系列访问和操作（如hypercall）的权限（deny or allow），比如规定：</p>

<pre><code>某个集合中的虚拟机（source）不能向（deny）虚拟机监控器Xen（target）调用某个hypercall（operation）
</code></pre>

<p>那么这些集合就需要通过一系列的层级进行定义，也就引入了接下来需要讨论的<code>type</code>, <code>role</code>, <code>users</code>和<code>attributes</code>。可以结合<code>$XEN/tools/flask/policy/policy/modules/xen.te</code>文件中的例子进行更具体的了解。</p>

<p><strong>Policy Attribute</strong></p>

<p><code>attribute</code>定义了一个抽象的属性，它可以被附属在接下来要介绍的<code>type</code>主体上，即表示某个<code>type</code>具备哪些<code>attributes</code>。</p>

<p><strong>Policy Type</strong></p>

<p><code>type</code>是整个policy定义规范中最低的一个主体级别，它可以被用来在某个规则中指定source和target的类型。定义<code>type</code>的方式是：</p>

<pre><code>type new_type_t &lt;attributes&gt;;
</code></pre>

<p>比如在示例文件中，定义了一个<code>type</code>：</p>

<pre><code>type xen_t, xen_type, mls_priv;
</code></pre>

<p>其中<code>xen_t</code>即为<code>type</code>的标示符，而后面的<code>xen_type</code>和<code>mls_priv</code>则是相应的<code>attribute</code>，也就是说每个<code>type</code>可能会带有多个不同的<code>attributes</code>。</p>

<p>当我们需要定义一个规则的时候，可以通过<code>type</code>来指定对应的源和目标主体。比如需要定义某个hypercall的调用是被允许的，可以这么写：</p>

<pre><code>allow &lt;source type&gt; &lt;target type&gt;:&lt;security class&gt; &lt;hypercall&gt;;
</code></pre>

<p>其中，<code>security class</code>会在之后介绍，简单来说，它定义了一系列具有相关性的hypercall的集合。一个具体的例子：</p>

<pre><code>allow dom0_t security_t:security check_context;
</code></pre>

<p>定义了<code>dom0_t</code> type的主体可以向<code>security_t</code> type主体调用<code>security class</code>中的<code>check_context</code> hypercall。</p>

<p>另外，如果同时定义多个同一个class中的hypercall，可以用<code>{}</code>将其括起来，例如：</p>

<pre><code>allow dom0_t dom0_t:resource { add remove };
</code></pre>

<p>除了用<code>type</code>表示的主体，我们也可以直接用<code>attribute</code>来表示主体，如：</p>

<pre><code>allow domain_type xen_t:xen tmem_op;
</code></pre>

<p>即表示所有具有domain_type属性的type主体都可以向<code>xen_t</code> type主体调用<code>xen class</code>中的<code>tmem_op</code> hypercall。</p>

<p><strong>Policy Role</strong></p>

<p><code>role</code>是处于<code>type</code>上一层级的主体级别，用户可以定义某个<code>role</code>由多个<code>types</code>组成，比如：</p>

<pre><code>role system_r
role system_r types { xen_type domain_type };
</code></pre>

<p>可以看到，<code>role</code>的<code>types</code>是采用<code>attribute</code>的方式定义的，即定义具有某个<code>attribute</code>的所有<code>types</code>都属于这个<code>role</code>。如果要定义具有某个<code>attribute</code>的除掉某个<code>type</code>的所有<code>types</code>，则通过在该<code>type</code>之前加上一个<code>-</code>进行标示，如：</p>

<pre><code>role vm_r
role vm_r types {domain_type -dom0_t };
</code></pre>

<p><strong>Policy Users</strong></p>

<p><code>user</code>作为policy中的最高层级的主体级别，它并不被定义在<code>.te</code>文件中，它们是被定义在<code>$XEN/tools/flask/policy/policy/users</code>文件中。因此我们可以跨安全模块共用同一个<code>user</code>。在默认情况下，FLASK定义了三个users：system_u, customer_t和customer_2。</p>

<h4>增加Policy constraints</h4>

<p>FLASK可以通过在<code>$XEN/tools/flask/policy/policy/constraints</code>文件中定义规则来限制某些操作。在默认的情况下，FLASK规则定义了两条constraints（限制规则）来防止不同用户之间event channel和grant table的交互。一条限制规则语法如下：</p>

<pre><code>constrain &lt;security class&gt; { &lt;hypercall&gt; } ( expression );
</code></pre>

<p>比如例子中的：</p>

<pre><code>constrain grant { map_read map_write copy } (
  u1 == system_u or
  u2 == system_u or
  u1 == u2
);
</code></pre>

<p>这条限制规则表示如果属于<code>grant class</code>的这些hypercall可以被执行，当且仅当expression中的条件成立。其中，expression可以包含之前定义好的所有<code>user</code>, <code>role</code>和<code>type</code>主体，其语法规则如下：</p>

<pre><code>expression : (expresion)
      | not expression
      | expression and expression
      | expression or expression
      | u1 op u2
      | r1 role_op r2
      | t1 op t2
      | u1 op names
      | u2 op names
      | r1 op names
      | r2 op names
      | t1 op names
      | t2 op names

op : == | !=
role_op : == | != | eq | dom | domby | incomp

names : name | { name_list }
name_list : name | name_list name
</code></pre>

<h3>Security classes</h3>

<p><code>security class</code>被定义在<code>$XEN/xen/xsm/flask/policy/access_vectors</code>文件中，每个hypercall被分配在了其中一个class中，需要注意的是，每一个class最多只能有32个hypercalls。下面简单介绍下默认的几个classes，相关的hypercall的描述可以直接看<a href="http://wiki.xen.org/wiki/Xen_Security_Modules_:_XSM-FLASK#Security_classes">这里</a>。</p>

<ul>
<li><code>class xen</code>包含了所有在hypervisor中进行的操作，其source为执行hypercall的domain，target为xen (<code>xen_t</code> type);</li>
<li><code>class domain &amp; class domain2</code>包含了某个domain调用另一个domain或者调用自己的操作，source为执行hypercall的domain，target为被调用的domain（包括<code>_self</code>和<code>_target</code>的type）;</li>
<li><code>class hvm</code>类似于<code>domain</code>，除了它是针对HVM domain；</li>
<li><code>class event</code>用于描述event channels；</li>
<li><code>class grant</code>用于描述grant mapping；</li>
<li><code>class mmu</code>用于描述不是采用grant机制映射的内存页；</li>
<li><code>class shadow</code>（这个不清楚是干嘛的）；</li>
<li><code>class resource</code>用于描述硬件设备passthrough所使用的资源，包括IRQ, MMIO regions, I/O ports, PCI device等；</li>
<li><code>class security</code>用于描述和FLASK相关的操作。</li>
</ul>


<hr />

<p>以上即为XSM-FLASK最基本的介绍，我也还正处于学习阶段，其它更细节的部分和更直观的实例会在以后的博文中进行说明。</p>
]]></content>
  </entry>
  
</feed>
