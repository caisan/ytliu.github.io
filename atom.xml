<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mctrain's Blog]]></title>
  <link href="http://ytliu.github.io/atom.xml" rel="self"/>
  <link href="http://ytliu.github.io/"/>
  <updated>2016-12-15T12:22:01+08:00</updated>
  <id>http://ytliu.github.io/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[萨凡纳小镇上的OSDI-2016——SJTU-IPADS的集体见闻（转载）]]></title>
    <link href="http://ytliu.github.io/blog/2016/12/15/sa-fan-na-xiao-zhen-shang-de-osdi2016/"/>
    <updated>2016-12-15T10:04:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/12/15/sa-fan-na-xiao-zhen-shang-de-osdi2016</id>
    <content type="html"><![CDATA[<p>这是一篇由我负责，我们实验室10位本硕博一起完成的OSDI见闻录，从参会者的角度详细阐述了我们对于2016年系统领域的盛会——OSDI的感受和理解。</p>

<p>文章的内容由以下作者共同完成：</p>

<ul>
<li><a href="http://ipads.se.sjtu.edu.cn/yutao_liu">刘宇涛</a>，上海交通大学IPADS实验室博士五年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn/doku.php?id=pub:members:yang_hong">洪扬</a>，上海交通大学IPADS实验室博士四年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/xiayang_wang/">王夏阳</a>，上海交通大学IPADS实验室博士三年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/zeyu_mi/">糜泽羽</a>，上海交通大学IPADS实验室博士二年级</li>
<li>华志超，上海交通大学IPADS实验室博士二年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/mingyu_wu/">吴明瑜</a>，上海交通大学IPADS实验室博士二年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/jiaxin_shi/">施佳鑫</a>，上海交通大学IPADS实验室硕士三年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/mingkai_dong/">董明凯</a>，上海交通大学IPADS实验室硕士二年级</li>
<li><a href="http://ipads.se.sjtu.edu.cn:3000/pub/members/xingda_wei/">魏星达</a>，上海交通大学IPADS实验室硕士二年级</li>
<li><a href="http://dolobyte.net/">张云昊</a>，上海交通大学IPADS实验室本科四年级</li>
</ul>


<p>整篇文章按照时间顺序分为6个章节，连载发表在了ChinaSys的微信公众号CNSys上。这个博文是对其的一个转载，并且将所有内容整合在了一个篇幅里。希望对相关领域的人有所帮助吧！</p>

<!-- more -->


<hr />

<p>今年OSDI在美国乔治亚洲的一个美丽小镇萨凡纳举办，萨凡纳曾经被评为全球最美的十大小镇之一，城中到处都是小广场和公园，电影《阿甘正传》中阿甘坐在长椅上讲故事的广场也是在这里取景。</p>

<p><img src="http://ytliu.info/images/osdi2016/1.jpg" title="scenery 1" alt="1" />
<img src="http://ytliu.info/images/osdi2016/2.jpg" title="scenery 2" alt="1" />
<img src="http://ytliu.info/images/osdi2016/3.jpg" title="scenery 3" alt="3" />
<img src="http://ytliu.info/images/osdi2016/4.jpg" title="scenery 4" alt="4" /></p>

<p>这次上海交大IPADS实验室给我们11个<code>Ph.D. candidates</code>，以及<code>Ph.D.-candidate candidates</code>提供了参会的机会，可以说团队空前强大。整个会场中也时不时响起“I&#8217;m xxx, from Shanghai Jiao Tong University”的声音，也算是OSDI会史上难得一见的场景了。</p>

<p><img src="http://ytliu.info/images/osdi2016/5.jpg" title="people 1" alt="5" />
<img src="http://ytliu.info/images/osdi2016/6.jpg" title="people 2" alt="6" /></p>

<p>今年OSDI收到了260篇提交的论文, 在经过48个reviewers三轮的评审意见和讨论之后，最终接收了47篇论文，创了OSDI接收论文数量的新高。这些论文覆盖了多个领域，包括安全，云计算，事务处理，存储，网络，形式化验证，图计算，机器学习系统支撑，编程语言，troubleshooting等。其中比较热门的话题（超过两篇论文被接受）有形式化验证，利用RDMA来加速transaction，fault tolerance，安全通信（secure communication），SGX等。</p>

<p>整个会议由12个sessions组成，并且选出了三篇best papers：</p>

<ul>
<li>Push-Button Verification of File Systems via Crash Refinement</li>
</ul>


<blockquote><p>Helgi Sigurbjarnarson, James Bornholt, Emina Torlak, and Xi Wang, University of Washington</p></blockquote>

<ul>
<li>Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data</li>
</ul>


<blockquote><p>Tyler Hunt, Zhiting Zhu, Yuanzhong Xu, Simon Peter, and Emmett Witchel, The University of Texas at Austin</p></blockquote>

<ul>
<li>Early Detection of Configuration Errors to Reduce Failure Damage</li>
</ul>


<blockquote><p>Tianyin Xu, Xinxin Jin, Peng Huang, and Yuanyuan Zhou, University of California, San Diego; Shan Lu, University of Chicago; Long Jin, University of California, San Diego; Shankar Pasupathy, NetApp, Inc.</p></blockquote>

<p>如果分别用一句最简单的话概括，第一篇论文展示了形式化证明的一种自动化解决思路；第二篇论文将SGX巧妙地利用在了distributed sandbox这么一个新的场景上；第三篇论文提出了一个有趣的关于configuration error的问题和相应的解决方案。我们会在接下来相应的session中详细地介绍它们。</p>

<p>在之后的篇幅中，我们会按照会议安排的时间顺序，详细介绍每个session的内容，并且根据我们自己的理解对它们进行相应的评价和讨论。</p>

<hr />

<h3>Session~[Operating Systems I]</h3>

<h4>>>> Push-Button Verification of File Systems via Crash Refinement &lt;&lt;&lt;</h4>

<p><a href="https://www.usenix.org/conference/osdi16/technical-sessions/presentation/sigurbjarnarson">这篇论文</a>出自University of Washington的研究团队，由Helgi Sigurbjarnarson及其导师Xi Wang，与James Bornholt及其导师Emina Torlak组成。Prof. Wang在系统软件形式化验证领域已有<a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-wang_xi.pdf">Jitk</a>(OSDI&#8217;14)、<a href="http://locore.cs.washington.edu/papers/wilcox-verdi.pdf">Verdi</a>(PLDI&#8217;15)等工作，此次的成果给出了自动完成正确性验证的的一种方案。这篇论文是OSDI&#8217;16的三篇Best Paper之一。</p>

<p>以往的形式化验证工作（如SOSP‘15的<a href="https://people.csail.mit.edu/nickolai/papers/chen-fscq.pdf">FSCQ</a>），一般借助机器辅助证明工具（如Coq）完成验证。在这种方案下，程序员需以工具本身所支持的程序语言完成系统实现，并人工撰写正确性的证明过程，最终由工具完成程序员所写的证明的正确性检查。在这种框架下，系统实现及证明需要耗费大量的人力成本。依照本文数据，FSCQ耗费了MIT的研究团队1.5年时间完成。而本文的工作借助微软开发的Z3工具，自动完成验证工作。</p>

<p>本文所介绍的工具被命名为Yggdrasil。</p>

<p><img src="http://ytliu.info/images/osdi2016/1-1.png" alt="1-1" /></p>

<p>上图展示了Yggdrasil的工作流程。程序员需要提供最上方虚线框内的三部分内容：specification，implementation与consistency invariants。这三部分输入被交给工具的verifier进行分析验证。如果验证正确，按照verifier左侧的路径，代码实现会被翻译成c代码；如果验证失败，按照右侧的路径，Yggdrasil会展示导致系统崩溃的输入值。Yggdrasil还提供了实现的优化工具，可在一定程度上给出系统实现中可减少的flush操作。</p>

<p>程序员需要指定一个抽象的文件系统正确性描述，如下图所示，</p>

<p><img src="http://ytliu.info/images/osdi2016/1-2.png" alt="1-2" />
<img src="http://ytliu.info/images/osdi2016/1-3.png" alt="1-3" /></p>

<p>整个文件系统记录的信息为inode之间关系和inode对应的元数据，可由若干map数据结构刻画。而lookup操作的基本性质由图中lookup()函数在对应的数据结构上的操作指定。其他操作可以类似定义。程序员需指明如何证明所实现的文件系统与上图所示的简易数据模型之间状态等价(state equivalence predicate)，这一结果可被记录为逻辑表达式。这一等价关系用来验证具体实现具有抽象模型所指定的功能。此外，程序员还需指定crash consistency的逻辑描述形式（consistency invariants），用来检查文件系统可达的各状态是否consistency，或足以恢复至consistency状态。</p>

<p>Yggdrasil借助程序员指定的specification、state equivalence predicate与consistency invariants来证明具体文件系统实现(implementation)的正确性。Yggdrasil通过符号执行（Symbolic Execution）技术，将具体的实现转换为逻辑表达式，然后交由Z3分析证明。Yggdrasil具体的推理过程如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/1-4.png" alt="1-4" /></p>

<p>上图中A系列表示specification之上的操作进展，B系列表示实际实现之上的操作进展。两个系列分别从硬盘状态S0和S1出发。Yggdrasil尝试证明具体的实现与抽象的file system specification可以完成等价的硬盘状态转换（从S0到S0&#8217;与从S1到S1&#8217;）。Yggdrasil首先默认S0与S1为等价且合法的硬盘状态（文件系统镜像），即S0与S1在指定的state equivalence predicate下等价，且S0与S1满足指定的consistency invariants。也就是说，S0和S1是等价的初始状态。在这个默认条件下，Yggdrasil对两个系列各自完成文件系统操作，即在A系列上执行specification所指定的操作，在B系列上执行具体实现的文件系统操作，进而得到了各自的执行结果，即硬盘状态S0&#8217;和S1&#8217;。Z3需要完成的工作，是借助程序员指定的consistency invariants分别计算S0&#8217;和S1&#8217;状态是否是consistency，也就是两个系列的执行结果是否能得到合法的文件系统状态。然后Z3还需借助state equivalence predicate判定S0&#8217;与S1&#8217;是否等价，也就是判定具体实现上的执行结果是否实现了specification所指定的功能。这一整套推理过程的结果，被称为B系列是A系列的crash refinement。</p>

<p>如果出现了硬盘故障，具体实现中可能需要执行数据恢复程序。恢复结果的正确性既可以是恢复到整个文件系统操作完全不执行的状态（即右下角的S1），也可以是推进至完成操作的状态（S1&#8217;）。Z3需要证明恢复操作完成后的状态S1&#8217;满足consistency invariants。</p>

<p>有了A系列的参照标准，B系列的证明只需要做自动“对照”，这是Yggdrasil能够实现自动验证的一个原因。但由于具体的文件系统实现较为复杂，对Z3施加了巨大压力。作者提出具体的文件系统实现应以层次化、模块化为指导思想，各个层次分别验证，以简化Z3的输入。本文介绍的文件系统实现应用了5个层次，高一层次需要证明是低一层次的crash refinement。</p>

<p>作者在测试阶段，比较了经Yggdrasil验证的文件系统Yxv6+group_commit，发现其性能较未优化的Yxv6+sync和FSCQ有3-150倍的性能提升，比默认配置的ext4仅仅慢了10倍。</p>

<h4>>>> Intermittent Computation without Hardware Support or Programmer Intervention &lt;&lt;&lt;</h4>

<p>这篇论文是由Sandia国立实验室的Joel Van Der Woude和密歇根大学的<a href="http://www.impedimenttoprogress.com/">Matthew Hicks</a>合作完成，其中Matthew是A2（今年S&amp;P的best paper）的作者，同时他在今年ASPLOS上提出利用performance counter来实现一个防御RowHammer的软件方法ANVIL。</p>

<p>这篇论文的题目提到一个关键词：<code>Intermittent computation</code>，即可间断的计算。这个场景主要发生在那些利用收集能源的方式进行供电的设备，比如利用太阳能供电的穿戴设备等。这些设备越来越流行，但是它们最大的问题在于，其能源的供应是不稳定的，因此很有可能会经常发生运行到一半就突然关机重启的现象，所以我们希望它们在重启之后能够从之前关机的状态继续执行，而不是完全从头再来，这就是所谓的可间断的计算。</p>

<p>针对这个问题，最直接的方法就是在特定的时候记录checkpoint（即当前的运行时状态），然后在重启的时候加载这些状态。那么何时进行checkpoint就是该问题的关键，当前有两种可行的方案：第一，利用特殊的硬件，在即将关机之前将当前的运行时状态进行保存；第二，程序员手动在程序中某些特定的点插入相关逻辑，进行相关的checkpoint的保存。而本文提出了第三种可行的方案，该方案既不需要特殊的硬件支持（hardware support），也不需要程序员手动插桩（programmer intervention），而是<strong>利用编译器自动化地寻找特定的点进行插桩</strong>。</p>

<p>因此，这篇论文最关键的贡献在于提出如何自动化地寻找那些特定的需要进行checkpoint的点，这里，第二个关键词出现了：<code>idempotent sections</code>，即具有幂等性特征的代码片段。它的意思是说如果一个代码片段在被重复多次执行的情况下也不会产生不一致的语义的话，那么这段代码片段就满足幂等性。而这篇论文的工作就是利用LLVM编译器来自动化地寻找那些<code>idempotent section</code>（之后简称为IS），并且在IS之间插入checkpoint的逻辑。</p>

<p>那么具有怎样特性的代码片段是属于IS的呢？这里有一个很好的例子来说明：</p>

<p><img src="http://ytliu.info/images/osdi2016/2-1.png" alt="2-1" /></p>

<p>上图中的(b)，如果在<code>*b = 42</code>这条指令之后关机重启，那么就意味着这两条指令会被重新执行，那么最后会发现其执行的结果就和原先是不一致的（原先<code>a=y; b=42</code>，之后<code>a=42; b=42</code>）。而如果我们在这两条指令之间进行一个checkpoint（如上图(c)），则就可以避免这种不一致的情况。也就是说，这两条指令所组成的代码片段不是一个IS。</p>

<p>这个例子能够很好地说明IS的一个非常重要的特定，即一个IS里面是不允许存在WAR（write after read）的！这也就是这篇论文提出的最关键的点。看上去很简单，但是非常有效，而且应用在了一个特别好的场景中。因此，这篇论文的重点就变成了如何通过程序分析的方法来寻找所有的那些WAR的依赖。当然，这里还要考虑很多corner case，比如虽然IS里面不能有WAR，但是可以有WARAW，以及对于一些特殊的指令（如<code>pop</code>），它们会违反IS的一些特性，因此都需要进行特殊的处理。最后它们还进行了一些优化，细节这里就不多说了。</p>

<p>演讲完之后，作者回答了几个问题，比如<code>你们是如何解决inter-procedure的读写依赖分析的？</code>，以及<code>你们是如何解决在进行checkpoint的时候发生failure的？</code>对于第一个问题，他们其实并没有进行interprocedural的分析，只是非常保守地在每个函数的entry都会进行一次checkpoint。对于第二个问题，他们采用了一种称为<code>double buffering</code>的机制，即在进行checkpoint的时候使用一个新的buffer，只有在该checkpoint做完之后，才会原子性地将指针指向这个新的buffer。</p>

<h4>>>> Machine-Aware Atomic Broadcast Trees for Multicores &lt;&lt;&lt;</h4>

<p>这篇论文的作者来自<code>ETH Zurich</code>的<code>System group</code>，第一作者<a href="https://people.inf.ethz.ch/skaestle/">Stefan Kaestle</a>已经博士毕业，现在在Oracle，他博士期间的导师是<a href="https://www.inf.ethz.ch/personal/troscoe/">Timothy Roscoe</a>，喜欢别人称他Mothy。</p>

<p>作者认为，当前并行编程中的同步机制的趋势将从shared memory慢慢转向message passing（具体原因可以去看paper），因此一个高效的message passing是实现高效同步机制的关键。在NUMA多处理器的系统架构中，基于message-passing的broadcast非常依赖于broadcast-tree的拓扑结构（topology），如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/3-1.png" alt="3-1" /></p>

<p>作者发现，实现一个最优的broadcast tree是machine-dependent的，因此，这篇论文的主要贡献就是实现了一个库（Smelt），它能够自动地针对每种不同硬件的机器，创建一套near-optimal的inter-core的broadcast tree，同时提供相应的接口，通过message-passing的方式实现包括barrier在内的一系列操作，并得到很好的性能提升。</p>

<p>在创建broadcast tree的过程中，主要先通过硬件寄存器提供的接口获得有用但是不全面的machine model，并结合一些micro-benchmark来得到比较完整的信息，这些信息主要包括core之间的结构关系，以及它们互相之间进行message-passing的效率。之后再通过一系列的算法，建立可能最优的broadcast tree。Smelt提供了一系列的接口，用于初始化，以及实现一些需要进行inter-core广播的操作。比如他们实现了一个smelt版本的barrier，比传统的基于share memory的barrier提高了三倍的性能，等等。</p>

<p>总的来说，笔者对这个报告没有听的很懂，但是笔者觉得它解决了一个很有趣的问题。它首先发现了在NUMA多处理器的系统架构中，核与核之间的信息传输效率其实是不均等的，甚至是不对称的（相同两个核之间send和receive的代价不同），它对这些通过测试发现的结果进行更深入的研究，从而提出near-optimal broadcast tree这么一个场景，并且通过静态（hardware register derivation）和动态（micro-benchmark）相结合的方法得到比较精准的硬件信息，最后创建near optimal的tree topology。是一个比较典型的通过实验发现问题-深入探究-定义场景和问题-解决问题的研究过程。</p>

<h4>>>> Light-Weight Contexts: An OS Abstraction for Safety and Performance &lt;&lt;&lt;</h4>

<p>这篇论文的一作James Litton来自马里兰大学，是<a href="https://www.cs.umd.edu/people/bobby">Bobby Bhattacharjee</a>的学生。</p>

<p>这是一篇笔者蛮喜欢的论文，它在进程和线程之间找到了一个很好的平衡，抽象出一个新的概念叫做light-weight context (lwC)，同时，将这个新的抽象应用在了几个非常匹配的场景上，达到了很好的效果。</p>

<p>我们先来看下为什么要有lwC这个概念。总所周知，现在操作系统的隔离机制主要是通过进程来做的，每个进程都有自己的内存地址空间，文件描述符，credentials等信息。同时为了更好的共享，又在进程中抽象出了线程的概念，同个进程中的所有线程都共享一些地址空间，同时又能维护自己的运行时状态，包括寄存器、栈等。一切都看起来这么完美，那为什么还要一层中间的抽象lwC呢？</p>

<p>问题就出在进程间的切换性能开销太大了，进程在切换是内核会涉及到一系列同步（synchronization）和调度（scheduling）相关的操作，大大增加了进程间切换的开销；而线程由于基本没有任何相互隔离的能力。因此，作者提出了一个lwC的概念。</p>

<p>简单来说，一个进程可以包含多个lwC，但是和线程不同的是，每个lwC之间的内存地址空间，文件描述符，credentials等信息都是相互独立的，同时这些资源通过配置也可以互相间进行共享。下图描述了和lwC相关的系统调用接口：</p>

<p><img src="http://ytliu.info/images/osdi2016/4-1.png" alt="4-1" /></p>

<p><code>lwCreate</code>类似于<code>fork</code>，但是返回同一个PID，而且不会产生新的线程，新的lwC在被创建之后也不会被执行。所以，在某些场景中，被创建出来的新的lwC可以被当成原来lwC的一个snapshot，在将来的某个时候可以很快被恢复。<code>lwSwitch</code>则是用于线程在不同的lwCs之间进行切换。关于不同lwCs之间的关系，可以通过静态或者动态的方式进行定义。其中在静态方式中，<code>lwCreate</code>默认的规则是copy-on-write，但是该规则可以通过参数<code>resource-spec</code>进行修改，<code>resource-spec</code>是一堆C union的数组，每个数组元素表示一段地址空间，文件描述符，或者credentials，以及它们相应的选项，比如<code>LWC_COW</code>，或者<code>LWC_SHARED</code>。而动态规则定义则通过另外一个接口<code>lwOverlay</code>中的<code>resource-spec</code>参数进行定义。当然，如何定义哪些lwC能够调用<code>lwOverlay</code>则是由每个lwC的access capability来决定的，而access capability则是通过接口<code>lwRestrict</code>来定义。最后，父lwC还可以通过<code>lwSyscall</code>来定义子lwC的系统调用规则，比如它可以通过<code>LWC_SYSTRAP</code> flag来对子lwC中的某些系统调用进行拦截，从而决定每种系统调用的行为。</p>

<p>通过对这些API的描述，其实可以发现，lwC非常适合诸如snapshot和rollback，隔离隐私数据，reference monitor等场景，报告和论文中都进行了详细的解释，这里就不阐述了。总的来说，lwC提出一个新的鉴于进程和线程之间的抽象，可以更加灵活地定义不同lwC之间的隔离机制，同时极大地减小了进程间相互切换所带来的性能损失（基本上只需要原来的一半时间）。另外，lwCs的代码已经开源：<a href="http://www.cs.umd.edu/projects/lwc/">http://www.cs.umd.edu/projects/lwc/</a></p>

<hr />

<h3>Session~[Cloud Systems I]</h3>

<h4>>>> Altruistic Scheduling in Multi-Resource Clusers &lt;&lt;&lt;</h4>

<p><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-grandl-altruistic.pdf">这篇论文</a>出自University of Wisconsin-Madison的博士生Robert Grandl，其导师Aditya Akella，以及University of Michigan的Mosharaf Chowdhury和Microsoft Research的Ganesh Ananthanarayanan。</p>

<p>如今集群计算的任务调度器需要在三个目标之间权衡：任务分配资源的公平性、任务执行时间和集群资源利用效率。已有的诸多调度器着重保持公平性目标，实现各任务执行的相互隔离，而对于另外两个效率目标只能尽力而为。本文设计实现的调度器CARBYNE旨在平衡三个目标：在不牺牲公平性的同时，提高执行效率。</p>

<p>作者关注了并发计算任务的两个重要特征：整个并行计算任务的完成时间取决于最慢一个任务的实行时间，以及用户只关心整个任务的执行效率而非单一子任务在调度时刻的执行状况。第一个特征意味着过多分配资源可能导致资源没有完全利用。第二个特征意味着牺牲短时间内的公平性不一定意味着任务整体的公平性和执行效率会变差。</p>

<p>作者在微软的分析计算平台上发现，50%的时间里有20%的计算资源可以被重新分配给其他计算任务使用。CARBYNE倾向于把这些剩余资源分配将要执行结束的计算任务，并尽量将计算资源合并。</p>

<p><img src="http://ytliu.info/images/osdi2016/5-1.png" alt="5-1" /></p>

<p>上图是CARBYNE优化调度提升性能的一个简单例子。蓝色矩形和橙色矩形是两个计算任务，各自有许多子任务（S0、S1、S2）。由于内在属性限制，橙色任务中的S2需要等待S1和S0完成。如左图所示，一种调度策略是将一个橙色S1任务延迟到第二个时间片执行，空余资源允许一个蓝色任务S0使用。但这种策略在两个时间片内均产生了一定量的空闲资源。CARBYNE倾向于将任意时间片的资源打包充分利用，如右图所示，第二个时间片内可以空余出七成的资源，这样便获得了大量的可重新分配的资源给其他任务使用，同时蓝色任务的执行时间可以缩短至1个时间片，也没有影响橙色任务的执行时间。</p>

<h4>>>> GRAPHENE: Packing and Dependency-Aware Scheduling for Data-Parallel Clusters &lt;&lt;&lt;</h4>

<p>一作Robert Grandl是威斯康星麦迪逊的博士生，导师是Aditya Akella。值得一提的是，Grandl还是本Session第一篇Altruistic的作者，两篇文章都是关于服务器集群任务调度的。Akella在本次OSDI也还有两篇论文，真是非常的高产。其余几位作者都来自微软，本工作也主要是在微软完成的。</p>

<p>首先普及一些基本概念。在流行的分布式编程框架中，Google的Map-Reduce可以说是最著名的。不过也由于其提供的抽象非常简洁，很多程序并不适合用Map-Reduce实现。由于很多程序的执行流本质上是一个DAG(有向无环图)，其他流行的框架都是将用户请求通过查询优化器转化为一个DAG，比如微软的Dryad和Apache的Spark。在这个DAG中，每个点表示一个框架原生支持的任务，边代表了数据流向。所以，在分布式框架的实现中，如何高效的调度这些任务成为了一个难题。</p>

<p>本文针对的DAG具有以下特点：图中节点多而且复杂，不同节点代表的任务具有很高的异构性(任务所需的时间和资源差异很大)。作者说，在微软的服务器上，一个中型DAG大约有五层，上千个节点。之前调度主要使用Heuristic方法，比如着重优化关键路径(Critical Path)或者使用贪心算法最大化当前资源利用率。前者的主要问题是忽略了调度复杂DAG中的潜在并行性，后者关注的局部最优不一定能够实现全局最优。</p>

<p><img src="http://ytliu.info/images/osdi2016/6-1.jpg" alt="6-1" /></p>

<p>上图描述了一个Graphene如何调度一个DAG。首先通过离线分析，识别出一个“麻烦任务集合”(Troublesome Tasks)，就是图中用红色和字母T表示的区域。DAG其余部分被分为“麻烦任务集合”的祖先、同辈和后代，对应图中的P(Parent), S(Sibling), C(Child)区域。接下来用一个坐标系形象的表示调度：横坐标表示时间，纵坐标表示资源。首先把“麻烦集合”在坐标系中的区域表示出来，然后根据数据依赖(DAG中的边)将P、S、C进行资源分配。Graphene将一个调度问题，转化成为将DAG中每个点画在这张图上，使得这个图尽量的紧密，即资源利用效率越高。这样，作者做到了同时考虑并行性和全局最优。</p>

<p><img src="http://ytliu.info/images/osdi2016/6-2.jpg" alt="6-1" /></p>

<p>上图表现了调度两个Job时，Graphene和其他调度算法的比较。可以明显看出更多考虑并行性后调度效率的提升。作者说根据微软的测试，目前部署的调度算法距离最优调度大概还有50%左右的理论提升空间，Graphene做到了30%的程度。由于最优调度是NP问题，所以Graphene作为在线调度已经非常不错了。</p>

<h4>>>> Firmament: fast, centralized cluster scheduling at scale &lt;&lt;&lt;</h4>

<p>这篇文章的一作是Ionel Gog来自于剑桥大学。这篇的工作开源在了<a href="http://firmament.io/">http://firmament.io/</a>。</p>

<p>在一个cluster中如何将任务schedule到机器是一个重要的问题，一个好的scheduler可以提高集群的利用率，application的运行性能以及更好的负载均衡。这篇文章提供了一个中心化的scheduler，名为Firmanent。Firmanent保留了中心化scheduler可以产生良好的placement的特性，同时可以支持成千上万台机器的cluster。</p>

<p>目前总共有三种scheduler的架构，中心化的，分布式的以及混合的。这里只关注前两者。中心化的scheduler可以使用算法得出非常好的placement（根据全局信息），但是具有非常高的latency（几秒到几分钟）。这样便何难scale到很大的cluster上。分布式的scheduler使用一些简单的算法，可以很快的依赖于局部信息得出placement，但是往往不能得出比较好的placement。</p>

<p>Firmenant基于state-of-the-art的中心化scheduler Quincy的flow based的算法来计算placement。下图展示了大致的算法。假设有4台机器，两个任务。其中T0有3个job，T1有两个。一个job可以连接一个machine（在这台机器调度），或者连接一个aggregator（表明任务没有被调度）。一个Min-cut-max-flow solver可以在这样定义的网络中找到最优的placement（流向machine的流）。</p>

<p><img src="http://ytliu.info/images/osdi2016/7-1.png" alt="7-1" /></p>

<p>Quincy的问题是在大集群上需要的开销特别大。下图是文中测试Quincy在大集群上的性能。在12,500机器的集群中，Quincy需要66秒来调度完成一个调度，这个开销是非常大的。</p>

<p><img src="http://ytliu.info/images/osdi2016/7-2.png" alt="7-2" /></p>

<p>文章中经过分析发现，算法的最大瓶颈在于solver花的时间过长。文中经过对于多个求解算法的分析，发现理论上不高效的松弛算法在实际中具有更好的性能。然而松弛算法在一些情况下可能会退化到其他算法的情况，文中（section 5）提出了具体的优化。感兴趣的可以查看原文。</p>

<h4>>>> Morpheus: Towards Automated SLOs for Enterprise Clusters &lt;&lt;&lt;</h4>

<p>这篇论文的一作<a href="http://web.engr.illinois.edu/~abdujyo2/">Sangeetha Abdu Jyothi</a>是来自UIUC的一名Ph.D. candidate妹子，她的导师是<a href="http://pbg.cs.illinois.edu/">Prof. P.Brighten Godfrey</a>，应该是网络方向的一名rising star。不过这篇论文的作者列表里面没有她的导师，所以应该是她在微软研究院实习的时候的工作吧。</p>

<p>这篇论文的主要工作为了解决云计算平台中的一个矛盾：即server端为了达到high utilization所需要的共享的特性，和user对于performance的predictability的需求所造成的矛盾。简单来说，云平台的用户希望其在云上跑的程序是可预测的，即在某个deadline之前能完成某些工作。而对于云平台的server来说，为了达到资源的最大利用率，每台机器的硬件资源都是由多个用户所共享的，而这种共享性势必有很大的可能造成某个用户的deadline需求无法满足。所以这篇论文的主旨就是在不降低server端utilization的情况下，提高对于user的predictability。</p>

<p><img src="http://ytliu.info/images/osdi2016/8-1.png" alt="8-1" /></p>

<p>如上图所示，文中将用户的需求称为Service Level Object (SLO）。为了提高user的SLO，首先需要对其进行合适的定义，同时对资源的需求进行一个建模。在这个过程中，Automatic inference模块通过对job之间的数据依赖进行了分析，同时利用一些historical的信息进行资源建模。在此基础上，就需要减少由于资源共享所带来的不确定性因素（unpredictability）了，其实这主要是一个调度（schedulin）的问题，里面用到很多现有的和新提出的算法，主要是一个被称为recurring reservation的概念，由于这篇论文笔者没有听太懂，所以细节就略过了。除此之外，还要解决的就是其它原因造成的不确定性（如failure等），这里作者提出了一种称为dynamic reprovisioning的机制，有兴趣的可以去看论文。
从结果来看，这项工作在基本不损失utilization的基础上，减少了5~13倍的SLO violation，利用基于静态分析和调度的方法，解决了一个常见的云平台中server和user之间的矛盾。</p>

<hr />

<h3>Session~[Transactions and Storage]</h3>

<h4>>>> The Snow Theorem and Read Latency Optimal read-only transactions &lt;&lt;&lt;</h4>

<p>这篇文章的一作是Haonan Lu，他的导师是Wyatt Lloy，作者来自南加州大学和纽约大学。他们在consistency上的paper非常多，代表的有COPS，非常厉害。</p>

<p>这篇文章是这个session里笔者最喜欢的一篇论文。 他提出了SNOW理论，说的是在一个分布式的存储系统中，S(Strict serializability),N(Non blocking read),O(One round-trip read),W(Write transactions) 这四种性质没有办法同时被满足。N和O指出了Readonly（只读）事务的最优执行方式，而S和W是对一个存储系统的功能性需求。同时文章说明了SNOW的任意三个性质的组合都可以被满足，这样给一些没有同时满足这三个性能的系统提供了优化read-only事务的方向。</p>

<p>SNOW所针对的系统如下图所示。数据被划分为多个shard，假设一个用户的只读请求需要访问多个shard的数据，那么他会向这些shard的server发请求。在这样的架构下，假设没有阻塞（blocking），以及只向每个server发一个请求的话，那这个只读请求能达到的latency就是最低的（optimal）</p>

<p><img src="http://ytliu.info/images/osdi2016/9-1.png" alt="9-1" /></p>

<p>除了SNOW的不可满足性以外，这篇论文还说明了SNOW能达到何种最优情况。通过举例可以说明除了4个特性以外，其他任意三个特性，比如S+N+O都是可以被满足的。
SNOW的证明笔者觉得也是比较简洁易懂的。其中的核心证明的点在于存在一个时间，一个write transaction对两个shard的数据修改的结果不同时出现，因为分布式系统的异步通信机制。这样，假设一个read操作在这个时候到达这两个server，如果不被block或者不重试，那么有可能会读到这个事务一部分的修改，违反了Strict serializability。</p>

<p>SNOW可以作为一个现有系统优化的guideline，也就是说假设一个系统没有达到所有的SNOW中的任意三者，那么他的Read-only事务仍然有优化空间。对于这篇文章来说，他选择了ROCOCO和COPS来优化，使得他们的Read-only事务达到了NO的特性。SNOW也指出了trade-off，也就是说一般你需要使得read-only事务optimal，那么你需要把overhead转移到write事务这里。对于目前的许多网络应用，由于Read-only事务可能会占到90%以上，所以对于总体性能来说优化Read-only事务还是可以获得提升的。</p>

<h4>>>> Correlated Crash Vulnerabilities &lt;&lt;&lt;</h4>

<p>这篇文章的一作是Ramnatthan Alagappan，作者都来自威斯康星大学麦迪逊分校。
文中提出了一个自动化框架PACE来判断，分布式系统的协议是否在corrlated failure的情况下仍然能正确的工作。正确指的是数据的一致性或者系统的状态是否正确。Corrlated failure指的是分布式系统中一组机器同时crash，甚至可能存储一个数据所有replica的机器都crash了的情况。这种情况下协议能否正常工作就非常依赖于每台机器的文件系统所存储的抽象，因为这时候数据不可避免的要从磁盘恢复。这篇文章把PACE应用到了许多现有框架包括Zookeeper，找到一些这些框架在系统出现correlated failure时会发生的bug。</p>

<p>Correlated failure在现有的数据中心中还是比较常见的。通常的原因包括停电，有计划的和无计划的重启。文章还引用了Google的报告表明在Google机器的failure通常是correlated的。当一个数据所有的replica都挂了的时候，必须依赖磁盘（文件系统）来恢复正确性。</p>

<p>PACE通过搜索distributed state来判断出现Correlated failure时系统可能存在的on-disk的状态。如何来记录和判断一个协议所产生的可能的distributed state呢？文中给了下图的例子。</p>

<p><img src="http://ytliu.info/images/osdi2016/10-1.png" alt="10-1" /></p>

<p>这个例子中假设有两台机器，初始状态为Qf和Pf。所使用的协议非常简单，P向Q发送一个message之后将磁盘的状态更新为P1和P2，之后再向Q发送一个message。当Q收到第二个message的时候，将自身状态更新为Q1。假设文件系统的写时同步的。我们可以看到，在这个协议中，&lt;Pf,Qf>&lt;P1,Qf>是可以达到的distributed state，而&lt;Pf,Q1>则是不可达的state，因为当Q的状态为Q1时，P的状态一定被改成了P2。</p>

<p>PACE通过搜索可能出现的distributed state来判断当存在correlated failure时系统的状态是否正确。我们可以看到，文件系统的特性对状态的变更来说非常重要，如上图的例子，如果文件系统是异步的，那么&lt;Pf,Q1>便是一个可能达到state。PACE使用了一些和协议相关的技巧来减少搜索空间，使得通常搜索可以在相对短的时间完成，具体的可以看文中的说明。</p>

<h4>>>> Incremental Consistency Guarantees for Replicated Objects &lt;&lt;&lt;</h4>

<p>这篇文章的作者是Rachid Guerraoui, Matej Pavlovic和Dragos-Adrian Seredinschi，他们都来自EPFL。
论文提出了一种新的在replicated data上编程的抽象，使得用户可以更加方便的在一个拥有多个consistency level的data store上编程。这种consistenct level他们称为incremental consistency。通过操作不同consistency level的数据，application可以使用speculation等优化技巧来提升程序的性能。文中展示新抽象的一个实现，名为Correctable。Correctable基于编程语言的promises机制，同时可以非常方便的使用其提供的binding接口和现有的许多数据backend比如memcache或者Cassandra接入。</p>

<p>对于现代的NoSQL存储来说，程序员通常需要决定使用什么consistency level的数据，这是一个很麻烦的事。在一个replicated的系统来说，一直获取最强（最新）数据的代价太高了，通常程序员只需要有数据就行了。只有很少的情况下用户需要一个强consistency的数据。比如说，对于一个社交网络来说，获取用户的timeline可以获得一个不是最新的timeline（不是最强的consistency），但是用户登录验证密码这件事一定是需要强一致性的。通常获取一个弱consistent的数据更加高效(比如可以从一个stale的replica中获得备份的数据)，这样可以提升整体application的性能。</p>

<p>下图的表格展示了文中列举的不同application对consistency level的需求。可以看出很多application可以从incremental consistency中获取性能提升。</p>

<p><img src="http://ytliu.info/images/osdi2016/11-1.png" alt="11-1" /></p>

<p>提供Incremental consistency的Correctable基于编程语言中的promises（B. Liskov and L. Shrira. Promises: Linguistic support for efficient asynchronous procedure calls in distributed systems. In PLDI, 1988.）机制。简单来说他提供了一个回调机制，用户希望访问一个数据的时候，他可以为不同consistency level提供回调函数。当特定consisteny level的数据到达时候，提供的回调函数会被调用，具体的api如下图所示。</p>

<p><img src="http://ytliu.info/images/osdi2016/11-2.png" alt="11-2" /></p>

<p>Backend能提供的consistency level和具体的实现有关，所以Correctable提供了binding机制，使其api可以和具体的backend实现绑定。这一部分需要程序员自己实现。</p>

<p>文章最后说明了一些如何用Correctable来做speculation的例子，笔者觉得比较trivial就不多说了。比较有趣的是，在去年sigmod上有一篇文章研究了如何使用类似的speculation来加速事务的执行。比这篇有意思的是，这篇sigmod文章提出的方法可以通过用户给的事务程序来自动地分析哪些操作可以使用一个弱consistency level的数据来做speculation。</p>

<h4>>>> FaSST: Fast, Scalable and Simple Distributed Transactions with Two-sided (RDMA) Datagram RPCs &lt;&lt;&lt;</h4>

<p>这篇文章的一作是Anuj Kalia，作者都来自于卡内基梅隆大学，他们在RDMA上的工作非常厉害。
正如作者在talk中所述的，这篇严格来说不算事务处理的文章而是RDMA实现相关的文章。这篇文章指出了现在RDMA one-sided的一个严重的scalability问题，也就是网卡缓存过多的queue pair会带来性能下降的问题。 这篇文章通过使用RDMA的unreliable two-sided datagram来解决当集群较大时需要过多queue pair的问题，同时基于two-sided的RPC在使用一系列的优化之后可以达到比较好的性能。</p>

<p>RDMA one-sided操作通常提供了最好的性能，但是需要sender和receiver预先建立好连接(queue pair),通常为了避免工作线程之间的共享，一台机器上每个thread都会使用不同的queue pair。这样，当一个集群有m台机器和t个thread时，一台机器需要建立m*q个queue pair。</p>

<p>Queue pair的信息会缓存在网卡上，当网卡没有缓存对应的queue pair时网卡会用dma去内存里读取对应的信息，然而这显然会带来比较大的性能开销。网卡缓存的数量会有限制，通常在CX3上为250个，而CIB上为400个。这样当一个rdma的cluster比较大的时候则会出现网卡没有办法缓存所有的queue pair的情况，这样会带来性能下降，如下图文中的测试所示。</p>

<p><img src="http://ytliu.info/images/osdi2016/12-1.png" alt="12-1" /></p>

<p>当使用unreliable datagram（UD）时，由于sender和receiver不需要预先建立连接，这样UD的queue pair可以on demand的连接，所以一台机器只需要t个queue pair就行了。这大大减少了queue pair的数量。</p>

<p>一种简单的解决queue pair数量的方法是让线程之间共享queue pair。但是由于rdma driver的实现问题（使用pthread_mutex）,简单的使用sharing带来的synchronization的开销就很大，如下图所示。</p>

<p><img src="http://ytliu.info/images/osdi2016/12-2.png" alt="12-2" /></p>

<p>所以，文中表示需要使用UD来解决这个scalability问题。同时，基于UD的rpc可以带来比较好的性能（使用他们之前ATC文中的优化），同时基于rpc的编程可以更加简单。</p>

<p>UD最大的一个问题是传输的包可能会被reorder或者发生丢包。这使得目前Fasst rpc的最大传输数据是4096个byte（网卡的MTU）。然而文中指出，由于infiniband实现的是无损（不会因为网络阻塞丢包）的传输层，所以丢包的概率非常低，几乎可以忽略不计。</p>

<hr />

<h3>Session~[Networking]</h3>

<h4>>> NetBricks: Taking the V out of NFV &lt;&lt;&lt;</h4>

<p>这篇论文来自 UCB 的 NetSys 实验室。同一个 session 他们实验室还有另一篇论文。NetSys 实验室在 NFV 领域有着多年的深入研究，在 SIGCOMM、NSDI、SOSP 等网络和系统的顶级会议上都发表了非常多的论文。这篇的第一作者 Aurojit Panda 同样是他们组在之前许多工作中的幕后贡献者，包括去年 SOSP 发表的 E2，以及SIGCOMM 的 Rollback Middlebox 等。</p>

<p>NetBricks 是一种用于更便捷地创建和部署 middlebox 的框架，利用 Rust 语言特性加上以 LLVM 作为运行时，保证了数据在 middlebox 之间传递的时候的安全性，不使用硬件提供的虚拟化机制来实现 middlebox 之间的隔离。之前的类似的 middlebox 框架要追溯到 Eddie Kohler（当时在 MIT PDOS 读博）在 1999 年提出的经典的 Click 系统。随着近年虚拟化技术的成熟应用，将网络中的 middlebox 利用已有的虚拟化技术抽象出来，用通用硬件和软件来实现的技术（NFV）也越炒越热。但是面向网络应用的 middlebox 对网络数据处理的吞吐率和延迟有着很高的要求，而现有的基于硬件的虚拟化技术已经被证实会带来很大的性能开销。NetBricks 是在这种场景下作出的一种新的尝试，完全使用编程语言特性和语言运行时来提供以往虚拟化技术提供的隔离性保证，而纯软件实现的 NFV 系统因为减少了硬件和软件之间的抽象，能够提供更高性能。</p>

<p>NetBricks 强调的一项隔离性是内存隔离性（memory isolation），即一个包或者一段数据在被一个 middlebox 处理之后，穿过 middlebox 边界来到另一个 middlebox，此时前一个 middlebox 应该不能再修改这个包或者数据。在以往的系统中，因为这一个包在内存中是被多个 middlebox 共享的，要做到这样的隔离性，最简单和常用的方法是把包复制一份，下游 middlebox 处理复制出来的副本。但是在高吞吐率的 middlebox 中，内存拷贝操作会立刻成为性能瓶颈。因此 NetBricks 借用了 Singularity 的思想，提出了 ZCSI（Zero-Copy Software Isolation）的概念。ZCSI 利用高级编程语言提供的语义，一方面用 zero-copy 的方法在 middlebox 之间共享包数据，另一方面在语言运行时层面插入权限检查的代码。只要程序员使用 NetBricks 基于的 Rust 编程以及使用 Rust 的运行时，middlebox 就无法绕开这样的权限检查。而这样的权限检查更可以利用 Intel 刚加入 Skylake 的 MPX 技术来减少开销。</p>

<p>这篇论文将编程语言、网络、系统结合起来设计，是比较有意思的一个项目，在 GitHub 上开源 <a href="https://github.com/netsys/NetBricks">https://github.com/netsys/NetBricks</a>，有兴趣的朋友可以去看一下，可以看到已经有不少工业界的人在尝试了。</p>

<h4>>> Efficient Network Reachability Analysis Using a Succinct Control Plane Representation &lt;&lt;&lt;</h4>

<p>一作是来自 CMU 的 Seyed K. Fayaz，曾在 NSDI&#8217;14 上发表 FlowTags，也是在 SDN 领域比较应影响力的一篇论文。署名最后两位是 CMU 的 Vyas Sekar 和 UCLA 的 Goerge Varghese，又是网络领域的两位大拿。</p>

<p>这篇论文是设计了一个用于分析网络可达性的工具。因为笔者严格来说并不是网络领域的，所以对这篇论文并没有太深见解，也有可能有所误解。这篇文章应该说的是通过对数据中心的网络在 control plane 层面建模，并分析出任意两点之间的可达性。从实现上来说，这个工具抓取了整个网络中的路由协议消息，并建立了一个网络通信模型。然后该工具探索这个模型，并找出网络中 bug 可能发生的情形。这篇论文中有许多公式和推导，并不像典型的系统领域论文，更像网络领域的论文。应当说今年 OSDI 接受了许多这样跨领域的论文。</p>

<h4>>> Simplifying Datacenter Network Debugging with PathDump &lt;&lt;&lt;</h4>

<p>这篇文章的第一作者来自爱丁堡大学，导师 Myungjin Lee 在网络测量方面发表过许多 SIGCOMM 论文，因此这篇论文也是在这个方向上一脉相承。合作作者 Rachit Agarwal 是 Cornell 的 AP，网络 debug 也是他的领域之一。</p>

<p>这篇文章同样是关于数据中心网络找 bug 的。PathDump 的方法很简单，利用基于 openflow 的 SDN 交换机功能，对每一个流经的包做检查，并对可疑的包在包头中插入一个 ID。最终的服务器能够收到这些打了 tag 的包，并更新所记录的 flow-level 统计数据。利用这样的简单的记录方法，PathDump 可以检测网络中的环、最长路径、协议 bug 、网络中的黑洞等等 bug。</p>

<h4>>> Network Requirement for Resource Disaggregation &lt;&lt;&lt;</h4>

<p>这就是来自 NetSys 组的另一篇论文，一作 Peter Gao 同样也是 SIGCOMM 2015 上 NetSys 发表的 Rollback Middlebox 的二作（当年的一作 Justine Sherry 也是带着大把顶会论文毕业并加入了 CMU）。</p>

<p>近年来资源解耦（Resource Disaggregation）被作为一种新的数据中心设计方案提出来，即将相同的资源放在一起作为资源池并连接起来。这与传统的数据中心有很大区别。传统数据中心使用的是通用服务器硬件，利用网络构建复杂的拓扑结构将所有服务器连接起来。Disaggregation 的思想是，将处理器、内存、外部存储等各类资源分类聚合，而不是以服务器为个体。这种思想的着眼点是更高的可伸缩性。</p>

<p>但是目前世界上还没有商用的这样架构的数据中心，因此这篇论文的贡献主要是通过测量现有的大数据应用，了解大规模计算应用的网络需求，估算未来的解耦设计的数据中心的网络需要达到怎样的性能才够。他们测试了 Hadoop、GraphLab、Memcahced、Spark Streaming、Spark SQL 等大数据应用，使用不同性能的网络（延迟和贷款）硬件进行测试，比较性能的提升和下降，给出了大量的数据，有兴趣的朋友可以仔细读论文和测试。</p>

<p>他们的结论是：1.现有的 40-100 Gbps 的网络硬件足以满足现在的应用的要求。2.网络的延迟需要在 3-5 微秒才能满足应用需求，这一点在当前是比较困难的。如果使用传统的以太网，可能需要类似 DPDK 这样的绕过内核的网络框架才能提供。最后他们认为，在数据中心层面实现 disaggregation 是可行的。</p>

<hr />

<h3>Session~[Graph Processing and Machine Learning]</h3>

<h4>>>> TensorFlow: A System for Large-Scale Machine Learning &lt;&lt;&lt;</h4>

<p>TensorFlow这个工作有22个作者，其中包括传说中的Jeff Dean。</p>

<p>TensorFlow是一个可以应用在大规模分布式环境和异构环境中的机器学习系统，使用数据流图表示计算，共享状态，以及使该状态发生变化的操作。它可以将数据流图的节点映射到一个集群中的多台机器上，也可以映射到每个机器中的多种计算设备上，包括多核CPU，通用GPU和定制的ASIC张量处理单元（TPU）。通过单一的编程模型来管理全部的计算和状态，程序员可以很方便地实验不同的并行化方案，如把计算offload到拥有共享状态的服务器上等等。</p>

<p><img src="http://ytliu.info/images/osdi2016/17-1.png" alt="17-1" /></p>

<p>上图是一个样例数据流图。和以往Batch系统最大的不同是，TensorFlow允许在重叠的子图上并发计算，并发的计算可以共享顶点上的可变的状态。这种设计对于机器学习来说很有用，因为它可以让更新更快地被传播出去。</p>

<h4>>>> Exploring the Hidden Dimension in Graph Processing &lt;&lt;&lt;</h4>

<p>这篇论文的一作Mingxing Zhang来自清华大学madsys组，是第5年的phd学生，导师Yongwei Wu。</p>

<p>图的划分对于分布式图计算系统来说，是至关重要的一步。划分算法最初是一纬的，即按照点为单位划分，每个顶点完成一个Task，后来PowerGraph提出了2维的划分算法，让Task的粒度更细，每个边代表一个Task，解决了自然图的不平衡的问题。于是作者就思考，能不能再进一步，提出3维的划分算法。现有的图计算系统，属性都是不可分割的，包括顶点上的属性，以及边上的属性。作者的观点是，顶点和边的属性也是可以再分割的！这就是第3个纬度。</p>

<p>许多MLDM算法可以用图来对原问题建模，比如推荐算法中，用户和物品被抽象成顶点，用户对物品的评价抽象成边，每个顶点的属性就是一个大的向量，这个向量就是可以被拆分的。于是作者提出了3D划分算法，举个例子，左边是原始图，被划分成上下2层，每一层又包含两台机器。每一层包含了整张原图以及一半的属性值，同层内部用2维的划分算法进行划分。</p>

<p><img src="http://ytliu.info/images/osdi2016/18-1.png" alt="18-1" /></p>

<p>于是3D划分算法多了一个可以调整的参数，层数L。L=1时等同于2D划分算法，L=机器数N时，相当于每台机器存储了原始的图拓扑结构以及1/N的属性。作者提出新的编程模型，Update是汇总顶点或边的属性，Push,Pull,Sink则是根据src,dst,edge三者中的两者更新另一者的值。这几种操作带来的通信开销可以被划分为两类：一类是同层间不同机器的通信开销，L越大，每一层机器越少，2D划分算法造成的平均副本数越少，通信开销越小；另一类是跨层的通信开销，即把同一个顶点或边的属性从不同层中汇总起来的开销，L=1时，这种开销不存在，L越大开销越大。</p>

<p>不同算法需要的操作不一样，通信开销也不一样，因此可以根据算法本身的特性，调整L的值，使得性能最好。</p>

<h4>>>> Gemini: A Computation-Centric Distributed Graph Processing System &lt;&lt;&lt;</h4>

<p>这篇论文的一作Xiaowei Zhu来自清华大学PACMAN组，是第4年的phd学生，导师Wenguang Chen。
Xiaowei Zhu在图计算领域做了很多工作，比如ATC&#8217;15的GridGraph。</p>

<p>分析了现有的单机和分布式图计算系统后，作者认为，分布式图计算系统主要慢在计算效率不高。
因此作者利用各种优化方法提升计算效率，实现了一个高效的分布式图计算系统。</p>

<p>图计算有两种不同的模式，pull(dense)模式和push(sparse)模式。pull模式下所有顶点拉取它们的入边邻居信息，然后更新自己，push模式下所有激活的顶点更新出边邻居的值。当激活的顶点很多时，pull模式性能比较好，因为每个顶点之间的更新不会相互冲突。当激活的顶点很少时，push模式性能比较好，因为可以跳过很多不必要的计算。单机系统Ligra动态切换pull-push模式，来获得性能提升，Gemini将这个技术用在分布式系统上。pull时，所有Mirror顶点读取邻居的值，然后汇总给master顶点。push时，Master顶点激活所有Mirror顶点，然后Mirror再更新它的邻居的值。</p>

<p><img src="http://ytliu.info/images/osdi2016/19-1.png" alt="19-1" /></p>

<p>Gemini的图划分算法是Chunk-Based的划分算法，就是连续id的顶点被划分到同一台机器上。这是基于一个观察：实际的图通常是通过爬虫采集的，因此相邻id很有可能是同一时刻被采集到的数据，它们之间存在边的可能性比较大，所以Chunk-Based划分有更好的locality。此外Chunk-Based划分还有别的好处，如全局的id和每台机器的local id之间转化开销很小。但Chunk-Based划分会带来负载均衡问题，因此Gemini调整每个机器的顶点个数，使得每台机器⍺·|V|+|E|的值大致相等。</p>

<h4>>>> Fast and Concurrent RDF Queries with RDMA-based Distributed Graph Exploration &lt;&lt;&lt;</h4>

<p>这是我们实验室自己的论文，一作Jiaxin Shi是第3年的硕士，由Haibo Chen和Rong Chen共同指导。
Jiaxin Shi之前也参与过其他的图计算工作，比如EuroSys&#8217;15的PowerLyra。</p>

<p>前面两个工作是图计算工作，而这篇是关于RDF图查询的。RDF常被语义网用来描述网络资源。简单地可以认为，RDF是一张大图，图的顶点是各种人或物，边是顶点之间存在的关系，例如老师、学生、课程之间存在着老师教课程、学生选课程等关系。这个工作主要是实现了一个用RDMA优化分布式图查询系统Wukong。</p>

<p>以一个查询为例，如果要找所有XYZ三元组，满足XY，YZ，ZX之间都有边，现有系统使用单步剪枝法，每一轮从现有顶点出发找下一轮激活的顶点，然后同步被激活的顶点，然后再从新的顶点继续。X找到邻居Y，Y再找到邻居Z，Z再找到邻居X，每完成一步都需要不同机器间同步，而且最后通过Z找到的X和最开始的X不一定相同，因此需要再做一个最终的连接。</p>

<p>作者提出全历史剪枝法，即Y被激活时，它知道整个历史信息XY，Z被激活时，知道所有历史信息XYZ，因此Z找邻居X时，根据历史信息，可以知道哪些X是可以直接排除的。RDMA有个特性，就是传输开销在一定范围内变化不大，传输8byte和传输2K的开销差别不大，因此作者使用RDMA WRITE来传输全历史信息，通信开销不一定会增大，但是最终连接确实一定可以避免的。</p>

<p><img src="http://ytliu.info/images/osdi2016/20-1.png" alt="20-1" /></p>

<p>此外，现有分布式系统的问题在于利用所有资源去处理分布式请求，无论是选择性弱的涉及大多数顶点的请求，还是选择性强的只涉及若干个顶点的请求。而Wukong则支持两种执行模式，Fork-Join模式和In-Place模式，如图所示。</p>

<p>Fork-Join模式是当需要处理的数据量比较大时，把请求拆分成子请求，连同相关的全历史信息发送给其他机器或者其他线程执行，可以并行地处理同一个请求。In-Place模式是当需要处理选择性强的简单请求时，单个线程执行完，需要用到远端数据时，直接使用RDMA READ把对应的数据读取过来。使用In-Place模式，整个系统有100个核的话，就可以并发处理100个分布式简单请求，系统吞吐量很高。</p>

<hr />

<h3>Session~[Languages and Software Engineering]</h3>

<h4>>>> REX: A Development Platform and Online Learning Approach for Runtime Emergent Software Systems &lt;&lt;&lt;</h4>

<p>这篇论文是由Lancaster大学的研究者完成的，一作<a href="http://www.lancaster.ac.uk/scc/about-us/people/barry-porter">Barry Porter</a>是该校的lecturer，其主要研究方向就是论文题目中的emergent software systems。这种类型的系统是由很多模块组成的 (component-based)，并可以在运行时根据外部条件和自身状态进行动态地重新组装。作者认为，目前这类系统的主要问题是人工干预太多，管理复杂，因此他们提出了REX，旨在节省人力的同时达到好的运行效果。</p>

<p>REX的基础是component，所以作者首先提出了用于开发和申明component的语言Dana。在Dana中，每个component的申明可以提供(provide)一些接口，也可以需求(require)一些接口。一个典型的component定义如下：</p>

<p><img src="http://ytliu.info/images/osdi2016/21-1.jpg" alt="21-1" /></p>

<p>component的定义为组装提供了可能。在组装时，REX会将需求接口A的component与提供接口A的component连接在一起，构建出更大规模的软件。例子中需求File接口的component，就会被连接到一个提供File接口的component。如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/21-2.png" alt="21-2" /></p>

<p>在component的基础之上，论文又提出了他们的PAL(perception, assembly, learning)平台，用于在运行时进行动态地组装。其中，每个component都有一些用于“感知”的方法，会对整个系统及自身运行状态进行监测；而PAL平台则会从这些监测信息里学习，并决定是否要进行重组。当重组发生时，新的component会取代旧的，并继承一些旧component的状态，整个过程有点像live update。</p>

<p>在实际情况下，一个系统往往拥有很多个可替换的component，因此暴力枚举所有的组装方案恐怕是不实际的。论文还提出了他们自己的statistical linear bandits算法用来解决这一问题。笔者对机器学习算法了解有限，这里就不再赘述了，有兴趣的读者可以参阅他们的论文。</p>

<h4>>>>Yak: A High-Performance Big-Data-Friendly Garbage Collector &lt;&lt;&lt;</h4>

<p>这篇论文是由多家机构一起完成的，作者大多来自加州大学尔湾分校(UCI)。第一作者<a href="http://www.ics.uci.edu/~khanhtn1/">Khanh Nguyen</a>是UCI的五年级Ph.D.学生，第二作者<a href="http://www.ics.uci.edu/~lfang3/">Lu Fang</a>也是Ph.D.五年级，<a href="http://www.ics.uci.edu/~guoqingx/">Guoqing Xu</a>是他俩的老师。他们组研究的核心是Java，既研究用Java实现的应用(比如GraphChi, Hyracks, Hadoop)的行为，也研究Java虚拟机的问题，在最近几年发表了不少相关的论文，比如去年SOSP上的Interruptible Task (Lu Fang为一作)，以及今年的这篇Yak。</p>

<p>与C/C++不同，Java虚拟机提供的是自动的内存管理机制——垃圾收集器(Garbage Collector, GC)。目前应用比较广泛的是分代式收集器(Generation GC)，它的假设是大多数对象的生命周期都很短，因此垃圾收集器将内存分为young区和old区，对象一开始都会分配到young区，只有经历了较长时间还活着的对象才会被拷贝到old区。在上述关于生命周期的假设成立的情况下，大多数的对象都会在young区死亡，因此被拷贝的对象很少。</p>

<p>然而，上述假设在大数据环境下并不成立。作者对一些大数据框架进行了分析，发现很多对象都并不会在young区死亡；相对的，它们的生命周期和程序的执行流紧密相关。比如在迭代式算法中，很多对象将在迭代开始时被分配出来，在迭代结束时将不再被访问。由于当前的垃圾收集器没有考虑到这一特征，在迭代执行期间也会进行垃圾收集，其结果就是大量对象存活并拷贝，造成了不必要的开销。</p>

<p>基于这些观察，论文提出了一种新的垃圾收集器：Yak。Yak将程序的执行分解为一个个<strong>epoch</strong>，要求程序员用<code>epoch_start()</code>和<code>epoch_end()</code>将epoch标记出来。当见到<code>epoch_start()</code>时，Yak会产生一个新的内存区域与该epoch对应，此后产生的新对象将被放入到该区域；当见到<code>epoch_end()</code>时，Yak会回收该epoch对应的内存区域。由于GC只有在epoch结束时才会进行，不必要的内存拷贝被大大减少了。</p>

<p>当然，有的时候对象的生命周期并不是和epoch一致的。为了保证正确性，Yak为每个内存区域维护一个remember set，记录是否有区域以外的对象引用了区域内的对象。例如在下图中，对象D被区域<strong>&lt;r21,t1></strong>以外的对象C引用，这将会记录在区域<strong>&lt;r21,t1></strong>的remember set之中。在epoch结束时，所有在remember set之中被引用的对象不能被直接销毁；它们会被拷贝到一个尚未执行结束的epoch，等待下一次GC。</p>

<p><img src="http://ytliu.info/images/osdi2016/22-1.png" alt="22-1" /></p>

<p>这篇文章一定程度上可以说是一些工作的集大成者，其中包括了许多前人的想法，比如将大数据框架中存储数据的对象区别对待以及基于区域(region-based)的垃圾收集，而remember set则与OpenJDK新晋的垃圾收集器——G1的设计颇为相似。由于Java在大数据处理方面的应用非常广泛，可以想见这种通过优化Java运行时来提升性能的工作还将继续涌现。</p>

<h4>>>> Shuffler: Fast and Deployable Continuous Code Re-Randomization &lt;&lt;&lt;</h4>

<p>这篇文章同样是多个机构合作的成果，其中包括一作在内的大部分作者都是<a href="http://www.cs.columbia.edu/~junfeng/">Junfeng Yang</a>的学生，他们的工作主要集中于构建可信赖的和安全的系统，涵盖的范围也是较为广泛。</p>

<p>这篇论文要对付的攻击是代码重用攻击(code-reuse attack)，这类攻击一般从一个内存漏洞开始，通过重用源程序中的良性代码片段拼凑出恶意程序并执行。这类攻击十分巧妙且有很多变种，很难防御。</p>

<p>本文主要采用运行时持续的随机化来达到防御的目的。过去的随机化(如地址空间结构随机化ASLR)虽然也能让代码的地址每次执行时都有所不同，但在执行过程中各部分地址却保持不变，因此可以被攻击者破解。而持续的随机化则会在运行过程中不断地重复随机化过程，即使攻击者真的找到了一些可用的代码片段，它们也会因为随机化造成的地址变化而变得不可用。理论上来说，如果持续随机化具有极高的频率，攻击者就没有充分的时间来获取足够多的代码片段，攻击也就没有办法进行。所以这篇文章主要的贡献，就是如题目所说——让持续随机化变得高效且可用。</p>

<p>持续随机化遇到的主要挑战是如何处理好代码指针(code pointer)。为了方便管理，Shuffler把所有的code pointer都放入了一个源程序不可见的code pointer table里，而原来代码中对code pointer的直接访问都变成了从code pointer table里获取对应code pointer的间接访问。这样，Shuffler只需要在随机化时遍历table并修改所有code pointer的地址即可，而访问code pointer的代码则完全不需要修改，随机化的过程得到了很大的简化。对于动态产生的返回地址，Shuffler采取加密的方式来防止攻击者直接读取。下图简单展示了Shuffler的工作原理。</p>

<p><img src="http://ytliu.info/images/osdi2016/23-1.jpg" alt="23-1" /></p>

<p>持续随机化的另一难题是语义问题。有的时候，我们很难通过汇编码判断出某个值究竟是一个代码指针还是只是一个普通的数字，而持续随机化要求准确地发现代码指针并予以随机化，这仅仅依靠语义较少的汇编代码是很困难的。因此，Shuffler提出了<strong>扩展的二进制文件分析</strong>(augmented binary analysis, ABA)，要求用户提供诸如symbol table,relocation table等编译器生成的元数据作为分析的辅助材料。通过ABA，Shuffler就能解决包括准确识别代码指针在内的各类琐碎问题，有兴趣的读者可以参阅论文来了解这些细节。</p>

<p>作者使用SPECCPU2006进行了测试，发现在以50ms为随机化间隔的情况下平均开销仅为14.9%，而现实生活中的代码重用攻击所花的时间一般多于50ms，可以说基本达到了题目中fast and deployable的目的。</p>

<p>实际上，通过持续随机化来防御代码重用攻击的工作到最近几年才开始逐渐出现，可以说还处于一个发展状态，或许未来还会有不少工作在Shuffler之上有所突破。</p>

<h4>>>> Don’t Get Caught in the Cold, Warm-up Your JVM: Understand and Eliminate JVM Warm-up Overhead in Data-Parallel Systems &lt;&lt;&lt;</h4>

<p>这篇工作的大部分作者来自于多伦多大学，David Lion, Adrian Chiu以及Xin Zhuang都是<a href="http://www.eecg.toronto.edu/~yuan/Home.html">Ding Yuan</a>的学生，袁老师这次在OSDI斩获两篇论文，而且两份工作的方向大不相同，令人印象深刻。</p>

<p>这篇论文是从回答“在当前data-parallel的系统中，JVM究竟带来了什么开销”这一问题开始的。作者对data-prallel系统的执行行为进行了分析，他们发现，JVM的warm-up时间是非常可观的，而warm-up主要由两部分组成：Java解释器执行，以及大量的Java类载入。这部分warm-up时间常常被人忽略，因为一般人们会假设JVM会运行一段较长的时间，而warm-up时间趋于恒定，因此可以忽略不计。但是，对于一些执行时间较短的Java应用来说(比如仅执行一次query就退出JVM的应用)，warm-up的开销就非常可观了。</p>

<p>论文提出的解决方案非常简单：他们提出了HotTub，一个类似线程池概念的JVM池。一般情况下，当Java的main函数退出时，JVM进程也会退出，但论文选择让该进程休眠。当用户再次尝试用Java运行某个应用时，HotTub会尝试在JVM池里找一个曾经运行过类似应用，已经warm-up完成的JVM直接进行使用，从而避免了解释器执行和大量的Java类载入。性能测试里也说明，他们能为Spark的query带来至多1.8X的性能提升。</p>

<p>相比这个session的其他工作，HotTub给人的感觉是找到了一个好问题，但是解决方案过于简单直接，也缺乏和其他解决方案的比较。笔者在茶歇时间曾找到一作聊天，他自己也认为这篇论文目前的解决方案较为简单，并表示之后还会继续关注JVM的性能问题，也许将来他们还会继续完善这一工作吧。</p>

<hr />

<h3>Session~[Potpourri]</h3>

<h4>>>> EC-Cache: Load-Balanced, Low-Latency Cluster Caching with Online Erasure Coding &lt;&lt;&lt;</h4>

<p>这篇论文来自 UC Berkeley 和 U Michigan 。值得一提的是，这估计是 OSDI 历史上第一次通过视频的方式进行的演讲。由于各种原因第一作者 K.V. Rashmi 没有能够来到会场，而问答环节是由其他作者代为进行的。</p>

<p><strong>问题是什么：</strong>
这篇文章的主要关注点在于分布式的内存缓存 (Distributed, in-memory caching) 。在传统的分布式内存缓存中，很大的一个问题就是不平衡 (imbalance) 。作者通过分析发现不平衡的来源至少有三个：1. 每个对象的热度不一样；2. 网络环境是不平衡的；3. 集群中的失败 (failure) 和不可用 (unavailability) 。这些不平衡会直接影响到集群的负载均衡以及读延迟（毕竟 caching 主要的目的还是为了读取，而非写入）。此处有个小结论，作者认为在内存里面只放一份数据，是不足以得到很好的性能的 (Single copy in memory not sufficent to get good performance) 。</p>

<p><strong>现有方法：</strong>
为了解决不平衡的问题，现有的解决方案是选择性备份 (Selective Replication) 。这种方案根据被缓存对象的热度将其分类，对于热数据使用更多的备份 (replica) 进行存储。如下面图中，由于对数据 A 的请求数更多， A 被备份在 Server 3 上，随后对于数据A的请求被分在 Server 1 和 Server 3 两个服务器上。选择性备份通过使用跟多的内存（用于保存备份）来达到更好的负载均衡，进一步提高数据读取性能。</p>

<p>下图为普通的缓存：</p>

<p><img src="http://ytliu.info/images/osdi2016/25-0.png" alt="Selective Replication" /></p>

<p>下图为选择性备份的缓存：</p>

<p><img src="http://ytliu.info/images/osdi2016/25-1.png" alt="SR2" /></p>

<p><strong>本文的方法：</strong>
这篇文章的目的就是在使用与选择性备份相同的内存情况下，进一步的提升系统的负载均衡和读取性能。而解决这个问题的关键，是使用了抹除码 (Erasure Coding)。抹除码是一种被广泛用于存储（尤其是磁盘存储）的编码技术。其特点在于，通过根据已有的 k 份数据单元 (data unit) 进行编码，可得到 r 份校验单元 (parity unit)。随后通过这 (k+r) 个单元中的任意 k 个单元，均可恢复出 k 个数据单元。例如下图中， d1~d5 是五个数据单元，根据五个数据单元，产生了四个校验单元 p1~p4。图中的两个例子，即是通过任意的五个单元，解码得到 d1~d5 的内容。其实原理类似于 RAID-5 和 RAID-6 。更多关于抹除码的资料可以看一下 <a href="https://en.wikipedia.org/wiki/Erasure_code">Erasure code - Wikipedia</a> 。</p>

<p>解码方法1:</p>

<p><img src="http://ytliu.info/images/osdi2016/25-2.png" alt="EC-Decode1" /></p>

<p>解码方法2:</p>

<p><img src="http://ytliu.info/images/osdi2016/25-3.png" alt="EC-Decode2" /></p>

<p><strong>EC-Cache：</strong>
在了解了抹除码的使用方法之后，我们来看一下这篇文章的 EC-Cache 是如何使用抹除码的。</p>

<p><strong>Writes：</strong>
如下图，如果要写入一个对象 X ， EC-Cache 先将其分割成 k 个数据单元，随后进行抹除码的编码，产生额外的 r 个校验单元。最后 EC-Cache 将这 (k+r) 个单元随机的保存在不同的服务器上。过程很简单，如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/25-4.png" alt="Write" /></p>

<p><strong>Reads：</strong>
如下图， EC-Cache 读取对象也很简单。在知道一个对象 X 的 (k+r) 个单元保存在哪些服务器上之后， EC-Cache 向这 (k+r) 个服务器发出读取请求。由于网络问题或者服务器负载问题，有些服务器的回复会比较慢。好在 EC-Cache 在收到 k 个回复之后，便可以直接使用这 k 个单元进行抹除码解码操作，得到 k 个数据单元，即全部对象 X 的数据，返回给客户端。</p>

<p><img src="http://ytliu.info/images/osdi2016/25-5.png" alt="Read" />*</p>

<p>上述的读写方法，至少在两个方面上有很好的效果：</p>

<ol>
<li>负载均衡。每一个对象均被分摊到多个服务器之上，可以更加均匀的把工作分摊给更多的服务器。论文中有关于负载均衡上更加“较”严格的证明，有兴趣的读者可以参看论文。</li>
<li>读延迟。在这个上面的影响是双重的。一来，由于数据被分割成 k 份，虽然总的传输量不变，但现在有更多的服务器同时提供数据，这并行化了读取操作。二来，由于 EC-Cache 只需要等待 (k+r) 个请求中回复最快的 k 个请求，这会大幅度的减小尾延迟 (tail latency)。</li>
</ol>


<p><strong>一些限制和缺点：</strong>
当然，这部分也可以叫做“适用范围”。┐(ﾟ～ﾟ)┌</p>

<ol>
<li>不可修改数据 (Immutable data) 。由于 EC-Cache 不支持数据的更新修改……其实如果通过先删除再添加的方法，应该也是可以支持的，但是这样性能并不好。这算是一个限制。</li>
<li>对象要足够大。由于 EC-Cache 使用了抹除码，而对于较小的数据，使用抹除码的效率并不高。另外对于连接和从多台服务器上读取数据来说，如果数据较小，其性能消耗 (overhead) 相对来说也是很大的。</li>
<li>网络通信（带宽占用）较多。这个也是由于使用抹除码导致的，论文中说大概有 10% 左右。</li>
</ol>


<p>最终稍微总结一下，这篇文章将 Erasure Coding 应用到了分布式内存缓存系统中，主要解决了 load balance 以及 latency 的问题。</p>

<h4>>>> To Waffinity and Beyond: A Scalable Architecture for Incremental Parallelization of File System Code &lt;&lt;&lt;</h4>

<p>这是一篇来自 NetApp 的历史总结论文 :P 。文章大概总结了 NetApp 将其文件系统一步步并行化的改进过程。笔者认为这种系统软件随着硬件的变化而一步步演变的过程十分有趣。</p>

<p><strong>主要问题：</strong>
在单核处理器时编写的文件系统 (Write Anywhere File Layout, WAFL) ，如何在尽可能少的修改的前提下（毕竟稳定性很重要），适应和充分利用多核处理器架构。</p>

<p><strong>背景：</strong>
在 WAFL 的设计之初，多核处理器架构还未被广泛使用。因而最初版本的 WAFL 是串行的处理所有的消息 (message) 的。然而随着核心数目的增多，串行化的消息处理不能利用到多核的的优势。</p>

<p><strong>Classical Waffinity (2006)</strong>
WAFL 的第一次演变，是将用户文件划分成固定大小的块 (chunk) ，叫做 file stripes 。 File stripes 被轮换着的分配给一组消息队列，即 Stripe affinities 。如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/26-0.png" alt="CW" /></p>

<p>Stripe 1 ~ Stripe 5 是五个 Stripe affinities ， msg 为每个 Stripe 上要做的请求，比如读写这个文件块中的数据。系统中有一个 affinity 的调度器，负责动态的把 affinity 分配给一个线程去执行。调度器调度的对象是 affinity ，因而在同一时刻，不会存在两个线程处理同一个 affinity ，从而避免了数据竞争。除了这些 stripe affinities 之外，还有一个 serial affinity ，用于处理所有 file stripe 之外的工作，比如元数据的读写。</p>

<p><strong>Hierarchical Waffinity (2011)：</strong>
然而随着多核处理器核心数目的进一步增加， Classical Waffinity 逐渐开始无法充分利用全部的处理器资源。因此 WAFL 进行了第二次演变，这次演变的成果，就是 Hierachical Waffinity 。</p>

<p>与 Classical Waffinity 的不同，Hierarchical Waffinity 中，不仅仅只有用户文件被划分，整个文件系统架构都被进行了划分从而更好的利用计算资源。如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/26-1.png" alt="HW" /></p>

<p>按照文件系统的设计层次，整个文件系统被划分成了有层次化的多个 affinity。如同 hierarchical lock 一样，父 affinity 是不能和子 affinity 同时执行的。例如当某个 Volume 被执行的时候，其下面的 Volume Logical 是不能被调度执行的；但是 Volume 和 Aggregate VBN 是可以同时被调度执行的。</p>

<p>通过这种划分，整个系统可以被更细粒度的被调度执行，在 Classical Waffinity 中 serial affinity 中的任务被进一步的并行化。而 Classical Waffinity 中的 stripe affinity 被保留下来。另外一点很重要的是，由于原本文件系统就存在层次化结构，这种根据已有层次进行 affinity 的划分，就如同庖丁解牛一般，只需要在原有系统上很小的修改，就能够达到好的性能提升。</p>

<p><strong>Hybrid Waffinity (2016)：</strong>
Hierarchical Waffinity 能够增加并行度，然而其还有继续被优化的空间。在 Hierarchical Waffinity 中，如果要同时修改的内容位于两个不同的 affinities 中，为了保证数据的一致性，需要找到两个 affinities 在树形结构中的最近公共祖先，并在这个公共祖先代表的 affinity 中进行执行。如下图：</p>

<p><img src="http://ytliu.info/images/osdi2016/26-3.png" alt="HW-Problem" /></p>

<p>如果要修改用户数据，需要在蓝色 affinity 中执行，如果要修改元数据，需要在黄色 affinity 中进行执行。而如果要同时修改用户数据和元数据，为了保证数据一致性，需要找到蓝色 affinity 和黄色 affnity 的最近公共祖先，即红色的affinity。并在这个红色的 affinity 中进行执行。然而这样会阻塞红色 aggregate affinity 下面的所有的子 affinities。</p>

<p>为了解决这个问题， Hybrid Waffinity 被提出。 Hybrid Waffinity 在 Hierarchical Waffinity 的基础上，引入了细粒度的锁 (fine-grained locking) 。如下图：</p>

<p><img src="http://ytliu.info/images/osdi2016/26-4.png" alt="HyW" /></p>

<p>在 Hierarchical Waffinity 的基础上，黄色的 affinities 中的元数据还被锁保护。通过这种方式，之前的例子中，蓝色区域的 Stripe 使用 affinity 保护，而黄色区域中的 AVBN Range 则使用细粒度的锁，从而避免了由于使用 aggregate affinity 导致的对其他子 affinities 的阻塞。</p>

<p>最后给出一张作者的 backup slides 中关于 Schedular 的一张图，希望可以帮助读者更好的进行理解：</p>

<p><img src="http://ytliu.info/images/osdi2016/26-5.png" alt="Schedule" /></p>

<p>这篇文章总结了 NetApp 如何一步步的将其串行化的文件系统逐渐并行起来，反映了软件系统随着硬件的提升而不断演变的过程。在这项工作中，稳定性是非常重要的一点，因而在每一步的演化中都在追求性能的同时，尽可能少的减少代码的修改量，从而保证系统的稳定性。</p>

<h4>>>> CLARINET: WAN-Aware Optimization for Analytics Queries &lt;&lt;&lt;</h4>

<p>这是一项来自 UW-Madison 和 MSR 的工作。</p>

<p><strong>背景：</strong>
为了减少用户使用的延迟，现在的很多应用的服务器分布在世界各地的多个数据中心里。但当我们需要对多个数据中心里的数据进行分析时，中心化的分析是一种很浪费的选择。中心化的分析，需要将多个数据中心里的数据集中到一台机器上，随后使用单数据中心的分析框架 (intra-data center analytics framework) 对数据进行分析。由于广域网 (WAN) 的带宽有限，这种中心化的分析不仅带来很高的延迟，还会耗费大量的资金。</p>

<p><strong>地理分布式分析：</strong>
另外一种方法是使用地理分布式分析 (Geo-distributed Analytics) 。如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/27-0.png" alt="GeoDA" /></p>

<p>当收到一个分布式查询请求时，查询优化器 (Query Optimizer) 会先根据请求产生查询方案，随后通过分布式执行层 (Distributed Execution Layer) 执行查询，期间会通过分布式存储层 (Distributed Storage Layer) 从各数据中心中读取数据。</p>

<p>然而，现有的查询优化并没有将广域网考虑在内，其产生的查询方案往往不是最优的。例如下图中：</p>

<p><img src="http://ytliu.info/images/osdi2016/27-1.png" alt="QueryPlans" /></p>

<p>在左上的网络情况下，对于右边的查询，可以产生 Plan A ~ Plan C 三种查询方案。按照已有的查询优化方法，因为 Plan A 中产生的中间数据量最小，优化器最终会选择 Plan A 进行执行。</p>

<p>然而在实际情况中，因为广域网的网络情况，执行 Plan A 所需要的时间是最长的。相反，虽然 Plan C 需要传输的数据总量最大，但是由于广域网网络环境，其在实际测试中耗时最短。</p>

<p>这说明，在地理分布式分析时，查询优化器应该将广域网网络环境考虑在内。</p>

<p><strong>其他影响因素：</strong>
除了上述的网络传输速度之外，还有一些其他的因素会影响到查询方案的执行时间。</p>

<ul>
<li>如下图中的 Map-Reduce 任务，原有的方案是将任务放在一个数据中心中执行，即将 DC1 中的数据传输到 DC2 中后，在 DC2 中进行 Reduce 操作。这个过程需要 200GB / 80Gbps = 20s 。然而如果我们把工作均匀地分配在两个数据中心，由于网络是全双工的，单方向上需要传输的数据是原来的一半，耗时 100GB / 80Gbps = 10s 。因此查询优化器应该考虑到所有可行的任务分配 (Task Placement) 方法。</li>
</ul>


<p>任务在一个数据中心:</p>

<p><img src="http://ytliu.info/images/osdi2016/27-2.png" alt="1DC" /></p>

<p>任务在两个数据中心:</p>

<p><img src="http://ytliu.info/images/osdi2016/27-3.png" alt="2DCs" /></p>

<ul>
<li>此外，由于网络中会有其他的应用在执行，虽然 DC1 和 DC3 之间的网络带宽最大（100Gbps），但是若存在一个更高级别的应用（或查询）正在占用这条线路，依赖于 DC1 和 DC3 之间带宽的 Plan C 依然可能不是最优的选择。这说明网络传输的调度也会影响到查询方案执行的时间。</li>
</ul>


<p><strong>Clarinet：</strong>
本文提出的 Clarinet 系统，综合了以上提到的各种影响因素，提供更快的地理分布式分析执行方案。如下图：</p>

<p><img src="http://ytliu.info/images/osdi2016/27-4.png" alt="Clarinet" /></p>

<p>系统首先通过查询语句产生多种查询方案，随后在逻辑上的查询方案中加入任务分配和调度等因素，产生物理查询方案，最终 Clarinet 会选择最快的方案进行执行。</p>

<p><strong>网络可知 (Network aware) 的任务分配与调度：</strong>
对于任务分配， Clarinet 在查询的每一步（如某个 join ），都使用贪心的策略，以最小化每一步的运行时间。</p>

<p>对于网络传输的调度， Clarinet 首先确定跨数据中心的网络传输的开始时间，和网络传输的依赖关系，使用二元整数线性规划去求得最优解。由于多个查询之间会有相互影响（例如两个查询都要占用同一条线路），在选择执行方案时，多个查询会被综合考虑。</p>

<p><strong>迭代的最快任务优先 (Iterative Shortest Job First)：</strong>
综合考虑多个查询的目标，是要最小化平均完成时间。 Clarinet 使用一种迭代的策略。在每轮迭代中包括：</p>

<ol>
<li>计算每个查询下一步要执行的时间；</li>
<li>在所有要执行的查询方案中，选择需要时间最少的一步查询安排执行（并非真正执行）；</li>
<li>为被选中的这一步查询留出足够的带宽，更新每个查询下一步需要执行的时间。</li>
</ol>


<p>通过不断执行上述迭代， Clarinet 可以得到一个具体的执行方案。然而在这种方法会产生碎片化。如下图左边：</p>

<p><img src="http://ytliu.info/images/osdi2016/27-5.png" alt="SJF" /></p>

<p>由于在上述迭代中 B1 被先于 A 任务选中，会使得 Link 2 中前 12 个单位时间是空闲的。 Clarinet 针对这种情况，将通过迭代产生的执行序列重新排列，从而得到图中右边的执行方案，总执行时间减少了 10 个时间单位。</p>

<p>这种调度方法进一步可以演化成 k-最快任务优先 (k-Shortest Jobs First) 。类似的，首先找到 k 个最快的未完成的任务，只要其所需要的线路空闲，就开始执行这些任务。</p>

<p>实话说，笔者并没有非常认真的读这篇文章，但在写这篇总结的时候着重看了一些段落，发现其实文章中的很多东西非常值得一读，并没有笔者认为的那么晦涩难懂。另外作者在 slides 中举的例子和论文中的例子并非一致，也希望读者在看过论文之后应该能看出两者的异同。</p>

<h4>>>> JetStream: Cluster-Scale Parallelization of Information Flow Queries &lt;&lt;&lt;</h4>

<p>这篇文章来自 U Michigan ，主要目的在于提供一种能够利用集群并行地处理信息流查询 (Information Flow Query) 的方法。</p>

<p><strong>背景：</strong>
动态信息流跟踪 (Dynamic Information Flow Tracking, DIFT, aka. Taint-Tracking) 在很多领域都是一个重要的工具。然而现有的工具需要很长时间才能完成信息流的查询，这极大的影响了动态信息流跟踪在调试程序、跟踪隐私数据以及性能调优等方面的使用。不幸的是，由于程序中串行的依赖，并行化动态信息流跟踪是一件很困难的事情。</p>

<p><strong>JetStream：</strong>
本文提出了一种并行化动态信息流跟踪的方法，利用计算机集群的并行化计算能力加速动态信息流跟踪的执行。主要分成两步，本地 DIFT 以及 Aggregation 。这两步中使用不同的方法来提高并行性。本地 DIFT 使用 Epoch Parallelism ， Aggregation 使用 Pipeline Parallelism 。</p>

<p><strong>本地 DIFT：</strong>
首先将程序切分成好多 Epochs ，然后使用 Record and Replay 在每个 Epoch 内部计算 DIFT 。由于内部的 Epoch 时是不知道全局的 Input 的，所以其要计算的是 local source 和 local sink 之间的关系。其中 local source 包括全局的 Input 与之前所有 Epoch 之间的中间变量。 local sink 同理，包括全局的 Output 以及之后的 Epoch 可能会用到的中间变量。</p>

<p>集群中每台机器负责一个 Epoch ，因此这个过程被自然的并行化了。</p>

<p>此时有一点需要注意，在本地计算 DIFT 的时候，并不急于计算出 Epoch 内部 local source 和 local sink 之间的关系，而是将 local source 和 local sink 之间的中间变量以 log 的方式记录下来，从而形成一种图结构。这个图结构会在 Aggregation 阶段被解析。如下图：</p>

<p><img src="http://ytliu.info/images/osdi2016/28-0.png" alt="l-DIFT" /></p>

<p>中间的小圆圈既不是 local source 也不是 local sink ，而是一些中间变量。通过记录这些中间变量，图中的图状结构记录了 local sources A, B, C 与 local sinks C, D 之间的关系。</p>

<p>由于每台服务器负责一个 Epoch ，其并不需要在最开始就开始记录所有的读写操作。因此此处有一个优化，称为 Fast Forward ，即服务器首先正常地执行到自己所关注的那个 Epoch 开头，然后开始使用 Pin 等工具记录读写，计算 DIFT 。</p>

<p>下图为本地 DIFT 的输出示例：</p>

<p><img src="http://ytliu.info/images/osdi2016/28-1.png" alt="l-DIFT-output" /></p>

<p>可以看出，整个程序被分成三个 Epochs ，分配到三台服务器上。方框为全局的 Inputs 和 Outputs 。中间的大圆圈为 local sources 和 local sinks 。小圆圈为以 log 形式记录的中间变量。整个图结构记录了所有的元素之间的关系。随后我们进入到 Aggregation 阶段。</p>

<p><strong>Aggregation：</strong>
我们先不考虑如何并行化，而是先来介绍一下这个阶段要做什么以及一些优化。</p>

<p><strong>要做什么：</strong>
这一部分要做的事情其实就是在全局计算 DIFT ，再说的简单一点，根据本地 DIFT 阶段生成的那个图结构，去遍历一下，如果从 Input A 开始，能够到达 Output B ，则输出一个二元组 &lt;Input A, Output B> ，表示 Input A 会影响到 Output B 。最简单的方法当然就是图上的深度优先搜索。</p>

<p><strong>Forward Pass 和 Backward Pass：</strong>
由于本地 DIFT 产生的数据量非常非常大。直接做搜索的效率比较低。因而 JetStream 先通过从所有的 Inputs 开始正向做一次活性分析，将从 Inputs 无法到达的节点全都去除，来较少搜索量。这个步骤叫做 Forward Pass 。同样的， JetStream 还会从 Outputs 开始，从后往前的做一次活性分析，去除掉那些无法到达任何 Output 的节点，同样可以减少搜索量。这个步骤叫做 Backward Pass 。对比下面三张图，可以看出做优化之前、做完 Forward Pass 之后、做完 Backward Pass 之后剩余的图结构。</p>

<p>图-优化前:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-2.png" alt="opt-0" /></p>

<p>图-Forward Pass 后:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-3.png" alt="opt-1" /></p>

<p>图-Backward Pass 后:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-4.png" alt="opt-2" /></p>

<p>这两个优化做完之后，所剩的图结构已经被大大的简化了。但，不管是前面的两个优化，还是后面要做的搜索，如果串行的去做，速度非常慢。如何在这里利用上集群的优势呢？</p>

<p><strong>Pipeline：</strong>
这个时候就要搬出（笔者认为的）整篇论文的精华部分了—— Pipeline 。</p>

<p>虽然 Pipeline 的概念很简单，但是能想出在这里这么用，感觉还是挺不容易的。由于各个 Epoch 的数据是在不同服务器上的，最简单想到的方法，是 Epoch 1 先做，然后把结果发给 Epoch 2 的服务器， Epoch 2 做完之后，把结构发给 Epoch 3 所在的服务器，以此类推。</p>

<p>通过使用 Pipeline 的方式，当在搜索 Epoch 1 的图结构的时候，每当遇到一个 local sink，可以把当前已有的结果直接发给 Epoch 2 。随后 Epoch 1 上的搜索继续进行，同时 Epoch 2 所在的服务器在收到发过来的结果之后，马上可以从这个 local source （ Epoch 1 的 local sink 即是 Epoch 2 中的 local source ）开始搜索。这样 Epoch 1 和 Epoch 2 是同时在进行搜索的。这就是 JetStream 里面的 Pipeline 。下面几张图更加形象的表示了这个过程。</p>

<p>图-Pipeline-0:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-5.png" alt="pipeline-0" /></p>

<p>图-Pipeline-1:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-6.png" alt="pipeline-1" /></p>

<p>图-Pipeline-2:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-7.png" alt="pipeline-2" /></p>

<p>图-Pipeline-3:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-8.png" alt="pipeline-3" /></p>

<p>图-Pipeline-4:</p>

<p><img src="http://ytliu.info/images/osdi2016/28-9.png" alt="pipeline-4" /></p>

<p>Pipeline 不仅仅是用在最后的搜索，在活性分析的优化中，同样需要使用 Pipeline 来进行加速。</p>

<p>总结一下，笔者认为这篇文章重点在于把 DIFT 抽象成了一个图结构，以及在 Aggregation 阶段的 pipeline 并行化。尤其后面的 pipeline ，对 DIFT 的性能提升非常大。在 Poster Session 与作者聊天时，作者提到其实很多时候， JetStream 中的瓶颈反而在于本地 DIFT 做的太慢了。</p>

<h4>&lt;&lt;&lt; Session 小结 >>></h4>

<p>总结一下整个 Session ，虽然名字是大杂烩，但是其实内容也确实是大杂烩。一篇分布式内存缓存，一篇文件系统并行化，一篇地理分布式分析优化，最后一篇并行化动态信息流跟踪。四项工作与其他 Session 的工作确实关联不大，但笔者并不认为这是因为这四项工作所做的事情不够重要或者不够热点，应该只是恰巧这次 OSDI 中类似的，且比较好的工作不够多吧。 :)</p>

<hr />

<h3>Session~[Fault Tolerance and Consensus]</h3>

<h4>>>> Just Say NO to Paxos Overhead: Replacing Consensus with Network Ordering &lt;&lt;&lt;</h4>

<p>这篇论文是华盛顿大学计算机系统实验室(Computer System Lab)的研究人员完成的，第一作者Jialin Li是四年级博士生，之前在NSDI&#8217;15发表Speculative Paxos并拿到Best Paper. 第三作者Naveen Kr. Sharma也是四年级博士生，之前在ASPLOS&#8217;16上发表FlexNIC。这篇文章正是Paxos和网络设计的结合，主要讨论了如何在数据中心保证网络通信顺序，并在此基础上提升Paxos的性能。</p>

<p>Paxos协议用来解决分布式环境下SMR(State Machine Replication)的一致性问题。但是由于其性能瓶颈，目前主要用在分布式配置维护，锁服务器(Chubby, ZooKeeper)等应用中。在Paxos的网络模型中，可能会出现的异常有：丢包，乱序和任意长的网络延时。根据这篇论文，之前的解决方案要么在软件层面解决所有异常，要么在硬件层面解决所有异常。作者提出的NOPaxos(Network-Ordered Paxos)的第一个贡献是<strong>将网络顺序和网络可靠性分离</strong>， 即网络硬件提供顺序保证，软件协议解决丢包和任意延迟的问题。NOPaxos中的网络模型叫做OUM(Ordered Unreliable Multicast)。在OUM网络中，有一个<em>sequencer</em>负责给每个链接(发送者+接收者)维护一个序列号。由于网络是有序的，接收者可以通过序列号来判断具体的丢包情况。</p>

<p>本文作者完成了三种OUM网络中<em>sequencer</em>的具体实现，如下图所示</p>

<p><img src="http://ytliu.info/images/osdi2016/29-1.jpg" alt="29-1" /></p>

<p>第一种实现使用P4语言直接对交换机进行编程，为数据包定义NOPaxos中所用的序列号。这是三种实现中性能最高的一种，但是作者说这样的交换机目前在市面上还买不到。第二种实现通过在网络拓扑的根节点安装一个Cavium Octeon网络处理器(Network Processor)来实现<em>sequencer</em>，该实现大约会造成8us的额外延时。最后一种是完全的软件实现，不过这也是性能最差的实现。</p>

<p>接下来是NOPaxos的软件协议部分。首先Client会将请求发送给所有Replica，由于网络有序，Replica收到请求顺序相同。那么当Client接收到大部分机器回复(包括Paxos leader)之后请求完成。当需要重新选举leader时，NOPaxos沿用了之前的VR(Viewstamped Replication)算法。</p>

<p>根据作者的Evaluation，NOPaxos的吞吐率是原本Paxos的4.7倍，延迟降低40%。同时，在丢包率升高时，NOPaxos的表现也比之前的Speculative Paxos要好。和没有Replica的系统相比，NOPaxos的吞吐率只有2%的降低，延迟提高约16us。</p>

<p><img src="http://ytliu.info/images/osdi2016/29-2.jpg" alt="29-2" /></p>

<p>根据Jialin自己讲，他希望可以通过提高Paxos的性能，使得分布式一致性协议可以用在更多的应用中。我们也期待以后有更多的使用新Paxos协议的数据中心应用出现。</p>

<h4>>>> XFT: Practical Fault Tolerance beyond Crashes &lt;&lt;&lt;</h4>

<p>这篇论文的一作Shengyun Liu是国防科技大学的本科，现在在EURECOM攻读博士学位。二作Paolo Viotti也是EURECOM的博士生。EURECOM是法国在信息和通信技术领域领先的工程师学校及研究中心。四作Vivien Quéma来自Grenoble理工学院，也是法国一所历史悠久的科技学院。三作Christian Cachin和五作Marko Vukolić来自IBM苏黎世研究院。这是一项完全来自欧洲的研究工作。</p>

<p>在分布式系统研究中，有两种经典的SMR(State Machine Replica)容错模型，一种是CFT(Crash Fault Tolerance)，另一种是BFT(Byzantine Fault Tolerance)。通俗地讲，CFT认为机器可能宕机，网络可能异常，但是所有信息真实可信。BFT在CFT的基础上，认为出错的机器是可能说谎的。通常认为，为了避免f台机器出错造成整个分布式系统出错，CFT模型容错需要至少2f+1台机器，BFT模型容错需要至少3f+1台机器。具体的证明是比较古老的事情，可以追溯到图灵奖得主Leslie Lamport活跃的时代。</p>

<p>这篇论文基于的观察是：在现实中的分布式系统中，机器因为出错而宕机或者撒谎都是可能的，但是随心所欲地控制网络发包顺序是很困难，几乎不可能的。由于完全操控网络是BFT容错需要大量冗余的关键，作者弱化了BFT，并将新的容错模型称为XFT(Cross Fault Tolerance)。作者进而提出了一种名为XPaxos的算法，使用2f+1台机器实现这种模型下的容错。作者认为通过XFT和XPaxos，可以在让目前使用2f+1容错的分布式系统在不增加机器的情况下提升到更高的容错级别。作者还证明了，当大部分(f+1台)机器是正确的并且可以自由良好通信时，XPaxos可以容忍另外少部分机器之间发生的BFT错误。</p>

<p>作者在Apache ZooKeeper中实现了XPaxos，并与之前基于Paxos的实现进行了性能比较。Evaluation中，作者使用6个跨地域的Amazon EC2来部署XPaxos以及对比系统(Zyzzyva, PBFT和WAN-optimized Paxos)。结果表明，XPaxos在延迟和吞吐率上和基于WAN优化过的Paxos不相上下，但是提供了更高的容错能力(在consistency和availability两个维度)。同时，XPaxos比Zyzzyva, PBFT性能要高很多，因为后二者是使用3f+1的BFT容错算法，网络开销很大。</p>

<h4>>>> Realizing the Fault-Tolerance Promise of Cloud Storage Using Locks with Intent &lt;&lt;&lt;</h4>

<p>这是一篇来自工业界的文章，作者来自微软研究院。本文专注于解决一个很现实的问题：云提供商(Microsoft, Amazon)都提供可靠的数据存储服务，但是计算服务还是可能因为机器宕机重启而导致本地数据和云服务器中数据不一致。本文利用了现有的可靠存储服务，为开发者提供了一种新的编程原语(intent和locks with intent)来简化软件容错的实现，减轻开发者的负担。</p>

<p>教科书里解决宕机的方式是Replica和Paxos协议，但是由于云存储服务已经提供了这样的可靠性，所以本文作者认为应该直接利用云存储服务为开发者提供编程接口。他们开发了Olive系统，为运行在云服务器上并使用云存储的程序提供Exactly-Once执行保证，以及易用的并发控制。基于Olive，本文作者开发了很多真实使用的软件(Snapshot Service, ACID Transactions等)，发现所需的代码量比不使用Olive降低了30%到80%。开发者程序、Olive和云存储服务的关系如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/31-1.jpg" alt="31-1" /></p>

<p>接下来我们介绍Olive中的具体技术。Intent指的是一段需要保护的代码，这段代码包含云端存储操作以及本地计算操作。概括的讲，Olive会通过云存储记录一段intent中每一步是否执行，从而保证Atomic和Exactly-Once。当一条修改记录发送到云存储，云存储系统会原子地进行修改并在同一个Partition上记录日志，作者称这样的日志为DAAL(Distributed Atomic Affinity Logging)。发生宕机时，Olive通过DAAL判断一段intent从哪里开始重新执行，进而保证每段intent执行的完整性。由于一段intent可能并行地由多个线程执行，Olive提供了并发控制机制，即拿锁和放锁通过云存储实现可靠性，当发生宕机重启时，云存储可以保证锁的状态一致性。</p>

<p>作者用约2000行C#代码实现了Olive，并实现了和Azure Table Store和Amazon DynamoDB的对接。作者称Olive还可以很容易的利用Cassandra, MongoDB等作为后端云存储。在Evaluation中，作者证实了Olive可以简化开发者代码，并且拥有较小的额外开销。如图所示，通常情况下Create和Read操作不会造成开销，Update操作开销在原来的两倍左右。由于Copy-On-Write，在snapshot之后第一次操作开销比较大。</p>

<p><img src="http://ytliu.info/images/osdi2016/31-2.jpg" alt="31-2" /></p>

<p>总结一下，这篇文章提出了Olive，利用云存储系统的可靠性减小了开发容错云端程序的工作量，是一篇来自工业界的非常扎实实用的文章。</p>

<h4>>>> Consolidating Concurrency Control and Consensus for Commits under Conflicts &lt;&lt;&lt;</h4>

<p>这篇文章的一作Shuai Mu是清华大学的Ph.D.，现在在纽约大学读博士后。二作Lamont Nelson是纽约大学在读博士。这两位都是四作Jinyang Li老师的学生。三作Wyatt Lloyd是南加州大学的助理教授，他同时是本次OSDI另一篇文章SNOW Theorem的作者。几位作者合作的这篇论文实现了一个新的分布式事务系统Janus，Janus和之前系统的主要区别可以用下图直观表示：</p>

<p><img src="http://ytliu.info/images/osdi2016/32-1.jpg" alt="32-1" /></p>

<p>Janus的目标是在实现Consensus和Concurrency Control的同时，尽量减小多种情况下(顺利提交和发生冲突)的跨地域通信。主要切入点是作者发现Consensus协议和Concurrency Control协议有很多地方类似，所以其实可以合并成为一个协议，从而达到上述目的。</p>

<p>首先，Janus考虑的事务由一系列提前内置的过程(Stored Procedures)表示。为了减少不同事物之间的冲突，在Consens和Concurrency Control协议中都会为这些内置过程制定一致地顺序，导致之前的分布式事务系统都会两次决定内置过程的顺序。Janus由于使用合并的协议，只需要一次决定。合并后的协议如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/32-2.jpg" alt="32-1" /></p>

<p>简单来说，Janus引入了Pre-accept状态。当发生冲突时，Janus会决定事务之间的顺序，发回给Client，由Client将新的请求以及顺序信息重新发送给每个Server进行执行，这样就可以避免Abort，实现事务必然提交。综上所述，Janus在发生冲突时需要2次跨地域通信，在没有冲突时只需要一次。这篇论文还讨论了很多细节情况，包括 Quorum大小，出现宕机时的各种情况等。同时，作者也讨论了如何将Janus扩展到更一般的事务上，即事务的读写集合可能不是事先知道的。Janus的开源代码可以在GitHub上下载。作者在Evaluation中验证，由于没有Abort，Janus在Client数量扩展性和单个事务的延迟上优于Tapir和2PL。</p>

<p>总结一下，Janus合并了Consensus协议和Concurrency Control协议，并且利用顺序决策避免了Abort，使得分布式事务系统的性能得到了提升。</p>

<hr />

<h3>Session~[Security]</h3>

<h4>>>> Ryoan: A Distributed Sandbox for Untrusted Computation on Secret Data &lt;&lt;&lt;</h4>

<p>这篇论文是由UT Austin的<a href="https://www.cs.utexas.edu/~witchel/">Emmett Witchel</a>团队完成的，今年他们在OSDI上还发表了另一篇关于huge page的工作。本文的第一作者<a href="https://www.cs.utexas.edu/~thunt/">Tyler Hunt</a>是一名第四年的博士生。</p>

<p>这篇paper是今年的三篇best paper之一。论文利用了现在正火的SGX，设计实现了一个<code>distributed sandbox</code>，即分布式沙盒。这个场景主要发生在目前的数据处理服务中，例如税费计算、个人健康状况分析等。这种场景下，用户需要将隐私信息交由服务提供商进行处理。与此同时，服务提供商也可能依赖其他机构提供的服务，例如23andMe(个人健康状况分析服务提供商)可能依靠亚马逊提供的机器学习服务。在这种场景下，用户担心某一服务提供商泄露自己的隐私，同时多个服务提供商之间也可能互相勾结，泄露用户的隐私数据。</p>

<p>与之前Haven这种基于SGX的工作不同，作者提出的Ryoan不仅不信任底层的系统软件，同时也不能信任服务提供商提供的服务逻辑代码。具体介绍Ryoan的系统设计之前，我们先来看一下她的威胁模型。首先，数据处理过程中可能存在着<strong>多个互相勾结的不可信机构</strong>。同时，系统中的用户<strong>不信任任何服务提供商</strong>能够对其隐私数据进行保密。值得注意的是，如果一个服务提供商把数据交由另一个机构处理，那么该提供商将变为另一机构的用户，其不能相信自己的隐私会被另一机构保护。也就是说整个系统中的所有服务提供商都可能<strong>互相勾结</strong>，也都可能互相<strong>窃取隐私</strong>。</p>

<p>与此同时，服务提供商可能将自己的代码运行在不可信的平台上。其可能与代码运行的平台进行勾结，将用户隐私泄露出去，例如通过系统调用的顺序或者参数泄露用户隐私。Ryoan同样能够抵御攻击者通过<code>covert channel</code>传递用户隐私。</p>

<p>接下来我们介绍这个工作的具体设计，首先Ryoan作为一个沙盒运行在SGX提供的enclave中。服务提供商则会提供自己的代码，也被称为module。这些module对整个系统而言都是不可信的，将运行在Ryoan之中，如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/33-1.png" alt="33-1" /></p>

<p>系统初始化过程中，能够通过SGX提供的remote attestation，验证每个服务提供商所使用的enclave中的确运行了Ryoan。Ryoan将能够加载并验证不同服务商提供的modue。为了限制module泄露用户（也可能是使用该module服务的提供商）的隐私，Ryoan提供了两种运行模式。当一个module未接受来自其他机构（包括用户）的数据时，其是<em>Non-confining</em>的，能够正常使用I/O操作等。但是当一个module接收了其他module的输出或者用户的输入之后，其将会进入confining状态。此时，Ryoan将限制其行为，例如对I/O操作进行加密,提供in-memory virtual filesystem等。Ryoan使用传统的label system来进行数据的追踪，从而识别一个module是否接收到其他module或者用户的隐私数据。同时Ryoan在一个module处理完请求之后，会将其进行销毁，防止其记录用户隐私并泄露给其他用户。</p>

<p>通过对数据进行追踪，并进行权限控制，Ryoan已经能够防止module直接泄露用户隐私。但是不同module之间，或者module与OS之间仍然可能通过covert channel间接地传递用户隐私数据。针对这一问题，Ryoan提出了抵御software covert channel（利用系统调用、运行时间）的方法，而对于hardware covert channel的防御，作者认为是运行平台的责任。Ryoan限制module不能直接调用系统调用，并且标准化了I/O读写操作的长度。同时对于module的运行时间，Ryoan也进行了限制，每次一个module必须运行固定的时间长度。</p>

<p>总的来说，这篇文章通过将SGX与sandbox进行结合，解决了云端数据服务环境下，服务逻辑，运行平台均不可信的问题。同时作者也考虑当下单个云端服务往往需要依赖多个服务提供商这一特点，解决了不同服务提供商之间勾结从而泄露用户隐私的问题。其实作者具体使用的sandbox、label system等技术都是现有的，但是作者将它们与SGX进行结合，应用到了一个新的场景之中，同时整个系统的设计与实现也非常完整，从而成为了一个非常好的工作。</p>

<h4>>>> Unobservable Communication over Fully Untrusted Infrastructure &lt;&lt;&lt;</h4>

<p>这篇工作是由UT Austin，纽约大学以及微软合作的，一作<a href="https://www.cs.utexas.edu/~sebs/">Sebastian Gomez Ange</a>是UT Austin 高级系统研究实验室的一名博士，目前在纽约大学的system group进行学术交流。在今年的USENIX Security上，他还发表了一篇关于利用虚拟化防止恶意外设攻击的工作。</p>

<p>这篇Paper旨在解决在不可信的网络环境下的通信问题，希望能够防止网络中的任意机构对通信的metadata (通信双方的身份，时间等)进行窃取。现有的一些解决方案往往需要相信网络中的一个或者多个对象，例如代理服务器，网络服务提供商等。而本文则提出了一种不信任网络中任一对象的可信通信方案。</p>

<p>在介绍详细的系统实现之前，我们仍然首先介绍该系统的威胁模型。该系统需要能够在公用网络上保护通讯的所有内容以及metadata不被窃取。系统保护的metadata包括：1）通信开始到结束的时间；2）通讯次数；3）通讯双方的身份等等。这些metadata除了通讯双方，不能够被网络中的任一对象获得。系统假设所使用的加密算法足够安全，同时认为通信双方事先已经知道了对方的公钥（但是交换公钥的过程中也会泄露metadata，下一篇paper将会解决这个问题）。</p>

<p>为了解决上述问题，作者提出了一个称为Peng的系统。该系统采用key-value store的工作模型，发送者A首先将一个（label，message）的数据条目存储到Peng cluster中，之后接收者B再从中获取该对应的条目，解密后获得用户A发送的信息，如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/34-1.jpg" alt="34-1" /></p>

<p>Peng首先使用一个经过加密的label，在每一个通讯周期r，信息的发送者A和接受者B都能够根据双方事先共享(通过本系统外的方法共享）的secret生成label-s以及label-r。A会将（label-s，message）发送至Peng cluster，B之后会通过label-r获取该加密的message，从而完成通讯。</p>

<p>可以发现，发送消息只需要将key-value对发送给服务器即可，但是接收消息时却不能简单的直接获取label-r对应的条目，否则服务器将能够获得通讯的metadata。最基础的解决方法是B一次性获取服务器所有条目，从中挑选label-r对应的信息。但是这样性能肯定很差，为此作者采用了 <strong>Private information retrieval (PIR)</strong>。通过该方法，用户向服务器发送一个query，服务器将会返回一个answer交给用户，用户通过特殊的decode方法从而获得真实的请求结果。这一方式使得能够在不暴露label-r的情况下，高效的从Peng cluster中获得想要的key-value对。同时为了混淆网络中的通讯，空闲的用户也会在每个周期也会发起信息发送／获取请求。</p>

<p>总的来说，本文通过巧妙的系统设计，实现了一个能够完全不泄露metadata的通讯方法。该方法有效的将加密通讯中除通讯双方之外的任一实体排除在了系统的可信基之外。在64个client的情况下，每分钟大约能够传递数万条消息。但是Peng在通讯之前要求双方必须拥有一个共享的secret或者拥有对方的公钥，然而却没有提供任何有效安全的公钥交换方案。</p>

<h4>>>> Alpenhorn: Bootstrapping Secure Communication without Leaking Metadata &lt;&lt;&lt;</h4>

<p>这篇论文是由MIT的POS实验室完成的，第一作者<a href="https://davidlazar.org">David Lazar</a>是POS的一名博士生，导师是<a href="http://people.csail.mit.edu/nickolai/">Nickolai Zeldovich</a>。一作在去年的SOSP发表了一篇关于安全通讯的系统Vuvuzela，工作与刚刚介绍的Peng类似。</p>

<p>这次作者想要解决的是安全通讯建立时遇到的metadata泄露问题。正如刚刚那篇Peng提到的，它们要求通讯双方事先知道对方的公钥或者共享一个secret，实际上现有的类似系统包括Vuvuzela都有这样的需求。然而在获取一个用户的公钥的过程中，往往会暴露一些metadata。例如公钥管理服务器将能够得知有人需要向公钥的拥有者发送消息。为此这篇文章就提出了一种能够安全交换secret的方法，利用该机制用户之间能够在不泄露metadata的情况下交换一个共享密钥，从而进一步使用现有安全通讯系统。</p>

<p>首先还是介绍该系统的威胁模型。系统中使用了<strong>mixnet服务器</strong>以及<strong>PKG( private key
generators)服务器</strong>。系统假设至少一个mixnet服务器以及一个PKG服务器是正常工作，没有被攻击者compromise的，其他任何网络中的对象都可能是恶意的。与此同时，本工作还将能够保证<code>forward secrecy</code>,即使某个server或者client被攻破，攻击者也不能获取之前通讯的内容。同样本工作假设系统所使用的加密算法本身都是完备的。</p>

<p>为了能够安全的在通信双方之间共享一个secret，作者提出了一个名为Alpenhorn的系统。该系统为每个用户维护了一个地址本，每个地址本中的条目对应一个朋友，条目中将包含与朋友共享的一个secret。两个用户能够通过一个更新算法，实时地更新各自地址本中记录的共享secret。</p>

<p><img src="http://ytliu.info/images/osdi2016/35-1.jpg" alt="35-1" /></p>

<p>Alpenhorn提供用户一个添加好友的接口，从而在自己的地址本中新建条目。上图是Alice向Bob发送添加好友请求的具体流程。首先所有的client在每个周期都将发送给mixnet服务器一个固定长度的请求，即使该client不想做任何操作，其仍将发送一个假的请求。此时，Alice就会发出一个添加Bob为好友的请求。Alice会使用Bob的公钥对请求内容进行加密，这里Alpenhorn采用<strong>identity based encryption （IBE）</strong>，该技术使得能够直接使用对方的账号名作为公钥，而不用向服务器发起公钥请求。Alpenhorn假设用户使用自己的邮箱作为用户名，所以此处Alice直接使用Bob的邮箱加密请求即可（系统假设用户知道好友的邮箱）。</p>

<p>此后mixnet服务器将会打乱所有用户发出的请求，并将请求分不到不同的mailbox中。每个mailbox中会存在大量不同用户的请求。此时只要有一个mixnet服务器正常工作，那么所有用户的请求就能够被安全的混淆。之后所有用户都将从其对应的mailbox中获取请求信息，当然这些信息中很多是空闲用户发送的混淆信息。</p>

<p>当Bob从他的mailbox中得到请求时，其将会使用自己的私钥对请求进行解密。由于系统使用了IBE，Bob并不会储存自己的私钥，其需要从PKG （private key generator）服务器中获得私钥，才能对信息进行解密。解密后Bob将获得来自Alice的好友添加请求。实际上该请求包含两部分，Alice的邮箱以及一个secret。由于Bob实现知道Alice注册了这个邮箱，那么其将能够选择添加Alice为好友，将这个secret添加到自己的地址簿里。并且向Alice发送一个ack，当然这个ack会经过同样的流程发送给Alice。当Alice收到该确认请求后，其将能够确认与Bob建立好友关系，并且两者的地址簿里已经存在了一个共享的secret，该secret将不断的保持同步变化。具体来说，系统采用Diffie-Hellman密钥交换协议，帮助Alice和Bob通过以上通信过程生成共享的secret。一旦共享了该secret，Alice和Bob将能够进行安全通讯，无论是采用与以上协议一样的通讯方法，还是其他的安全通讯系统。</p>

<p>需要额外提到的是PKG的anytrust模型。对于一个IBE系统，将会有一个可信的PKG服务器，管理所有用户的私钥。该服务器拥有一个单独的公钥，用户可以通过该公钥以及目标对象的账号名对内容进行加密。之后，目标对象能够向PKG请求自己的私钥，并且使用该私钥对内容进行解密。为了防止某个恶意PKG服务器窃取用户metadata，Aplenhorn采用多个PKG服务器，加密时利用每个服务器的公钥与目标的邮箱进行加密。解密时目标对象会从所有PKG服务器索取自己的私钥，并依次用所有私钥对内容进行解密。因此只要有一个PKG服务器正常工作，那么通讯的安全性就能得到保障。</p>

<p>这篇文章通过mixnet服务器以及IBE技术，结合提出的anytrust模型，设计并实现了一个能够在不泄露metadata的情况下发起安全通讯的系统，有效解决了现有安全通信系统需要事先共享secret的这一问题。Alpenhorn使得安全通讯系统变得更加实用，使用者仅需知道对方的邮箱地址即可进行通讯，而无需事先知道对方的公钥。</p>

<h4>>>> Big Data Analytics over Encrypted Datasets with Seabed &lt;&lt;&lt;</h4>

<p>这个session的最后一篇文章是由宾夕法尼亚大学，微软研究院以及UCLA共同合作完成的。一作<a href="https://www.cis.upenn.edu/~apap/">Antonis Papadimitriou</a>是个即将毕业的博士，今年已经第五年了，导师是<a href="https://www.cis.upenn.edu/~ahae/">Andreas Haeberlen</a>。</p>

<p>这篇文章针对的是大数据环境下加密计算的性能问题。为了保证存储在云端数据的安全，需要对云端数据进行加密。但与此同时，却又依赖云端对这些数据进行处理。为了能够让云端处理加密后的数据，现有的系统往往采用确定性加密算法与同态加密算法。云端对加密后的数据进行计算并得到一个返回值，客户端能够利用一个密钥解密该返回值并得到真正的运算结果。但是传统的这类系统一方面在大数据环境下性能较差，另一方面容易被进行频率攻击。本文则提出了一种新的加密方法，使得系统拥有更高的性能，同时也能防御频率攻击。</p>

<p>在具体设计之前首先介绍一下频率攻击。由于使用确定性加密技术，同样的明文数据会被加密成同样的密文。这也就意味着攻击者能够通过频率侧面获得加密内容。例如在事先知道男女比例的情况下，攻击者能够通过性别栏目不同密文的出现频率，从而得知密文对应的性别。</p>

<p>与现有的系统采用非对称加密不同，作者认为数据的拥有者和结果的查询者往往是同一机构，因此作者设计的系统Seabed使用了一种新的更为快速的对称加密方法<strong>ASHE(symmetric homomorphic encryption scheme)</strong>。具体来说，对于数据库中条目中的一个值m，会计算出一个附加量d，最终存储的密文将是m+d，如下图所示。</p>

<p><img src="http://ytliu.info/images/osdi2016/36-1.png" alt="36-1" /></p>

<p>首先对于每个加密密钥k，都能够有一个哈希函数Fk，其能够将一个非负整数变成一个正整数。之后对于位于第i行的值m，其密文则是{m-Fk(i)+Fk(i-1), i}。假设需要进行求和计算，那么所有密文的和则是m1+  &#8230;+mn - Fk(n)+ Fk(0)，以及{1,&#8230;,n}。那么只要去除最终的-Fk(n)+Fk(0)就能够得到正确的值，这也是ASHE的主要思想。</p>

<p><img src="http://ytliu.info/images/osdi2016/36-2.png" alt="36-2" /></p>

<p>而为了防止频率攻击，论文中提出了一种<strong>SPLASHE (Splayed ASHE)</strong>技术，简而言之就是将取值可能性少的列分为多个新的列。如上图，将性别这个取值为男或者女的列划分为两个列 （性别男以及性别女），如果是男性那么性别男那一列的取值将为1。与此同时，ASHE保证每一列的不同行内容看起来是一个随机数，从而使得攻击者完全无法通过频率对密文内容进行猜测。</p>

<p>测试部分作者比较了使用ASHE技术的Seabed与传统采用非对称同态加密技术的Pailier，无论是在资源（硬盘与内存）使用量，还是响应时间上，Seabed都拥有非常大的提升。</p>

<p>总的来说，作者通过一种新的、巧妙的加密方法，有效的提升了在加密数据库上进行大数据分析的性能。但是由于采用对称加密，也就要求数据拥有者与分析结果的需求者必须是同一机构，或者互相信任。并且由于ASHE算法本身设计简单，因此其难以支持更多复杂的操作，例如乘除等。但是作者在提问环节也说到，ASHE支持的简单操作已经能够满足绝大部分数据分析的需求。</p>

<hr />

<h3>Session~[Troubleshooting]</h3>

<h4>>>> Non-Intrusive Performance Profiling for Entire Software Stacks Based on the Flow Reconstruction Principle &lt;&lt;&lt;</h4>

<p>这篇论文的一作<a href="http://www.xuzhao.net/">Xu Zhao</a>和他的导师<a href="http://www.eecg.toronto.edu/~yuan/Home.html">Ding Yuan</a>都是属于憋大招的高手，2014年和2016年都有两篇OSDI的大作，令人膜拜！其中，Ding Yuan是<a href="https://cseweb.ucsd.edu/~yyzhou/">YY Zhou</a>的得意门生之一，现在在多伦多大学当助理教授。</p>

<p>该工作特别有他们工作的印记，就是属于那种一看就能想到Ding Yuan或者YY Zhou的工作。一句话概括就是：利用Log来帮助程序员debug分布式系统。该方法建立在一个原则上：Flow Reconstruction Principle。
该原则的意思是说：程序员在写代码的过程中，会在一些关键的事件发生时，插入一个log的打印，该log会记录所有相关的objects对应的ID，用于在debug的时候重建执行流。下面是一个满足该原则的log：</p>

<p><img src="http://ytliu.info/images/osdi2016/37-1.png" alt="37-1" /></p>

<p>也就是说，每一条log都能清楚地记录关键事件发生时所涉及到的objects的唯一的ID。之后，该方法会通过分析这些log，来生成一张整个执行流过程中所有objects之间的对应关系，并用时间线的方式描述出来，如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/37-2.png" alt="37-2" /></p>

<p>该图中，OBJECT那一列记录了所有涉及到的objects的ID，TIMELINE那一列表示如果在某个时间点发生的事件的log中记录了该object的ID，则在相应的地方标记一个点。因此它表示object在时间线维度的存在性。通过这张图，我们可以比较清楚地看到，<code>container..5..611</code>发生在<code>container..4..071</code>之后，因此在debug的过程中很容易得到它们之间的依赖关系，从而发现其实是在container分配过程中的问题。</p>

<p>当然，其实该方法是存在很大的局限性的，比如它非常依赖程序员记录log的习惯，同时，它只能帮助程序员找到那些特定类型的bug，而不是所有的bug。不过笔者觉得这篇论文给人映象最深的一点是它在一开始描述了一个motivating example和user study，并且在之后将其贯穿全文，让读者看的一目了然，整篇文章写的非常清晰，而且确实是在很大程度上解决了一个分布式系统debug的问题。</p>

<h4>>>> Early Detection of Configuration Errors to Reduce Failure Damage &lt;&lt;&lt;</h4>

<p><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-xu.pdf">这篇论文</a>出自UCSD Yuanyuan Zhou组的博士生Tianyin Xu，Xinxin Jin，最近入职Johns Hopkins University的Peng Huang，以及合作者University of Chicago的Shan Lu，UCSD的Long Jin和NetApp的Shankar Pasupathy。这篇论文是今年三篇Best Paper之一。</p>

<p>Tianyin在本篇论文中的工作尝试解决了一个简单而重要的问题。许多系统在部署运行一段时间后崩溃，原因可能很简单：配置参数有一些问题，一经使用便会崩溃。但是，一部分配置参数并不会在系统开始运行时就被使用，因此问题会在很晚的时候才会浮现出来。这一类问题被作者称为latent configuration (LC) errors。作者研究发现，像HDFS，YARN，HBase，Apache，MySQL和Squid这些系统，14%到93%的配置参数在系统实现中缺少对应的检查操作，而仅在即将使用之时才做检查。其中12%-38%的配置参数在系统启动阶段完全没有被使用，因此也就躲过了启动阶段崩溃的命运。</p>

<p>本文设计实现了PCHECK这一检查工具。思路很简单：既然许多配置参数很晚才会被用到，那就尽量让他们早点被用到。所谓“使用”，其实是系统的实现中有一些操作指令（configuration-consuming instructions）会读取相应的变量值，然后尝试以文件路径或ip地址等方式进行利用，而在利用这些值的时候得到错误返回值。PCHECK通过静态分析找到这些指令，并将提取这些指令生成(encapsulate)一个独立的函数，用来作为专门检查配置变量的测试函数。而后通过编译阶段的插装，在程序初始化阶段插入该函数，实现了“提早检查”。插入的指令如下图所示：</p>

<p><img src="http://ytliu.info/images/osdi2016/38-1.png" alt="38-1" /></p>

<p>提早执行这些指令，有可能会给系统带来不必要的side effect。例如这些指令可能读写文件，或使用系统调用。PCHECK的解决方案是模拟(model)这些指令的执行结果，而不是真正去执行它们。如上图所示，插入的指令并不会实际调用freopen，而是模拟freopen函数的执行效果，并检查freopen的参数。对于全局变量的修改，PCHECK会把对应的全局变量转换成局部变量，以防止误修改。</p>

<p>PCHECK在实现中考虑了源程序的数据流和控制流，以求减少误检率。对于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (p != NULL) { use p; }</span></code></pre></td></tr></table></div></figure>


<p>这样的操作，PCHECK也会将条件判断指令加入到生成的检查函数中，以求和源程序执行逻辑保持一致。PCHECK在整个系统实现中实现了跨函数的污点跟踪技术，以完整恢复原系统的数据流。</p>

<p>PCHECK的一个局限性是应对的配置错误情形较为简单。如果触发该配置错误，需要读取系统经长时间运行后才产生的结果，这种情形PCHECK是无能为力的，因为提早执行的函数没有办法得到这种值。</p>

<p>本文在测试阶段对58个包含此类型错误的配置文件进行检测，有七成以上的错误被成功发现，相比于已有的配置检测工具多发现了30%左右的错误。</p>

<h4>>>> Kraken: Leveraging Live Traffic Tests to Identify and Resolve Resource Utilization Bottlenecks in Large Scale Web Services &lt;&lt;&lt;</h4>

<p>本文作者来自Facebook。Fecebook、谷歌和微软这一类的顶级技术公司，经常会在SOSP/OSDI发表论文，与学术界分享公司内部的技术探索和实践，BigTable, MapReduce, GFS就是其中的典范。本文的一作Kaushik Veeraraghavan毕业于密歇根大学，为Peter Chen的学生。</p>

<p>这篇文章针对的问题非常有意思，笔者相信也是许多公司所关注的：如何测试出整个系统中的瓶颈。Facebook的问题会更进一步，如何实时地测出分布在多数据中心中的成百上千的系统中的瓶颈。以往针对这个问题有2种方法，第一种是通过建模的方式，第二种是使用构建的数据进行压力测试。作者认为这两种方式都不适用。首先，因为Facebook内部的workload在实时发生变化，同时，每个系统本身也在不断被更新，所以很难用建模的方式去静态评估。第二，使用构建的数据进行压力测试虽然在某些情况下有些效果，但是这些数据很难反应真实的情况，不能发现所有的系统问题。</p>

<p>Facebook的工程师们发现，实时的用户访问流量是最具代表性的，也是最能帮助发现系统问题的。读者也许会感到疑惑，实时流量确实最具代表性，但是如果在处理实时请求的时候系统发生重大问题，用户将因此产生困扰。为了避免这种情况，作者们设计了安全指标，不断地实时监测系统，一旦发现系统的某些安全指标出现可疑的问题，就立即将用户流量导向至其他数据中心。基于上述思想，作者们设计了Kraken，一个2013年上线、使用实时用户访问流量进行压力测试的系统。</p>

<p><img src="http://ytliu.info/images/osdi2016/39-1.png" alt="39-1" /></p>

<p>上图是Kraken的架构图。首先，Faceboook在整个系统中的不同部分（Edge POP、Web LoadBalancer、Service Balancer）进行流量分流，分流基于的权重是可以动态改变的。因此Kraken可以在测试中改变这些权重，从而对流量进行控制。其次，为了保证整个系统不发生宕机的危险情况，Kraken会持续收集安全指标，并将它们保存在数据库中。每60秒运行一次的Traffic Shifter在下次导流之前，会查看这些安全指标，一旦某些指标出现问题，就会停止测试，从而保证系统安全。</p>

<p>最后，笔者想介绍一下Facebook应对紧急情况的策略。</p>

<ol>
<li>Request spike：在重要的节日，或发生重大事件时，Facebook会在短时间内收到巨大的请求。比如在超级碗时，Facebook在30秒内收到比以往多100%的请求。在这种情况下，Facebook会停掉所有Kraken的测试并把请求导向所有的数据中心，以保证整个系统的正常运行。</li>
<li>Major faults in system operation：有时候，某数据中心的集群会因为一些问题停止工作。这种情况下，Kraken可以通过安全指标的异常变化发现这些问题，并将流量导向其他正常运行的集群。</li>
<li>External faults such as a network partition and power loss：这种情况下，整个数据中心的服务都是不可用的，Kraken依然可以通过安全指标的异常变化发现这个问题，并将流量导向其他正常运行的数据中心。</li>
</ol>


<p>在听报告时，笔者想到阿里巴巴在这方面的技术积累一定不输于Facebook。每年双十一零点过后半小时内产生的爆炸性海量流量足以令任何公司胆寒，而阿里的技术团队却一次次成功地守住了每一年的双十一。为了应对双十一，阿里巴巴在2013年推出了全链路压力测试（与Kraken同岁），主动创造海量用户流量对全链路的系统进行测试。笔者十分期待阿里巴巴也能将自己的傲人技术成果与世人共享。</p>

<hr />

<h3>Session~[Operating System II]</h3>

<h4>>>> CertiKOS: An Extensible Architecture for Building Certified Concurrent OS Kernels &lt;&lt;&lt;</h4>

<p><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-gu.pdf">这篇论文</a>来自Yale University的博士生Ronghui Gu，其导师Zhong Shao，以及Yale的其他合作者Hao Chen，Xiongnan (Newman) Wu，Jieung Kim，Vilhelm Sjoberg和David Costanzo。</p>

<p>本文设计实现了一个简易的支持并发操作的操作系统内核mC2，并验证了其实现的正确性。相比于以前的工作（如seL4 SOSP’09和FSCQ SOSP&#8217;15），本文所介绍的验证方法可以允许被验证的系统实现存在并发操作，mC2读写共享内存的操作的正确性可以被保证。</p>

<p>与验证单一执行流的正确性不同，并发操作中的每一执行流的正确执行受其他执行流的执行情况影响。每一线程都有可能修改全局共享内存的内容，因此线程内部访问共享内存的结果，不能简单通过分析证明本线程的操作得到；而分析众多线程的交互，复杂程度较高。如果对于每次共享内存访问都借助于全局唯一的锁得到保护，势必影响性能，也无助于充分利用多核系统资源。</p>

<p><img src="http://ytliu.info/images/osdi2016/40-1.png" alt="40-1" /></p>

<p>上面的图片展示了并发程序执行模型。CPU0和CPU1是两个独立的执行流，各自有原子操作（绿色矩形）、私有内存访问（黄色矩形）和共享内存访问(蓝色矩形）。作者提出了hardware scheduler概念（粉色实线），模拟不同执行流之间不同的调度及交互顺序。一个hardware scheduler代表了调度顺序的一种情况。每一个执行流的每一指令执行结束，都会向hardware scheduler获取调度信息。粉色实线上黑框白字标示最左侧两个依次代表由CPU0切换至CPU0、由CPU0切换至CPU1。</p>

<p>在上图的模型中，各执行流执行的正确性，取决于hardware scheduler的具体操作。完成证明的基本操作就是证明对于任一hardware scheduler，CPU0和CPU1都能正确地完成各自操作。完成两个执行流正确性证明之后，需要对执行流数量进行归纳扩展，归纳至任意执行流数量，从而证明对于任意情况，各执行流能够实现正确执行。</p>

<p><img src="http://ytliu.info/images/osdi2016/40-2.png" alt="40-2" /></p>

<p>即使是一个简易的操作系统内核，也需要实现较多数量的功能模块。如上图所示，mC2具备了装载器、虚拟内存管理、线程调度等基本的操作系统功能。这些功能实现中存在许多并发操作。为了简化mC2的验证复杂度，验证过程分为30多个层次完成。最低层是硬件指令集的抽象模型，其上的层次借助于指令集模型完成证明，进而证明排队自旋锁(Ticket Lock)和MCS锁等并发控制操作的正确性。对于使用这些并发控制操作的上层实现，例如页表管理，可以借助底层证明过的锁实现的语义完成正确性证明。因此，为了证明页表管理中的并发操作正确性，不必要从指令集部分开始推理，开发者可以借助大量已证明的基本操作语义来完成。</p>

<h4>>>> EbbRT: A Framework for Building Per-Application Library Operating Systems &lt;&lt;&lt;</h4>

<p>本文作者来自波士顿大学。作者认为，一般操作系统为了保证通用性，不得不牺牲性能。另一方面，系统界有一句名言：没有什么性能问题不是去掉一层抽象不能解决的。2014年OSDI最佳论文之一的Arrakis（Simon Peter的工作）就是将操作系统从data path上抽掉，由应用直接控制硬件，从而提升应用的性能。可是，这种让应用直接控制硬件的系统虽然具备较高的性能，但是会带来很多额外开发成本。</p>

<p>作者提出一种名为EbbRT的系统，既能允许应用直接控制硬件，又能获得通用操作系统所提供的服务，从而减少开发成本。以下为EbbRT的架构图，系统分成两个部分，VM0内运行通用商用操作系统，VM1和VM2内运行native LibOS。VM1和VM2内的LibOS设置了一个唯一的地址空间，提供必需的系统功能（比如内存分配、网络等）允许应用直接与硬件交互，如果需要使用通用操作系统的功能，EbbRT可以通过Offloading的方法将请求交给VM0内的通用操作系统完成。</p>

<p><img src="http://ytliu.info/images/osdi2016/41-1.png" alt="41-1" /></p>

<p>当然，需要补充的一点是，虽然架构图中使用了虚拟机的抽象，但是这并不意味着EbbRT的每一个实例都必须跑在虚拟机内。</p>

<h4>>>> SCONE: Secure Linux Containers with Intel SGX &lt;&lt;&lt;</h4>

<p>这篇论文的作者来自德累斯顿工业大学和帝国理工学院，其中Peter Pietzuch是2016年EuroySys的General co-chair。笔者原以为SGX会在今年OSDI上大放异彩，结果会议一共只收录了2篇SGX相关的文章，其中一篇获得了最佳论文奖，另一篇正是本文。</p>

<p>首先介绍本文试图解决的问题。自2013年Docker正式发布以来，容器技术因其封装性强、易于部署程序、开销小的优势，在业界掀起一场技术风暴。因此，许多人认为可以在云服务中抛弃虚拟机抽象，转而使用更为轻便的容器。然而，2015年Red Hat的一篇调查显示，60%的公司担忧容器弱隔离型可能引发的问题。为什么业界会对容器的安全性产生疑虑呢？其中一个原因是过大的攻击面（Attack Surface）。容器技术植根于Linux内核，一个容器进程与内核之间通过系统调用、Proc/Sys虚拟文件系统等方式进行交互。任何一个容器本身或者接口层面的漏洞都可能使得容器内的程序获得Root权限，进而威胁到其他容器内程序的安全。</p>

<p>本文的目标是使用Intel SGX保护容器，加强其隔离性。在展开论文之前，有必要简单介绍一些SGX的背景知识。SGX是Skylake中的新特性，它提供名为Enclave的抽象。一个程序如果运行在Enclave内，它的内存将被硬件自动加密，即使高权限的程序（例如内核），也不能读取其内存数据。</p>

<p>可是，SGX技术本身的技术特点决定了不能直接将容器放入Enclave内，因此，本文需要解决以下2点Challenges。第一，如何减少可信计算基（TCB），也就是如何使得Enclave内的程序代码尽可能得少；第二，如何减少引入Enclave抽象带来的开销。</p>

<p>为了解决上述Challenges，本文实现了SCONE，架构图如下：</p>

<p><img src="http://ytliu.info/images/osdi2016/42-1.png" alt="42-1" /></p>

<p>其中采用了3种技术策略，下面笔者将依次对它们进行介绍。
第一个策略是将LibC放入Enclave。如果一个系统不信任内核，应该尽可能少地使用内核提供的接口，Haven是很好的一个例子，它只使用了22个系统调用，但因为它将整个Windows LibOS放入Enclave中，从而引起了较大的开销。SCONE的策略是将LibC放入Enclave中，大大减小了TCB，从而减少了开销。可是LibC实现里会调用较多的系统调用，比如read、write、send、recv。为了保护这些系统调用，SCONE会使用Shield技术保护这些调用，也就是下一个策略。</p>

<p>Shields技术透明地加密文件、加密通讯数据（通过TLS）、加密串口数据。当一个文件描述符被打开时，SCONE会为其绑定对应的Shield。当然，Shield只会保护用户数据，而不会考虑Metadata。</p>

<p>第三个策略是异步系统调用。SGX不允许在Enclave中直接发起系统调用，因此必须由Enclave之外的线程提供协助。具体而言，SCONE实现了一个内核模块，其中为若干个内核线程，用来替Enclave内的线程完成系统调用。首先，Enclave内的线程首先需要把参数写入非加密的请求队列（Request Queue）；接着，内核模块内的线程读取参数并完成系统调用，并把结果写入相应队列（Response Queue）；最后，Enclave内线程得到队列中保存好的结果。</p>

<h4>>>> Coordinated and Efficient Huge Page Management with Ingens &lt;&lt;&lt;</h4>

<p>本文的作者来自德州大学奥斯汀分校，其中有3位大神：Simon Peter、Christopher J. Rossbach和Emmett Witchel。Emmett Witchel组今年中了2篇OSDI，笔者做过统计，Witchel大神一共发过10篇SOSP/OSDI。本文一作是来自韩国的Youngjin Kwon，今年发在ASPLOS上的Sego也是他的工作。</p>

<p>64位的虚拟地址需要经过4次页表的翻译，在硬件虚拟化环境下，每次Guest页表翻译需要走4次EPT页表。可以看出，4KB页所带来的虚拟地址翻译开销很大。如果我们使用2MB的大页（Huge Page），将会省掉许多的地址翻译工作。然而，目前内核中对于大页的支持存在着许多问题，以至于很多人宁愿把大页支持关掉，以避免给程序带来意外的性能问题。</p>

<p>本文依次分析了内核中对大页支持的问题，并针对这些问题，设计一个名为Ingens的系统。下面，笔者将重点介绍其中的3个问题与其解决方法。</p>

<p><strong>第一，Page fault latency</strong></p>

<p>作者表示，内核的大页分配策略是greedy且aggresive的，如果在4KB页上发生page fault，内核会立即使用大页支持。然而，分配大页的开销较大，原因有二，其一是必须将整个页面内容全部清零；其二为，当没有足够内存分配大页时，内核会将挪动其他页面，从而拼凑出一个完整的大页。</p>

<p>为了减小page fault的延迟，Ingens只在page fault handler内决定是否使用大页（根据Util bitvector），之后立即返回。如果有必要整合内存，handler会并通知一个后台的Pomote线程，由它负责异步地整合大页。</p>

<p><strong>第二，Increased memory footprint (bloat)</strong></p>

<p>使用大页有一个缺点：即使你只使用其中很小的部分，其他部分也不能给其他程序使用，从而造成了很大的内存泄露。为了证明这点，作者做了一个对比试验，结果如下。可以看出，在Redis里，使用大页将会造成69%的内存泄露。</p>

<p><img src="http://ytliu.info/images/osdi2016/43-1.png" alt="43-1" /></p>

<p>解决这个问题的思路其实很简单，只需要维护一个记录页面使用率的数据结构就好。Ingens也的确是这么做的，它用Util bitvector来记录一个大页内存的使用率。当Util bitvector显示此内存的使用率超过一个阈值（作者设为90%），就将其整合成大页。</p>

<p><strong>第三，Huge pages increase fragmentation</strong></p>

<p>前面说到，当没有足够多内存分配大页时，page fault延迟会提高，这种说法实际上是不严谨的，内存中的确存在着足够的内存，它们的数目加起来也许很大，但是彼此不相邻，因而不能整合成一个完成的大页。这种不相邻的内存空间就是fragmentation。作者发现：目前内核在使用大页时会造成很多fragmentation。</p>

<p>为了解决这个问题，Ingens会在Pomote线程中整合大页。因为整合过程需要进行拷贝内存等操作，所以会占用过多CPU，为了尽可能少地影响其他程序，Promote线程每次只整合100MB的内存。</p>

<hr />

<h3>Session~[Cloud Systems II]</h3>

<h4>>> Diamond: Automating Data Management and Storage for Wide-Area, Reactive Applications &lt;&lt;&lt;</h4>

<p>本文的第一作者是<a href="http://irenezhang.net/">Irene Zhang</a>。她出生在北京，在MIT本科毕业后，去了VMware工作了几年，现在正在Washington攻读博士学位。在VMware工作期间，主要工作围绕VM checkpointing，分别在VEE&#8217;11和ATC&#8217;13发表论文。博士期间主要研究方向是cloud system，尤其是cloud application。她在OSDI&#8217;14和SOSP&#8217;15上各发表了一篇文章。她的两位导师分别是Arvind Krishnamurthy和Henry M. Levy。</p>

<p>本文的目标应用叫做reactive applications，这是一种分布式的应用，用户会在多台设备上使用，且不需要显式地对共享数据进行保存和刷新。方便程序员进行开发分布式的reactive applications。类似twitter的社交app，以及类似炉石传说的游戏软件，都属于这一范畴。由于reactive applications会在多用户之间共享数据，因此有必要在用户之间维持一致性(consistency)，否则会容易出bug。但众所周知一致性是一个维护起来很麻烦的性质，它需要考虑到程序执行的各种情况。过去的reactive application要么由开发者手动处理各种可能的问题，要么采用通用但不能满足所有需求的框架(比如Dropbox能解决存储共享数据的问题，却不能处理信息推送的问题)。在这种情况下，作者提出了<strong>Diamond</strong>，这是第一个为分布式reactive application特别设计的服务系统。该系统将程序逻辑与共享数据管理解耦，开发者可以集中精力处理好应用逻辑，同时使用Diamond的接口获取到具有一致性保证的共享数据。</p>

<p>Diamond的大致框架如下图。在Diamond中，所有用户都通过libDiamond与特化的server——Diamond cloud相连，由它统一负责共享数据更新及推送工作。</p>

<p>![44-1] (http://ytliu.info/images/osdi2016/44-1.png)</p>

<p>reactive data map(rmap)是连接client的本地数据与Diamond server上的共享数据之间的桥梁，用户可以通过rmap让本地的变量(如players)与Diamond server上的共享变量建立映射。为了保证每个用户看到的变量都是一致的，Diamond提出了ACID+R的性质，既能保证传统事务系统中的ACID，又具备了reactive application的reactivity(响应性)特征。</p>

<p>论文主要通过两类transaction来实现ACID+R。一类是能够更新共享数据的read-write transaciton，另一类是能对修改作出响应的reactive transaction。开发者使用read-write transaction来执行程序逻辑，保证ACID；同时开发者也可以注册reactive transaction，这是一种特殊的read-only transaction，当它的read set中的变量被人修改时，reactive transaction将会被激活执行，将修改从server端同步到本地。有了reactive transaction的辅助，就能够在保证ACID的同时给予用户“应用在不断进行远程同步”的印象了。</p>

<p>这里有一个小八卦：和华盛顿大学的博士生聊天时得知，去年SOSP上Irene Zhang的工作——TAPIR，最初竟然来自于一个课程项目，这令我很是意外。与TAPIR类似的是，Diamond的灵感似乎也十分贴近生活，笔者手机里的炉石传说就是明证。能在日常中的各处发现灵感并应用到自己的研究之中，想想还是挺酷的呢。</p>

<h4>>> Slicer: Auto-Sharding for Datacenter Applications &lt;&lt;&lt;</h4>

<p>这是一项 Google 和以色列理工学院的工作。 分片 (sharding) 是大规模应用程序中很很重要的一部分。然而现有的系统多使用自定制化的分片系统。这篇论文介绍了在 Google 内使用的通用分片系统，其通过负载热点 (load hotspots) 和服务器状况 (server health) 来动态的对工作进行分片划分。在保证了高可用和负载均衡的情况下，尽可能地减小任务移动带来影响。</p>

<p><strong>总体介绍</strong></p>

<p>Slicer 是一个通用的分片系统。为了方便介绍，作者先做了一些定义。一个应用程序通常会包括很多任务 (tasks) ，这些任务一起组成一个工作 (job) 。在做负载均衡的时候，是以任务为粒度的。</p>

<p>Slicer 在做分片的时候，是以键 (key) 为单位的。
Slicer 结合了 Google 的 Stubby RPC 系统用于路由其他服务发来的 RPC 请求，并使用了 Google 的前端 HTTP 负载均衡器路由外部浏览器发来的 HTTP 请求，以及 REST 客户端。</p>

<p><strong>系统组成</strong></p>

<p>Slicer 包括一下几个组件：</p>

<ul>
<li>中心化的 <em>Slicer Service</em> ；</li>
<li><em>Clerk</em> ，用于链接到客户端应用程序的库；</li>
<li><em>Slicelet</em> ，用于链接到服务器端任务的的库。</li>
</ul>


<p>下图是 Slicer 的架构图，总的来说， <em>Slicer Service</em> 是 Slicer 的主体部分， <em>Clerk</em> 和 <em>Slicelet</em> 分别在客户端与服务端与 <em>Slicer Service</em> 进行交互。</p>

<p><img src="http://ytliu.info/images/osdi2016/45-0.png" alt="arch" /></p>

<p><strong>分片模型</strong></p>

<p>Slicer 将应用程序中的键哈希到 63 比特的 <em>slice key</em> 。每个 <em>slice</em> 被分配到这个映射空间中的一段。这种方式的有两个好处： 1. Slicer 的与应用程序中实际使用的键分开，不受限制于应用程序中键的多少，也不限制应用程序增加和减少键的数量； 2. 这种方法简化了负载均衡算法，因为比较热门的键更可能被均匀的分布到不同的分片中。而这种方式的牺牲了局部性 (locality) ，另外对于区间查询的支持会比较复杂。
根据应用程序的不同， Slice 提供强一致性和最终一致性。</p>

<p><strong>接口</strong></p>

<p>Slicelet 接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>interface Slicelet {
</span><span class='line'>  boolean isAffinitizedKey(String key);
</span><span class='line'>  Opaque getSliceKeyHandle(String key);
</span><span class='line'>  boolean isAssignedContinuously(Opaque handle);
</span><span class='line'>}
</span><span class='line'>interface SliceletListener {
</span><span class='line'>  void onChangedSlices(List&lt;Slice&gt; assigned,
</span><span class='line'>      List&lt;Slice&gt; unassigned);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这些接口不是必须被用到的，但是一些应用程序可以使用这些接口来实现一些功能。</p>

<p><code>isAffinitizedkey</code> 用于检测一个键是否被错误的路由过来，可以用于决定是让客户端重发请求还是在这台错误的服务器上继续执行。尽管路由到错误的服务器上，但是一些服务依然是可以被执行的，比如缓存。</p>

<p><code>getSliceKeyHandle</code> 和 <code>isAssignedContinuously</code> 一起用于检测在本地执行请求期间，一个键的分片是否被改变过，从而保证更强的一致性。</p>

<p>Clerk 接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>interface Clerk {
</span><span class='line'>  Set&lt;Addr&gt; getAssignedTasks(String key);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>论文中似乎并没有提到这个接口在什么情况下会被使用，只提到说大多数应用程序可以忽略这个接口。</p>

<p><strong>应用举例</strong></p>

<ul>
<li>内存缓存

<ul>
<li>Flywheel (HTTP proxy for mobile devices)</li>
<li>&#8230;</li>
</ul>
</li>
<li>内存存储

<ul>
<li>语音识别</li>
<li>云 DNS</li>
</ul>
</li>
<li>聚合程序 (Aggregation Applications)

<ul>
<li>事件分析</li>
<li>客户端推送 (Pubsub systems for mobile devieces)</li>
</ul>
</li>
</ul>


<p><strong>实现细节</strong></p>

<p>下图是 Slicer 更加细节的服务架构。</p>

<p><img src="http://ytliu.info/images/osdi2016/45-1.png" alt="arch-detail" /></p>

<p><strong>分片方案：</strong>
Slicer 将所有的分片方案保存在一个一致性存储之中，<em>Assigner</em> 负责根据现有信息更新分片方案。 <em>Assigner</em> 每次从这个一致性存储中读出分片信息，然后根据工作大小、服务器状态、负载情况产生新的分片方案，虽然事务性的将更新保存回一致性存储之中。事务性可以保证分片方案写回的一致性。</p>

<p><strong>分片方案分发：</strong>
图中， <em>Distributor</em> 是加在 <em>Assigner</em> 和 <em>Client</em> 之间的一层。论文中说，在大规模服务下，分发成为了计算和网络的瓶颈。因此 Slicer 将分发单独做成了一层。 <em>Client</em> 先从本地的缓存里面查询分片信息，如果没有找到，则去请求 <em>Distributor</em> 。 <em>Distributor</em> 如果也没有这个信息，则去询问 <em>Assigner</em> 。</p>

<p><strong>容错：</strong>
<em>Backup-Distributor</em> 用于在 <em>Distributor</em> 出现故障的时候使用。为了避免一同出现故障，其使用的是与 <em>Distributor</em> 不同的代码和逻辑。<em>Backup-Distributor</em> 使用静态分片方法，基于稍陈旧的负载和服务器“健康”信息。虽然性能会差一点，但是至少能够保证服务可用。</p>

<p><strong>负载均衡：</strong>
除了前文提到的哈希映射可以帮助负载均衡之外， Slicer 还有一些其他的方法可以帮助做负载均衡：</p>

<ul>
<li>增减某个键上的冗余任务。在某些应用程序上，让更多的任务去处理热门数据上的请求。</li>
<li>键范围切分和合并。如果 [a,c) 上的流量过载，则将其进一步切分成 [a,b) 和 [b,c) 。当然为了防止无限制的切分，也需要把一些冷范围进行合并。</li>
</ul>


<p><strong>强一致性：</strong>
由于有些应用程序对强一致性有要求， Slicer 可以保证强一致性（可选功能）。
实现强一致性最简单的方法是使用 lease manager ，如 Chubby 。然而 Chubby 无法扩展到支持上亿级别的 lease 管理，因此为每个键分配一个 lease 是不可行的。</p>

<p>于是 Slicer 巧妙地对于每个工作只使用三个 lease 。分别为：</p>

<ol>
<li><em>job lease</em> ，用于保证同一时刻只有一个 <em>Assigner</em> 能够管理分片方案；</li>
<li><em>guard lease</em> ，用于保证 <em>Assigner</em> 在修改分片方案的时候，没有 <em>Slicelet</em> 在读分片方案。</li>
<li><em>bridge lease</em> ，当分配方案（的一个键范围） A1 要被改变成 A2 的时候， <em>Assigner</em> 首先保存和分发 A2 然后创建一个 <em>bridge lease</em> ，等待 <em>Slicelet</em> 获取这个 <em>bridge lease</em> 后，<em>Assigner</em> 才去修改 <em>guard lease</em> 。当一个 <em>Slicetlet</em> 获得 <em>bridge lease</em> 之后，他可以访问 A1 和 A2 的交集。这可以保证在 A1 更新成 A2 的过程之中， <em>Slicelet</em> 不会被阻塞。</li>
</ol>


<p>总体来说，这是一项很有内容的工作，解决的是很实际问题。 Slicer 已经在 Google 内被超过 20 个客户服务所使用，在 100,000 个客户和服务端之间每秒钟均衡 2-7M 请求。</p>

<h4>>> History-Based Harvesting of Spare Cycles and Storage in Large-Scale Datacenters &lt;&lt;&lt;</h4>

<p>本文的第一作者是来自University of Michigan的Yunqi Zhang，主要研究方向是scalablity。二作是来自EPFL的George Prekas，主要研究方向是high throughput &amp; low latency。</p>

<p>这篇文论针对的是服务器端的资源利用问题。目前服务器端存在很大的资源浪费，特别是部署与用户交互的低延迟要求服务时。因为这类服务往往在用户使用时存在明显的波峰，并且需要预留资源处理一些突发事件。为了解决资源利用率低的问题，往往会将一个批处理服务（如机器学习）以及其所需的数据存储在部署了低延迟要求的服务器中，让它们协同运行。在将一个批处理服务<code>co-locate</code>在部署了低延迟要求服务的机器上时，需要保证其不能对原先服务的响应时间造成太大影响。同时批处理服务本身的性能也不能太差，否则就丧失了协同运行的意义了。</p>

<p>为了防止批处理服务影响原有服务的性能，当原有服务需要批处理服务占用的资源时，批处理服务会被杀死并在之后重新启动。与此同时，原有服务很可能会定期格式化磁盘（例如为了更换服务器上运行的服务），这也就使得批处理服务在本地存储的数据可能会丢失。为了解决这些，本篇论文利用一些<strong>historical</strong>的分析结果，减少批处理服务被终止的次数，增强批处理服务数据的持久性。</p>

<p>首先为了得到原有服务的一些特性，作者利用AutoPilot记录原有服务的某些特定行为。由于本文主要考虑CPU资源的利用率以及数据存储的持久化，所以作者主要分析了原有服务在CPU利用率方面的特性以及磁盘格式化的频率等信息。利用这些<strong>historical</strong>的数据，作者进一步提出了一个调度方法以及一个数据分配方法。</p>

<p>调度方面，通过之前的分析，作者将原有的低延迟服务根据它们的CPU使用率变化分为三类，周期性，非周期性以及恒定性。调度时，所有的低延迟服务都将被划分成这三类中的一种。而同时批处理服务也会被划分成大、中、小三种，每种批处理服务对不同种类的低延迟服务都拥有不同的适应率。例如运行时间较长的批处理服务就更为适合CPU利用率几乎不变的恒定性服务，因为这类服务很少出现CPU利用率的突变，基本不会打断批处理服务的运行。而中等大小的批处理服务更适合与周期性的低延迟服务协同工作，只要其位于原有服务两个CPU利用率的波峰之间即可。小型批处理服务则适合与非周期性的低延迟服务一同部署。</p>

<p><img src="http://ytliu.info/images/osdi2016/46-1.jpg" alt="46-1" /></p>

<p>对于批处理服务的数据储存，作者使用一个分布式数据存储系统提供数据存储服务。然而原先服务的格式化操作会破坏数据的持久性，另一方面一旦某服务器的原先服务CPU利用率达到峰值，那么那个节点的数据将暂时无法访问，从而降低数据的可用性。为了兼顾数据的持久性和可用性，备份算法在两个不同的维度对服务器进行划分，磁盘格式化的几率和CPU波峰的利用率，分别对应持久性与可用性。在每个维度上服务器会被分为三种不同的级别。存储数据备份时，会保证一个数据的不同备份在持久性和可用性维度上均不同。</p>

<p><img src="http://ytliu.info/images/osdi2016/46-2.jpg" alt="46-2" /></p>

<p>这篇论文巧妙的通过对服务器中原有服务进行利用率，磁盘格式化等行为的分析，通过分析结果进一步优化协同工作的批处理服务的调度以及数据分布策略。结果显示该工作能够很好的对服务器的冗余资源进行利用，同时不对原有低延迟服务造成明显的性能影响。</p>

<p>为了减少由于原先服务格式化磁盘带来的影响，该系统需要合理的对数据进行备份。</p>

<h4>>> DQBarge: Improving data-quality tradeoffs in large-scale Internet services &lt;&lt;&lt;</h4>

<p>这是一篇来自 UMich 和 Facebook 合作的论文，一作 Michael Chow 曾在 OSDI&#8217;14 上发表一篇，参与两篇，非常厉害。导师是 Jason Flinn，系统界大佬，今年收获两篇。这篇我觉得应该是作者在 Facebook 实习的时侯完成或者是和 Facebook 有合作，因为文章整体上属于对工业界的生产系统进行深入分析，然后提出针对性的实用解决方案的工作，比较接地气。</p>

<p>文章研究的问题是所谓的“数据质量（data-quality）”。在 Facebook 的系统中，通常一个服务是有非常非常多的小的功能组件组合起来的。作者发现，为了达到这个服务整体的性能目标（例如低延迟），编写小的功能组件的程序员通常会在数据的精确性和组件的对一个请求的完成时间上做取舍（tradeoff）。换句话说，当这个组件发现自己可能来不及完成一个请求并传给下一个组件的时候，它可能选择返回一个不那么精确的值或者可能是一个局部值；当它有足够的时间完成时，则能够提供一个完全准确的值。举个栗子：比如键值存储服务中，一个组件负责统计数据集的大小，但是当它的 deadline 快到了可是所需的数据只收到了一部分，那这个时候是应该继续等呢还是放弃？通常程序员为了达到延迟要求，会设置一个 timeout，如果时间到了却无法得出正确结果，那这个组件就选择只返回已经收到的数据集的大小，比如只有 1/2 的数据。那这个结果当然是不准确的，但是满足了延迟要求，而且在一些对数据的准确性要求不是非常严格的情形下，也不会造成严重后果。</p>

<p>![47-1] (http://ytliu.info/images/osdi2016/47-1.png)</p>

<p>作者研究了 Facebook 的一个键值存储系统 Laser，发现这种取舍非常普遍。作者还发现，这样的取舍通常都是被动的，即在发现时间已经用完的时候，才被动地做一个取舍。而且这些组件通常只能根据自己内部记录的状态来做决定，无法得知整个服务全局的状态（比如其他组件的延迟，请求的处理路径）。所以文章提出一个系统 DQBarge，这个系统能够对 Facebook 服务处理请求的过程进行取样，获得输入和输出。然后对某一个服务，不断地用喂输入，比较输出，记录请求处理的关键路径、系统负载等信息，检测组件在数据精确性和请求处理时间之间所做的取舍，并对整个服务的行为建模。有了这样的模型，该服务在生产环境中运行时，每一个组件可以动态地得知一个请求经过的路径和系统状态，从而根据生产环境的全局信息，查询这个模型，积极地而非被动地做出数据精确性取舍。</p>

<p>我觉得这个工作是比较偏工业界，因为整个问题的背景是特定于 Facebook 的内部服务。但是抛开这样的特定性，作者解决问题的方法是典型的系统的方法，对于我们做系统研究依然有借鉴意义。</p>

<hr />

<p>总结一句话，欢迎大家参加明年在上海举办的SOSP-2017！</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X86指令编码的那些事儿]]></title>
    <link href="http://ytliu.github.io/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/"/>
    <updated>2016-12-10T22:46:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er</id>
    <content type="html"><![CDATA[<p>好久没有写博客了，感觉时间飞逝，转眼又到了一年的最后一个月了，不管怎么说这一年自己还是挺有收获的，当然这些是留在年末总结的时候来写的。这篇文章继续之前“那些事儿”系列，这次要介绍的，是关于X86指令编码的“事儿”。</p>

<p>如果你之前有见过或者听说过<code>prefix</code>，<code>opcode</code>，<code>ModR/M</code>，<code>escape opcode</code>这些词，但是其实并不是那么清楚它们是什么意思，那么恭喜你，今天你就将得到它们！首先还是先说明下这篇博客主要参考的资料，依旧是来自Intel的文档（这里再次安利下Intel文档，写的非常详细），不过这次是第二册的几个章节（Volume 2 - Chapter 2~4, 以及Appendix A）。</p>

<!-- more -->


<p>好了，废话不说，直接进入正题。</p>

<p>我们知道，CPU在运行的时候认的是一个个二进制的数字（或者人类为了方便说明，一般会把它们先转换成一个个十六进制的数字）。那么，就需要有一套编码机制，告诉计算机，这些数字代表的意思是什么。</p>

<p>我们还知道，CPU一般执行的都是一条条的指令，每个指令都有其相对应的含义，以及一些它们所需的附加信息，比如数据读取的原地址，或者写入的目标地址。而CPU就是用之前所谓的编码机制，来识别并且运行这一条条指令的。</p>

<p>因此，将这两个合起来，就是我们今天所要讨论的<code>指令编码</code>，如果用一个英文词的话，可以用<code>encoding</code>，如果用两个英文词的话，那就是<code>instruction encoding</code>，如果还要加第三个词的话，就变成了<code>x86 instructino encoding</code>。好了，我不无聊了，继续往下聊吧。</p>

<p>你之前可能听说过，x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p>

<p><img src="http://ytliu.info/images/2016-12-10-1.png" title="Intel 64 and IA-32 Architectures Instruction Format" alt="Instruction Format" /></p>

<p>可以看出，在x86的指令格式中，每条指令<strong>最多</strong>会有六部分组成，在这六部分中，只有<code>opcode</code>是必须的，其它的部分都是可选的。接下来我们一个部分一个部分进行介绍：</p>

<h4>Instruction prefix</h4>

<p><code>prefix</code>说白了就是对本条指令进行一个修饰，主要包含了以下四组可能的prefix：</p>

<ul>
<li>第一组：<code>lock</code> 和 <code>repeat</code></li>
</ul>


<p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p>

<ul>
<li>第二组：<code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></li>
</ul>


<p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p>

<ul>
<li>第三组：<code>operand-size override</code></li>
</ul>


<p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p>

<ul>
<li>第四组：<code>address-size override</code></li>
</ul>


<p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p>

<h4>Opcode</h4>

<p>接下来是最重要的opcode，基本上整个指令编码都是围绕opcode来进行的，所以opcode是整个指令的核心。</p>

<p>一个opcode可能的长度为1、2或3，除此之外，在之后会提到的<code>ModR/M</code>所占用的那个byte中，还有可能会有3个bits来表示opcode的一部分内容，当然，这3个bits主要用来定义一些额外的信息，包括：direction of operation, size of displacements, register encoding, condition codes, or sign extension，至于这三个bits是否属于opcode，或者它们表示什么信息，是由不同的opcode来决定的。</p>

<p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p>

<p>除此之外，还有一种可能是，在这个<code>escape opcode</code>之前，还有可能会出现一个被称为<code>mandatory prefix</code>的byte，这不属于我们之前提到的任何一种prefix，我感觉它一般是在某个新的硬件特性出来的时候，为该硬件特性新增加指令的一种做法。这个byte可能的取值为<code>66H</code>，<code>F2H</code>或者<code>F3H</code>。很有趣的一点是，<code>66H</code>也是<code>lock prefix</code>的取值，而<code>F2H</code>和<code>F3H</code>也是<code>repeat prefix</code>的取值。所以说，当遇到这些prefix的时候，还得需要根据之后的opcode来判断这是属于哪种prefix。</p>

<p>这里举一个例子，比如一个指令叫<code>PHADDW</code>，是在<code>XMM</code>特性中的一条指令，它的编码为<code>66 0F 38 01</code>，因此，它是一个<code>3-bytes opcode</code>，<code>66</code>是<code>mandatory prefix</code>（而不是<code>lock prefix</code>），<code>0F</code>是escape opcode，而最后两个bytes<code>38 01</code>就是另外两个opcode bytes。</p>

<h4>ModR/M 和 SIB</h4>

<p><code>ModR/M</code>主要是在对指令中的操作数进行寻址的时候需要用到的域，它由一个byte组成，如之前的图所示，<code>ModR/M</code>这一个byte又被分成了三部分：<code>mod</code>（由6~7两个bits组成），<code>reg/opcode</code>（由3~5三个bits组成），<code>r/m</code>（由0~2三个bits组成）。其中，如前所说，<code>reg/opcode</code>可以表示某个寄存器，或者作为opcode的三个额外bits进行使用。而<code>mod</code>和<code>r/m</code>结合，可以产生32种可能的值，包括了8个寄存器和24中寻址模式。</p>

<p>另外，在<code>ModR/M</code>三个部分可能的组合中，还有可能会涉及到另外一个寻址模式，被称为SIB，SIB也是由三部分组成：Scale，Index和Base。一般如果涉及到SIB，则相关的值就可以通过<code>base + index * scale</code>计算出来。</p>

<p>接下来，我们来详细解释下如何利用<code>ModR/M</code>和<code>SIB</code>进行寻址。这里主要有三张非常关键的表，可以说，利用<code>ModR/M</code>和<code>SIB</code>进行寻址都可以通过查这三张表完成。</p>

<p><img src="http://ytliu.info/images/2016-12-10-2.png" title="16-Bit Addressing Forms with the ModR/M Byte" alt="16-bit ModR/M" /></p>

<p><img src="http://ytliu.info/images/2016-12-10-3.png" title="32-Bit Addressing Forms with the ModR/M Byte" alt="32-bit ModR/M" /></p>

<p><img src="http://ytliu.info/images/2016-12-10-4.png" title="32-Bit Addressing Forms with the SIB Byte" alt="32-bit SIB" /></p>

<p>其中，可以利用第一张表对16位的地址寻址进行查询，利用第二张表对32位的地址寻找进行查询，而第三张对某些需要用到SIB的地址寻址进行查询。对于<code>ModR/M</code>表（即前两张表），我们看到中间一部分列出了00~FF所有的数字，这些数字是即为一个byte的所有可能值，该byte的组成之前也提到了，如下图所示：</p>

<p><img src="http://ytliu.info/images/2016-12-10-5.png" title="ModR/M Byte" alt="ModR/M byte" /></p>

<p>所以，当得到一个<code>ModR/M</code>的值，就可以查询这张表，这里举个例子，比如<code>ModR/M</code> byte的值为<code>CC</code>，那么我们找到<code>CC</code>对应的行和列，可以发现，它对应的行为<code>ESP/SP/AHMM4/XMM4</code>，列为<code>CL/CX/ECX/MM1/XMM1/1/001</code>。那么就将范围限定在了这几个寄存器上，当然，至于它最后要选哪个寄存器，则是由opcode来决定的。</p>

<p>同样的，对于需要用到<code>SIB</code>表（即最后一张表）的指令，同样的，我们获得<code>SIB</code>的数值（比如<code>CC</code>），发现它对应的行为<code>[ECX*8]</code>，列为<code>ESP</code>，即表示SIB最终的值的计算方法为<code>[ESP]+ECX*8</code>。</p>

<h4>Displacement 和 Immediate</h4>

<p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。这部分很直接，就不解释了。</p>

<hr />

<h3>IA-32e mode</h3>

<p>上面提到的都是16位或者32位的寻址，而我们现在主要用的系统都是64位的，那么，在64位系统下的寻址又是怎么样的呢？</p>

<p>这里又要引入一个新的prefix：<code>REX prefix</code>，如下图所示：</p>

<p><img src="http://ytliu.info/images/2016-12-10-6.png" title="Prefix Ordering in 64-bit Mode" alt="REX prefix" /></p>

<p>这里需要注意的是，每条指令最多只能有一个表示<code>REX prefix</code>的byte，而且这个byte必须紧紧贴着opcode，不能放在其他的prefix之前。另外，<code>REX prefix</code>的格式如下图所示：</p>

<p><img src="http://ytliu.info/images/2016-12-10-7.png" title="REX Prefix Fields" alt="REX prefix format" /></p>

<p>其中，最高的4位是固定的值（<code>0100</code>），低4位分别代表了operand size，以及是否修改<code>ModR/M</code>和<code>SIB</code>的值。比如说下面四张图：</p>

<p><img src="http://ytliu.info/images/2016-12-10-8.png" title="REX Prefix 1" alt="REX prefix 1" /></p>

<p><img src="http://ytliu.info/images/2016-12-10-9.png" title="REX Prefix 2" alt="REX prefix 2" /></p>

<p><img src="http://ytliu.info/images/2016-12-10-10.png" title="REX Prefix 3" alt="REX prefix 3" /></p>

<p><img src="http://ytliu.info/images/2016-12-10-11.png" title="REX Prefix 4" alt="REX prefix 4" /></p>

<p>如果对应的R\X\B bit被设置上了，则会根据opcode来修改对应的<code>ModR/M</code>中<code>r/m</code>或者<code>reg/opcode</code>域中的值，或者<code>SIB</code>中<code>base</code>或者<code>index</code>域中的值。我们知道，这些域其实就是指定了某些寄存器，而基于<code>REX prefix</code>的修改其实就是将16或者32位的寄存器换成64位的，比如把<code>EAX</code>换成<code>RAX</code>这样。</p>

<hr />

<h3>opcode table</h3>

<p>好了，最关键的技能来了，教你如何看懂opcode table!</p>

<p>其实也就三张opcode table（或者叫opcode map也行），就是前面所说的<code>1-byte</code>, <code>2-bytes</code>和<code>3-bytes</code>。比如我们随便截一张图：</p>

<p><img src="http://ytliu.info/images/2016-12-10-12.png" title="opcode table random" alt="opcode table 1" /></p>

<p>这是一个<code>1-byte</code> opcode table，如果我们的opcode是<code>85</code>，则找到第八行第五列对应的那个小格子：<code>TEST (Ev, Gv)</code>。那么这个是什么意思呢？首先，<code>TEST</code>是opcode，<code>(Ev, Gv)</code>是这条opcode的寻址模式。<code>E</code>，<code>v</code>，<code>G</code>这些都是缩写，在opcode map中有很多缩写，这篇博文最后的附件中显示了它们的含义。可以看到，<code>E</code>表示opcode之后会跟一个<code>ModR/M</code> byte，用来表示操作数，该操作数可以是一个寄存器或者一个内存地址，如果是内存地址的话，该地址可以通过之后的SIB和displacement算出来；<code>v</code>表示这个操作数可能是一个16位的word，32为的doubleword，或者64位的quadword，具体情况要根据operand-size的属性决定（比如是否有<code>operand-size override prefix</code>，或者REX.W bit是否被置上等）；<code>G</code>代表<code>ModR/M</code>中的<code>reg</code>域会选择一个通用寄存器。
因此，有了这个opcode table之后，就可以接着往下去看对应的<code>ModR/M</code>、<code>SIB</code>以及可能存在的displacement了，然后再去查之前<code>ModR/M</code>和<code>SIB</code>相关的表，就能得到整条指令的意思，以及该指令所对应的寻址方式。</p>

<p>其实查询opcode table的整个流程特别简单。如果你想要模拟一个指令，你就在opcode table中搜索这条指令，然后找到其对应的小格子（比如前面例子中的那个<code>TEST (Ev, Gv)</code>），然后根据前面所的方法再去看后面的<code>ModR/M</code>和<code>SIB</code>等内容，一个个往下走就行了。</p>

<hr />

<h3>虚拟化环境中的指令模拟</h3>

<p>其实到这里，x86的指令编码部分基本上都讲完了。之所以还要加上这一小节，是想举个例子，练习练习。</p>

<p>我们知道，在虚拟化环境中，如果非特权级环境中的客户虚拟机执行了一条特权级指令，则会引发下陷，进入特权级别中的虚拟机监控器，由虚拟机监控器对该指令进行模拟。在虚拟化环境中有14条指令是会无条件引发虚拟机下陷（VMExit）的，它们是<code>CPUID</code>, <code>GETSEC</code>, <code>INVD</code>, <code>XSETBV</code>, <code>INVEPT</code>, <code>INVVPID</code>, <code>VMCALL</code>, <code>VMCLEAR</code>, <code>VMLAUNCH</code>, <code>VMPTRLD</code>, <code>VMPTRST</code>, <code>VMRESUME</code>, <code>VMXOFF</code>, <code>VMXON</code>。我们就以<code>VMCLEAR</code>这条指令为例，看看虚拟机监控器里面要如何对其进行模拟。</p>

<p>当然，最简单的办法就是在发生VMExit的时候直接去读取相应<code>RIP</code>的值，然后获得指令的opcode和其它内容，通过查表我们可以知道<code>VMCLEAR</code>指令的opcode是<code>66 0F C7 /6</code>，然后通过查opcode table，我们发现以下内容：</p>

<p><img src="http://ytliu.info/images/2016-12-10-13.png" title="opcode table for vmclear" alt="opcode table vmclear" /></p>

<p>这里需要注意的一点是，这个表示一个扩展表，是Intel为其它新添加的硬件特性重新扩展得到的opcode table，其实我们之前提到过，这里<code>66</code>是一个<code>mandatory prefix</code>，所以它的opcode是<code>0F C7</code>，另外，<code>ModR/M</code>中的<code>reg/opcode</code>用于补充opcode，所以这里的<code>/6</code>表示的是<code>ModR/M</code>中<code>reg/opcode</code>的值。</p>

<p>不管怎么样，<code>VMCLEAR</code>有3个bytes的opcode，然后从opcode table查询出来的值为<code>VMCLEAR (Mq)</code>，我们查询缩写表可以知道，<code>M</code>表示<code>ModR/M</code>用于表示内存寻址，而<code>q</code>表示一个64位的quadword（不管operand-size是什么）。因此，我们知道在这个opcode之后一定至少有一个表示<code>ModR/M</code>的byte，所以我们就可以继续读这个byte，然后通过<code>ModR/M</code>的寻址表来确定操作数的内存地址是什么了。具体的这里就不阐述了。</p>

<p>不过这里还需要提一点的是，其实最后我们发现，<code>VMCLEAR</code>采用的是SIB寻址的模式，而且对于它的寻址，可以不需要通过opcode table来进行，因为在虚拟化环境中，虚拟机下陷会将需要的信息填入VMCS的某些数据结构中，比如，对于特权指令产生的下陷，会将和这个指令相关的信息（特别是操作数寻址的信息）存入一个叫<code>VM-exit instruction information</code>的域中，这个域对于每种指令都会提供不同的存储信息的格式，因此我们在虚拟机监控器中对这些指令进行模拟的时候，其实是可以直接从<code>VM-exit instruction information</code>域中获取所需的信息的。</p>

<hr />

<p>附：opcode table中缩写码的含义：</p>

<ul>
<li>Codes for Addressing Method</li>
</ul>


<table>
<thead>
<tr>
<th align="center">Code </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">A </td>
<td align="left"> Direct address: the instruction has no ModR/M byte; the address of the operand is encoded in the instruction. No base register, index register, or scaling factor can be applied (for example, far JMP (EA)).</td>
</tr>
<tr>
<td align="center">B </td>
<td align="left"> The VEX.vvvv field of the VEX prefix selects a general purpose register.</td>
</tr>
<tr>
<td align="center">C </td>
<td align="left"> The reg field of the ModR/M byte selects a control register (for example, MOV (0F20, 0F22)).</td>
</tr>
<tr>
<td align="center">D </td>
<td align="left"> The reg field of the ModR/M byte selects a debug register (for example, MOV (0F21,0F23)).</td>
</tr>
<tr>
<td align="center">E </td>
<td align="left"> A ModR/M byte follows the opcode and specifies the operand. The operand is either a general-purpose register or a memory address. If it is a memory address, the address is computed from a segment register and any of the following values: a base register, an index register, a scaling factor, a displacement.</td>
</tr>
<tr>
<td align="center">F </td>
<td align="left"> EFLAGS/RFLAGS Register.</td>
</tr>
<tr>
<td align="center">G </td>
<td align="left"> The reg field of the ModR/M byte selects a general register (for example, AX (000)).</td>
</tr>
<tr>
<td align="center">H </td>
<td align="left"> The VEX.vvvv field of the VEX prefix selects a 128-bit XMM register or a 256-bit YMM register, determined by operand type. For legacy SSE encodings this operand does not exist, changing the instruction to destructive form.</td>
</tr>
<tr>
<td align="center">I </td>
<td align="left"> Immediate data: the operand value is encoded in subsequent bytes of the instruction.</td>
</tr>
<tr>
<td align="center">J </td>
<td align="left"> The instruction contains a relative offset to be added to the instruction pointer register (for example, JMP (0E9), LOOP).</td>
</tr>
<tr>
<td align="center">L </td>
<td align="left"> The upper 4 bits of the 8-bit immediate selects a 128-bit XMM register or a 256-bit YMM register, deter- mined by operand type. (the MSB is ignored in 32-bit mode)</td>
</tr>
<tr>
<td align="center">M </td>
<td align="left"> The ModR/M byte may refer only to memory (for example, BOUND, LES, LDS, LSS, LFS, LGS, CMPXCHG8B).</td>
</tr>
<tr>
<td align="center">N </td>
<td align="left"> The R/M field of the ModR/M byte selects a packed-quadword, MMX technology register.</td>
</tr>
<tr>
<td align="center">O </td>
<td align="left"> The instruction has no ModR/M byte. The offset of the operand is coded as a word or double word (depending on address size attribute) in the instruction. No base register, index register, or scaling factor can be applied (for example, MOV (A0–A3)).</td>
</tr>
<tr>
<td align="center">P </td>
<td align="left"> The reg field of the ModR/M byte selects a packed quadword MMX technology register.</td>
</tr>
<tr>
<td align="center">Q </td>
<td align="left"> A ModR/M byte follows the opcode and specifies the operand. The operand is either an MMX technology register or a memory address. If it is a memory address, the address is computed from a segment register and any of the following values: a base register, an index register, a scaling factor, and a displacement.</td>
</tr>
<tr>
<td align="center">R </td>
<td align="left"> The R/M field of the ModR/M byte may refer only to a general register (for example, MOV (0F20-0F23)).</td>
</tr>
<tr>
<td align="center">S </td>
<td align="left"> The reg field of the ModR/M byte selects a segment register (for example, MOV (8C,8E)).</td>
</tr>
<tr>
<td align="center">U </td>
<td align="left"> The R/M field of the ModR/M byte selects a 128-bit XMM register or a 256-bit YMM register, determined by operand type.</td>
</tr>
<tr>
<td align="center">V </td>
<td align="left"> The reg field of the ModR/M byte selects a 128-bit XMM register or a 256-bit YMM register, determined by operand type.</td>
</tr>
<tr>
<td align="center">W </td>
<td align="left"> A ModR/M byte follows the opcode and specifies the operand. The operand is either a 128-bit XMM register, a 256-bit YMM register (determined by operand type), or a memory address. If it is a memory address, the address is computed from a segment register and any of the following values: a base register, an index register, a scaling factor, and a displacement.</td>
</tr>
<tr>
<td align="center">X </td>
<td align="left"> Memory addressed by the DS:rSI register pair (for example, MOVS, CMPS, OUTS, or LODS).</td>
</tr>
<tr>
<td align="center">Y </td>
<td align="left"> Memory addressed by the ES:rDI register pair (for example, MOVS, CMPS, INS, STOS, or SCAS).</td>
</tr>
</tbody>
</table>


<ul>
<li>Codes for Operand Type</li>
</ul>


<table>
<thead>
<tr>
<th align="center">Code </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">a </td>
<td align="left"> Two one-word operands in memory or two double-word operands in memory, depending on operand-size attribute (used only by the BOUND instruction).</td>
</tr>
<tr>
<td align="center">b </td>
<td align="left"> Byte, regardless of operand-size attribute.</td>
</tr>
<tr>
<td align="center">c </td>
<td align="left"> Byte or word, depending on operand-size attribute.</td>
</tr>
<tr>
<td align="center">d </td>
<td align="left"> Doubleword, regardless of operand-size attribute.</td>
</tr>
<tr>
<td align="center">dq </td>
<td align="left"> Double-quadword, regardless of operand-size attribute.</td>
</tr>
<tr>
<td align="center">p </td>
<td align="left"> 32-bit, 48-bit, or 80-bit pointer, depending on operand-size attribute. pd 128-bit or 256-bit packed double-precision floating-point data.</td>
</tr>
<tr>
<td align="center">pi </td>
<td align="left"> Quadword MMX technology register (for example: mm0).</td>
</tr>
<tr>
<td align="center">ps </td>
<td align="left"> 128-bit or 256-bit packed single-precision floating-point data.</td>
</tr>
<tr>
<td align="center">q </td>
<td align="left"> Quadword, regardless of operand-size attribute.</td>
</tr>
<tr>
<td align="center">qq </td>
<td align="left"> Quad-Quadword (256-bits), regardless of operand-size attribute. s 6-byte or 10-byte pseudo-descriptor.</td>
</tr>
<tr>
<td align="center">sd </td>
<td align="left"> Scalar element of a 128-bit double-precision floating data.</td>
</tr>
<tr>
<td align="center">ss </td>
<td align="left"> Scalar element of a 128-bit single-precision floating data.</td>
</tr>
<tr>
<td align="center">si </td>
<td align="left"> Doubleword integer register (for example: eax).</td>
</tr>
<tr>
<td align="center">v </td>
<td align="left"> Word, doubleword or quadword (in 64-bit mode), depending on operand-size attribute.</td>
</tr>
<tr>
<td align="center">w </td>
<td align="left"> Word, regardless of operand-size attribute.</td>
</tr>
<tr>
<td align="center">x </td>
<td align="left"> dq or qq based on the operand-size attribute.</td>
</tr>
<tr>
<td align="center">y </td>
<td align="left"> Doubleword or quadword (in 64-bit mode), depending on operand-size attribute.</td>
</tr>
<tr>
<td align="center">z </td>
<td align="left"> Word for 16-bit operand-size or doubleword for 32 or 64-bit operand-size.</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Segmentation Protection in Intel Processor]]></title>
    <link href="http://ytliu.github.io/blog/2016/09/30/segmentation-protection-in-intel-processor/"/>
    <updated>2016-09-30T13:49:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/09/30/segmentation-protection-in-intel-processor</id>
    <content type="html"><![CDATA[<p>最近继续看Intel手册，第三卷的第3章和第5章，感觉又学到很多，包括一些之前一直困扰我的问题。这里做一个整理和总结吧。</p>

<!-- more -->


<p>这里先推荐一篇博文，<a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/">CPU Rings, Privilege, and Protection</a>，感觉写的非常好，思路很清晰。建议可以先阅读一下。</p>

<p>首先提一个问题，为什么在当前的Linux操作系统里面，用户态的程序不能访问内核的数据，不能执行内核的代码，同时不能执行一些特权指令呢？在回答这个问题之前，首先需要明白一个概念，到底什么是用户态和内核态。</p>

<h4>特权级（privilege levels）</h4>

<p>特权级是处理器硬件内部维护的一个状态，软件无法直接修改。Intel处理器一共有四个特权级，从高到低分别由0到3表示，即数字越低，表示特权越高，而每个数字即表示了当前CPU运行在哪个特权级上。一般情况下（特别是在64位系统中），系统只会用到这四个特权级中的两个，即0和3，其中0就是所谓的内核态，而3就是用户态。</p>

<p>所以说，一个程序运行在用户态的意思，就是该程序所运行的CPU里面的特权级的状态为3，内核态就表示运行内核的CPU的状态为0，仅此而已。当然，这个特权级会和其它的一些机制组合在一起，在触发某些操作的时候进行检查。这个会在之后详细说明。</p>

<h4>软件如何知道自己运行在哪个特权级上</h4>

<p>按道理来说，特权级是CPU内部的一个状态，软件是无法对它进行直接修改的。但是Intel为软件提供了一个机制，使得软件能够知道自己当前运行在哪个特权级上，简单来说，就是通过段寄存器<code>cs</code>来获得该信息。<code>cs</code>说白了就是一个16位的寄存器，长成这样：</p>

<p><img src="http://ytliu.info/images/2016-09-30-1.png" title="cs register" alt="cs register" /></p>

<p>也就是说，它最后两个bits就表示当前CPU所处的特权级状态。软件可以通过直接读取<code>cs</code>寄存器获取该信息：</p>

<figure class='code'><figcaption><span>read_cs.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">read_cs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cs</span><span class="p">;</span>
</span><span class='line'>  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;mov %%cs, %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">cs</span><span class="p">));</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cs</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果读出来最后两个bits是0，则表示运行在内核态，如果是3，则表示运行在用户态。</p>

<h4>基于特权级的保护机制</h4>

<p>有了特权级的概念，我们就可以比较清楚地了解Intel处理器本身提供的那些保护机制了，总体来说，该保护机制主要由三个部分组成。</p>

<ul>
<li>特权指令的执行</li>
<li>Memory的保护</li>
<li>I/O的保护</li>
</ul>


<p>对于I/O的保护，我们这里暂且不表，这里主要考虑的是前面两个部分。</p>

<h3>特权指令的执行</h3>

<p>在Intel的处理器中，一共有16条指令是用户态不能直接执行的（只有内核态可以执行），这些指令如下：</p>

<ul>
<li>LGDT — Load GDT register.</li>
<li>LLDT — Load LDT register.</li>
<li>LTR — Load task register.</li>
<li>LIDT — Load IDT register.</li>
<li>MOV (control registers) — Load and store control registers.</li>
<li>LMSW — Load machine status word.</li>
<li>CLTS — Clear task-switched flag in register CR0.</li>
<li>MOV (debug registers) — Load and store debug registers.</li>
<li>INVD — Invalidate cache, without writeback.</li>
<li>WBINVD — Invalidate cache, with writeback.</li>
<li>INVLPG —Invalidate TLB entry.</li>
<li>HLT— Halt processor.</li>
<li>RDMSR — Read Model-Specific Registers.</li>
<li>WRMSR —Write Model-Specific Registers.</li>
<li>RDPMC — Read Performance-Monitoring Counter.</li>
<li>RDTSC — Read Time-Stamp Counter.</li>
</ul>


<p>如果在CPL非0的状态下执行这些指令，将会产生一个general-protection exception (#GP) 。至于这些指令都是做什么的，这里也不一一解释了。</p>

<h3>Memory的保护</h3>

<p>这是这篇博文重点关注的内容，主要分为两个部分：Segmentation和Paging。</p>

<h4>段机制（Segmentation）</h4>

<p>下图是利用段机制将内存分成不同段（代码段，数据段等）的一个例子：</p>

<p><img src="http://ytliu.info/images/2016-09-30-2.png" title="Protected Flat Model" alt="segmentation" /></p>

<p>在这个设计中，有很多段寄存器，通过每个段寄存器可以分别找到其对应的段描述符，然后获得相应的段的基地址，大小，权限等信息。</p>

<p>下图是一个利用段机制寻址的例子：</p>

<p><img src="http://ytliu.info/images/2016-09-30-3.png" title="Logical Address to Linear Address Translation" alt="segmentation translation" /></p>

<p>段寻址，即给定一个logical address，将其转换为linear address，分为以下几步：</p>

<ul>
<li>第一，根据情况判断需要寻找的是什么类型的地址（代码？还是数据？由logical address中的segment selector获得）；</li>
<li>第二，根据所需类型，得到相应的段寄存器（<code>cs</code>，或者<code>ds</code>等）；</li>
<li>第三，通过段寄存处的第3位到底15位，得到一个特定的段描述符（segment descriptor）；</li>
<li>第四，根据描述符中的信息（base, limit, access）等，对该logical address进行检查，并且获得对应的linear address（base+offset)；</li>
</ul>


<p>下图是段选择子的示意图：</p>

<p><img src="http://ytliu.info/images/2016-09-30-4.png" title="Segment selector" alt="segment selector" /></p>

<p>段选择子会被存在段寄存器中，比如之前提到的<code>cs</code>，其中最低2位为RPL（Requested Privilege Level），不过要注意的是，<code>cs</code>段寄存器的最低位为CPL，其它的都是RPL。另外，第3位表示该从GDT还是LDT寻找对应的段描述符，后面的bits就是对应的index了。</p>

<p>下图是段描述符的示意图：</p>

<p><img src="http://ytliu.info/images/2016-09-30-5.png" title="Segment descriptor" alt="segment descriptor" /></p>

<p>这里不一一解释，可以直接去查Intel文档。总的来说，它就是定义了某个特定的段所对应的基地址，大小，以及相应的权限。这里最重要的权限位就是DPL（Descriptor privilege level），会在之后权限检查的时候使用。</p>

<p>需要声明的是，段寻址主要应用在32位的系统中，在64位的系统上，已经不再采用段寻址了，logical address即为linear address。但是这并不意味着段机制被关闭，段机制是通过设置<code>CR0</code>上的<code>PE flag</code>来开启的，在<code>PE flag</code>开启之后，除非将其清空，否则是无法关闭段保护机制的。这里所说的不用段寻址是指将那些不需要的段描述符的base和limit都设为0，同时如果不需要段机制保护的话也将相应的权限位清空即可。虽然如此，在64位的系统中，关于CPL的信息依然还能通过<code>cs</code>寄存器读取，而且<code>gs</code>和<code>fg</code>两个段寄存器被用作了其他用途。</p>

<p>关于段保护机制，主要是对前面提到的CPL，DPL和RPL进行检查，主要发生在以下三个场景中：</p>

<ul>
<li>当某个进程需要装载一个新的段选择子：</li>
</ul>


<p><img src="http://ytliu.info/images/2016-09-30-6.png" title="x86 Segment loading" alt="segment loading" /></p>

<p>它会判断当前的CPL和RPL是否权限都比相应的DPL的权限高（Max(CPL, RPL) &lt;= DPL），如果是，则允许加载新的段选择子，否则产生GP。</p>

<ul>
<li>当某个进程需要访问某个段中的内容：</li>
</ul>


<p><img src="http://ytliu.info/images/2016-09-30-7.png" title="x86 Segmentation data access" alt="segmentation data" /></p>

<p>该检查的逻辑同上。</p>

<ul>
<li>当某个进程中一个段的代码需要跳转到另外一个段的代码中。</li>
</ul>


<p>这个过程比较复杂，它的段描述符被称为门描述符（gate descriptor），一共有四种门描述符：<code>call-gate</code>，<code>interrupt-gate</code>，<code>trap-gate</code>，<code>task-gate</code>。每一种的检查都有一些细微的区别，但是总体的规则是差不多的，下图举了一个IDT（Interrupt Descriptor Table）的例子：</p>

<p><img src="http://ytliu.info/images/2016-09-30-8.png" title="Interrupt Descriptor with Privilege Check" alt="Interrupt-gate descriptor" /></p>

<p>这里有两个DPL，一个是<code>interrupt-gate</code>描述符中的DPL，还有一个是该门描述符中指向的目标代码段的DPL，在这里为0。在发生一个interrupt的时候，它需要检查CPL是否比目标代码段的DPL更低权限（即CPL >= DPL），因为interrupt不允许高权限往低权限跳转。另外，对于软件产生的interrupt，比如<code>int n</code>，还要再检查一下CPL是否比<code>interrupt-gate</code>描述符的DPL更高（即CPL &lt;= gate DPL）。否则用户态就可以任意调用interrupt了。</p>

<p>可以说，在64位系统上，关于数据访问的段保护机制已经完全由paging机制代替了，其它两个还会涉及到相应的检查。</p>

<h4>RPL (Request Privilege Level)</h4>

<p>最后来说一下为什么需要有<code>RPL</code>这个概念，它的主要作用是允许高特权级（比如内核态）的代码在为低特权级提供服务的时候，通过较低的权限来加载段。</p>

<p><a href="https://iambvk.wordpress.com/2007/10/10/notes-on-cpl-dpl-and-rpl-terms/">这里</a>举了一个例子：</p>

<p>假设有一个设备驱动跑在内核态，它为上层用户态进程提供了一个服务，即能够直接将一部分数据从磁盘拷贝到用户态进程的数据段。因此，用户态的进程需要将数据段的信息（如段选择子，地址和需要拷贝的数据大小）提供给该驱动。</p>

<p>由于该驱动在内核态，因此一个用户态的进程能够通过伪造数据段的信息，欺骗该驱动将数据拷贝到另一个内核态的数据段中。这种攻击就被称为权限提升（privilege escalation）。</p>

<p>那么，<code>RPL</code>是怎么解决这个问题的呢？</p>

<p>还是上面的例子，当驱动加载目标段的段选择子的时候，将其<code>RPL</code>修改成用户态的权限（即3）。由于数据段的检查逻辑保证<code>CPL &lt;= DPL</code>和<code>RPL &lt;= DPL</code>两个条件同时满足，因此上面提到的权限提升的攻击就会因为<code>RPL（3） &lt;= DPL（0）</code>而造成protection-fault。</p>

<p>所以说，这里的关键就是，当内核态的代码为用户态的进程提供服务的时候，应该要预先将其RPL所代表的权限暂时降低。</p>

<h4>回答开头的那个问题</h4>

<p>用户态的程序之所以不能访问内核的数据，不能执行内核的代码，同时不能执行一些特权指令，在32位系统中，这主要是由特权级、segmentation和paging机制共同决定的，而在64位系统中，这主要是由特权级和paging机制决定的。用户态的进程所能看到的页表，内核页对应页表项的权限位标记了S(upervisor)位，因此，当进程处于用户态时，<code>CPL</code>
为3，当然就不能访问内核数据，执行内核代码，以及执行特权指令了。</p>

<h3>总结</h3>

<p>最后总结一下，在64位系统还没有出来的时候，段机制是被广泛应用的。当64位出现，能够访问的地址空间变得特别大，就不需要再将内存划分成多个段进行管理了（否则复杂度增加），转而采用一种扁平化的模型（Flat model），另外，页表机制的出现，也使得不同权限级别之间的数据访问保护和隔离也不再需要段保护机制来做，而是直接通过设置页表项中的<code>U/S</code>, <code>R/W</code>, <code>P</code>, <code>NX</code>等权限位即可达到原来的目的。因此，segmentation这套机制，在64位系统中的利用价值就不如以前了。不过，如之前所说，<code>cs</code>段选择子依然可以帮助软件了解当前运行的特权级，<code>gs</code>, <code>fs</code>两个段选择子也另寻用处，这个就是后话了。另外，对于不同特权级之间的控制流转换，包括不同门描述符的利用，这个还是和原来的机制一样。因此，可以说segmentation这套机制在64位系统中依然还有用武之地，甚至我觉得它们可以找到一些新的利用场景，来优化当前的系统。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TLB的那些事儿]]></title>
    <link href="http://ytliu.github.io/blog/2016/09/16/tlbde-na-xie-shi-er/"/>
    <updated>2016-09-16T09:39:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/09/16/tlbde-na-xie-shi-er</id>
    <content type="html"><![CDATA[<p>这两天因为某些原因，好好地研究了一下Intel的手册，比较系统地学习了一下和TLB相关的知识。以下内容主要来自Intel手册第三卷的第4章，第11章和第28章。</p>

<!-- more -->


<p>我们知道，现在内存寻址基本采用的是页表翻译机制，即给定一个虚拟地址，经过2~4层页表，得到一个物理地址。虽然该过程一般由硬件（MMU）完成，但是也会有一定的延迟。因此，为了加速页表翻译的过程，一般的处理器都会有一个翻译信息的缓存机制，在Intel中，有两个相关的机制：<code>TLB</code>和<code>paging-structure cache</code>。</p>

<p>TLB，cache的关系如下图所示：</p>

<p><img src="http://ytliu.info/images/2016-09-16-1.png" title="Cache Structure of the Intel Core i7 Processors" alt="i7" /></p>

<p>当处理器在获取指令或者读取数据的时候，每当遇到一个虚拟地址，会首先通过TLB等地址翻译缓存机制查找该虚拟地址对应的物理地址，如果没有找到对应的条目，则通过内存翻译硬件机制<code>MMU</code>通过走页表的方式查找相应的物理地址，当得到确切的物理地址之后，则会通过cache找到物理地址对应的内存数据，如果cache中没有相应的数据，再去内存中读取。</p>

<h4>PCID</h4>

<p>在介绍<code>TLB</code>和<code>paging-structure cache</code>之前，有必要先提一下PCID。PCID的全称是<code>Process-Context Identifiers</code>，如果没有PCID，那么运行在处理器上的软件每次切换CR3，都会造成整个处理器的地址翻译缓存信息（包括<code>TLB</code>和<code>paging-structure cache</code>）被刷掉。而PCID则是优化了这一过程。可以这么说，每个进程有自己的一个PCID，这使得进程间的切换不用刷掉处理器中对应的地址翻译缓存信息。</p>

<p>每个进程的PCID由CR3的0:11共12个bits组成，只有在<code>CR4.PCIDE = 1</code>的情况下才有PCID一说，否则当前的PCID只能是<code>000H</code>。</p>

<p>当logical processor在<code>TLB</code>和<code>paging-structure cache</code>里面创建条目的时候，它会将该条目和当前的PCID挂钩，当翻译地址需要使用这些条目的时候，它也只会查找那些和当前PCID匹配的条目。</p>

<p>注：logical processor的数目一般和processor是一样的，不过当processor支持超线程（hyper-threading）的时候，每个processor上一般会有两个logical processor。</p>

<p>硬件enforce了以下两个关于PCID的规则：</p>

<ul>
<li>如果<code>IA32_EFER.LMA = 0</code>或者<code>CR3[11:0] != 000H</code>，则将<code>CR4.PCIDE</code>从0改为1会造成<code>general-protection exception (#GP)</code>；</li>
<li>如果<code>CR4.PCIDE = 1</code>，则将<code>CR0.PG</code>改为0会造成<code>general-protection exception</code>。</li>
</ul>


<h4>TLB</h4>

<p>TLBs的全称是<code>translation lookaside buffers</code>，它存储了<code>page number</code>（由虚拟地址的高位组成）到<code>page frame</code>（由虚拟地址的高位组成）的映射。另外，<code>page number</code>和<code>page offset</code>（由虚拟地址的地位组成）的界线由<code>page size</code>决定：</p>

<ul>
<li>32-bit paging

<ul>
<li>如果是大页（4M），则<code>page number</code>由虚拟地址的31:22位决定；</li>
<li>如果是普通页（4K），则<code>page number</code>由虚拟地址的31:12位决定。</li>
</ul>
</li>
<li>PAE paging

<ul>
<li>如果是大页（2M），则<code>page number</code>由虚拟地址的31:21位决定；</li>
<li>如果是普通页（4K），则<code>page number</code>由虚拟地址的31:12位决定。</li>
</ul>
</li>
<li>IA-32e paging

<ul>
<li>如果是超大页（1G），则<code>page number</code>由虚拟地址的47:30位决定；</li>
<li>如果是大页（2M），则<code>page number</code>由虚拟地址的47:21位决定；</li>
<li>如果是普通页（4K），则<code>page number</code>由虚拟地址的47:12位决定。</li>
</ul>
</li>
</ul>


<p>TLB中的每个条目存储了以下信息：</p>

<ul>
<li><code>page number</code>所对应的<code>page frame</code>；</li>
<li>在页表寻址过程中得到的访问权限：

<ul>
<li>The logical-AND of the R/W flags.</li>
<li>The logical-AND of the U/S flags.</li>
<li>The logical-OR of the XD flags (necessary only if IA32_EFER.NXE = 1).</li>
</ul>
</li>
<li>在页表寻址过程中得到的其它属性：

<ul>
<li>The dirty flag</li>
<li>The memory type</li>
</ul>
</li>
</ul>


<h4>Paging-Structure Caches</h4>

<p>除了TLB缓存虚拟地址到物理地址的映射之外，还有一个被称为<code>paging-structure cache</code>的机制，即用于缓存虚拟地址到某一个页表项地址的映射，包括：</p>

<ul>
<li>PML4 cache (IA-32e paging only)：缓存虚拟地址的47:39位到<code>PML4E</code>物理地址的映射；</li>
<li>PDPTE cache (IA-32e paging only)：缓存虚拟地址的47:30位到<code>PDPTE</code>物理地址的映射；</li>
<li>PDE cache：

<ul>
<li>For 32-bit paging，缓存虚拟地址的31:22位到<code>PDE</code>物理地址的映射；</li>
<li>For PAE paging，缓存虚拟地址的31:21位到<code>PDE</code>物理地址的映射；</li>
<li>For IA-32e paging，缓存虚拟地址的47:21位到<code>PDE</code>物理地址的映射；</li>
</ul>
</li>
</ul>


<h4>Global Pages</h4>

<p>除了可以用PCID标记特定的进程的地址翻译缓存信息之外，也可以通过global page的机制标记相应的地址翻译缓存信息。</p>

<p>首先，这需要CR4.PGE设置成1，之后，如果PTE（或者大页的最有一级页表项）中的<code>G bit</code>（即第8个bit）是1的话,则该TLB条目就被标记成global。需要注意的一点是，
global page这个标记对<code>paging-structure caches</code>不适用，它只能标记TLB中的条目。</p>

<p>logical processor可以通过被标记成global的TLB条目来翻译一个和当前PCID项不同的虚拟地址。</p>

<h4>翻译虚拟地址的步骤</h4>

<pre><code>* 如果在TLB中找到对应虚拟地址到物理地址的映射，则直接使用；
* 否则，在PDE cache中查找，如果有match，则获得相应的PTE的物理地址；
* 否则，在PDPTE cache中查找，如果有match，则获得相应的PDE的物理地址；
* 否则，在PML4 cache中查找，如果有match，则获得相应的PDPTE的物理地址；
* 否则，就直接从CR3中获得PML4的物理地址。
</code></pre>

<h4>其它需要注意的事项</h4>

<p>在寻址过程中，只有当四级页表中（对于IA32-e来说）每一个条目的<code>P flag</code>都是1，且所有的<code>reserved bits</code>都是0的情况下才会填上相应虚拟地址的TLB条目。<code>paging-structure cache</code>也类似。另外，在缓存该翻译信息之前，会先把<code>accessed flag</code>设置为1。</p>

<p>而且，对于prefetch和speculative execution造成的地址翻译也有可能被缓存下来。</p>

<p>另外一点很重要的是，如果软件修改了某一个相应的paging-structure条目，TLB和paging-structure cache里面的条目都可能还存在，这就需要开发者意思到这点，并且能够手动的调用相应的invalidate的指令。</p>

<p>另外还有一个有趣的问题是：Multiple Cached Entries for a Single Paging-Structure Entry，即同一个页表项可能会存在不同的地址翻译缓存，文中给出了两种可能造成该情况的场景：</p>

<ul>
<li>假设两个PML4E指向了同一个PDPT，因此对于这个PDPT中的任意一个PDPTE，都有可能会有两个<code>paging-structure cache</code>中的条目引用它，因为它们的虚拟地址项是不同的。</li>
<li>假设某个PML4E指向了PML4本身，这样，所有47:39位为0，或者47:30为0，或者47:21为0，以及47:12为0的这些虚拟地址都是指向PML4的物理地址，因此，PML4的物理地址就可能会有很多的<code>TLB</code>和<code>paging-structure cache</code>引用它。</li>
</ul>


<h4>TLBs and Paging-Structure Caches的invalidate机制</h4>

<p>以下操作会invalidate TLB和paging-structure cache相关的条目：</p>

<ul>
<li>INVLPG：一个参数：线性地址。该操作会invalidate所有和该线性地址和当前PCID相关的TLB和paging-structure cache条目，以及global TLB条目；</li>
<li>INVPCID：两个参数：INVPCID type 和 INVPCID descriptor。四种type:

<ul>
<li>Individual-address，即只invalidate一个特定的虚拟地址翻译；</li>
<li>Single-context，即只invalidate某个PCID相关的所有的虚拟地址翻译；</li>
<li>All-context, including globals，即可以invalidate掉所有PCID对应的虚拟地址翻译，包括global page标记的TLB条目；</li>
<li>All-context，同上，但是不能invalidate掉global page标记的TLB条目；</li>
</ul>
</li>
<li>MOV to CR0：如果将<code>CR0.PG</code>从1变成0，将会invalidate所有PCID的<code>TLB</code>和<code>paging-structure cache</code>的条目，包括global；</li>
<li>MOV to CR3：

<ul>
<li>如果<code>CR4.PCIDE</code>为0，会invalidate<code>PCID</code>为000H的<code>TLB</code>和<code>paging-structure cache</code>的条目，不包含global；</li>
<li>If <code>CR4.PCIDE</code>为1，且源地址的第63位为0，将源地址的第11:0位作为PCID，invalidate掉相应PCID的<code>TLB</code>和<code>paging-structure cache</code>条目；</li>
<li>If <code>CR4.PCIDE</code>为1，且源地址的第63位为1，则不会invalidate任何条目；</li>
</ul>
</li>
<li>MOV to CR4：

<ul>
<li>如果它修改了<code>CR4.PGE</code>的值，或者将<code>CR4.PCID</code>的值从1改成0，则invalidate所有<code>TLB</code>和<code>paging-structure cache</code>的条目，包含global；</li>
<li>如果它修改了<code>CR4.PAE</code>的值，或者将<code>CR4.SMEP</code>的值从0改为1，则invalidate当前PCID的<code>TLB</code>和<code>paging-structure cache</code>的条目。</li>
</ul>
</li>
<li>Task switch：如果task switch修改了CR3的值，则将PCID为000H的<code>TLB</code>和<code>paging-structure cache</code>的条目进行invalidate。</li>
<li>page fault exception会invalidate和造成page fault相关的虚拟地址所对应的<code>TLB</code>和<code>paging-structure cache</code>的条目。</li>
</ul>


<h4>多核相关</h4>

<p>在多核环境中，当某个核修改了相应的地址翻译信息需要进行invalidation的时候，也需要考虑其它核的<code>TLB</code>和<code>paging-structure cache</code>的缓存了相关的条目。这种地址翻译修改的传递被称为<code>TLB shootdown</code>，该过程一般是通过<code>memory-based semaphores</code>或者<code>interprocessor interrupts (IPI)</code>。文中给了一个低效的实现方案：</p>

<pre><code>* 除了当前的logical processor之外，暂停其它所有的logical processor；
* 让当前的logical processor修改相应的地址翻译信息；
* 让所有的logical processor invalidate相应的`TLB`和`paging-structure cache`条目；
* 恢复所有logical processor的执行。
</code></pre>

<p>当然可能会有一些优化的方案，但是需要考虑很多情况，这里就不详细介绍了。</p>

<h4>虚拟化相关</h4>

<p>虚拟化环境增加了一层额外的地址翻译，EPT。同时由于在CPU中多了一个root和non-root模式，因此增加了一个virtual processor的概念，相应的，在地址翻译缓存这块也就多增加了一个<code>virtual-processor identifiers（VPID）</code>的机制进行优化。</p>

<p>在一般情况下，如果发生VMX transition（即vmexit或者vmenter），则会invalidate相应logical processor的TLB，加入了VPID的特性，每个logical processor就可以同时管理多个线性地址空间的TLB，而不需要每次发生VMX transition的时候都invalidate。</p>

<p>VPID在以下三种情况下为000H：</p>

<pre><code>* Outside VMX operation.
* In VMX root operation.
* In VMX non-root operation when the “enable VPID” VM-execution control is 0.
</code></pre>

<p>当VMCS的<code>VM-execution control</code>中<code>enable VPID</code>被设为1的时候，VMX non-root模式下VPID由当前logical processor中VMCS的<code>VM-execution control</code>的VPID域来决定。</p>

<p>另外，VPID和PCID是可以同时被使用的。</p>

<p>在EPT被开启的情况下，<code>TLB</code>和<code>paging-structure cache</code>中可能会缓存以下信息：</p>

<ul>
<li>Guest-physical mappings，包括了<code>guest-physical page number</code>到<code>physical page frame</code>的映射（存储在<code>TLB</code>中），以及guest-physiaddress的高位到EPT页表页的物理地址的映射（存储在<code>paging-structure cache</code>中）；</li>
<li>Combined mappings，包括了<code>linear page number</code>到<code>physical page frame</code>的映射（存储在<code>TLB</code>中），以及<code>linear page number</code>到相应页表页的物理地址的映射（存储在<code>paging-structure cache</code>中）。</li>
</ul>


<p>除此之外还有一个叫做<code>linear mapping</code>，在EPT开启的情况下不会被缓存，它主要映射了线性地址的映射，和非硬件虚拟化的TLB机制类似。</p>

<p>在地址翻译缓存条目的创建和使用过程中，可能会涉及到PCID，VPID和EP4TA（即EPT-PML4-table，表示当前EPTP第51:12位的值）。</p>

<p>在和虚拟化相关的TLB invalidation中，相关的操作如下所示：</p>

<ul>
<li>和VMX不相关的invalidation指令（如INVLPG和INVPCID），会invalidate当前VPID的<code>linear mappings</code>和<code>combined mappings</code>；</li>
<li>EPT violation会invalidate当前EP4TA相关的<code>guest-physical mappings</code>，以及和该guest-physical address相应的linear address的<code>combined mappings</code>；</li>
<li>如果<code>enable VPID</code>位为0，VM entries和VM exits会invalidate掉VPID为0000H的所有<code>linear mappings</code>和<code>combined mappings</code>；</li>
<li>INVVPID指令，会invalidate掉<code>linear mappings</code>和<code>combined mappings</code>。带两个参数：INVVPID type 和 INVVPID descriptor。四种type:

<ul>
<li>Individual-address，即只invalidate一个特定的虚拟地址翻译；</li>
<li>Single-context，即只invalidate某个VPID相关的所有的虚拟地址翻译；</li>
<li>All-context，即可以invalidate掉所有VPID（除了000H）对应的虚拟地址翻译；</li>
<li>Single-context-retaining-globals，同single-context，但是不能invalidate掉global page标记的TLB条目；</li>
</ul>
</li>
<li>INVEPT指令，会invalidate掉<code>guest-physical mappings</code>和<code>combined mappings</code>。带两个参数：INVEPT type 和 INVEPT descriptor。两种type:

<ul>
<li>Single-context，即只invalidate某个EP4TA相关的所有的虚拟地址翻译；

<ul>
<li>All-context，即可以invalidate所有EP4TA相关的所有的虚拟地址翻译；</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内存初始化（C语言部分）]]></title>
    <link href="http://ytliu.github.io/blog/2016/03/15/linuxnei-cun-chu-shi-hua-c/"/>
    <updated>2016-03-15T11:04:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/03/15/linuxnei-cun-chu-shi-hua-c</id>
    <content type="html"><![CDATA[<p>这篇博客接着<a href="http://ytliu.info/blog/2016/03/14/linuxnei-cun-chu-shi-hua-assembly/">上篇博客</a>，继续介绍Linux内核启动过程中内存的初始化过程。</p>

<p>相比于汇编代码，分析C代码有一个优势，因为在之前的汇编代码中已经开启了分页模式，所以可以通过一些symbol直接在某些函数上设置断点，然后通过gdb进行调试。如何用gdb调试内核可以参考<a href="http://ytliu.info/blog/2014/10/22/debugging-linux-kernel-using-gdb-and-qemu/">这篇博客</a>。</p>

<!-- more -->


<h3>进入x86_64_start_kernel</h3>

<p>之前我们讲到，在<code>secondary_startup_64</code>最后，我们通过far return进入了C语言实现的函数<code>x86_64_start_kernel</code>，那么这篇我们就从这个函数开始讲起。</p>

<p>这个函数在<code>arch/x86/kernel/head64.c</code>文件中，该函数有一个参数，是<code>char * real_mode_data</code>，这个参数是在之前通过<code>movq  %rsi, %rdi</code>传进来的。</p>

<p>在该函数的开头，先做了一些sanity检查：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Build-time sanity checks on the kernel image and module</span>
</span><span class='line'><span class="cm">   * area mappings. (these are purely build-time and produce no code)</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MODULES_VADDR</span> <span class="o">&lt;</span> <span class="n">__START_KERNEL_map</span><span class="p">);</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MODULES_VADDR</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">&lt;</span> <span class="n">KERNEL_IMAGE_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MODULES_LEN</span> <span class="o">+</span> <span class="n">KERNEL_IMAGE_SIZE</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">PUD_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">__START_KERNEL_map</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">MODULES_VADDR</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PMD_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">MODULES_VADDR</span> <span class="o">&gt;</span> <span class="n">__START_KERNEL</span><span class="p">));</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(((</span><span class="n">MODULES_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PGDIR_MASK</span><span class="p">)</span> <span class="o">==</span>
</span><span class='line'>        <span class="p">(</span><span class="n">__START_KERNEL</span> <span class="o">&amp;</span> <span class="n">PGDIR_MASK</span><span class="p">)));</span>
</span><span class='line'>  <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">__end_of_fixed_addresses</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MODULES_END</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要是针对Module地址的检查（module被映射在<code>0xffffffffa0000000</code>上面）。</p>

<p>之后做了一个操作，将之前建立的<code>identity-map</code>给清除掉了，因为我们现在已经用高地址进行页表翻译了，所以那个identity-map也就没有用了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Wipe all early page tables except for the kernel symbol map */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">reset_early_page_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTRS_PER_PGD</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">early_level4_pgt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pgd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">next_early_pgt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">write_cr3</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">early_level4_pgt</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Kill off the identity-map trampoline */</span>
</span><span class='line'>  <span class="n">reset_early_page_tables</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里有一个<code>__pa(early_level4_pgt)</code>，我们来看一下<code>__pa</code>的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__phys_addr_nodebug</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* use the carry flag to determine if x was &lt; __START_KERNEL_map */</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="n">phys_base</span> <span class="o">:</span> <span class="p">(</span><span class="n">__START_KERNEL_map</span> <span class="o">-</span> <span class="n">PAGE_OFFSET</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define __phys_addr(x)  __phys_addr_nodebug(x)</span>
</span><span class='line'><span class="cp">#define __pa(x)   __phys_addr((unsigned long)(x))</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后调用<code>clear_bss</code>，即将bss中的内容清零：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Don&#39;t add a printk in there. printk relies on the PDA which is not initialized </span>
</span><span class='line'><span class="cm">   yet. */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">clear_bss</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">__bss_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__bss_stop</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">__bss_start</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* clear bss before set_intr_gate with early_idt_handler */</span>
</span><span class='line'>  <span class="n">clear_bss</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后创建idtr gate：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_load_idt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="n">dtr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&quot;lidt %0&quot;</span><span class="o">::</span><span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">dtr</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define load_idt(dtr) native_load_idt(dtr)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_EXCEPTION_VECTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">set_intr_gate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">early_idt_handlers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">load_idt</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">desc_ptr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">idt_descr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后调用<code>copy_bootdata</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">copy_bootdata</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">real_mode_data</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span> <span class="n">command_line</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmd_line_ptr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_params</span><span class="p">,</span> <span class="n">real_mode_data</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">boot_params</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sanitize_boot_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_params</span><span class="p">);</span>
</span><span class='line'>  <span class="n">cmd_line_ptr</span> <span class="o">=</span> <span class="n">get_cmd_line_ptr</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">cmd_line_ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">command_line</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">cmd_line_ptr</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">,</span> <span class="n">command_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">copy_bootdata</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">real_mode_data</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里面主要是copy一些boot的参数，之后调用<code>load_ucode_bsp</code>和<code>early_printk</code>，这里都不详述。</p>

<p>然后设置<code>init_level4_pgt</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">clear_page</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* set init_level4_pgt kernel high mapping*/</span>
</span><span class='line'>  <span class="n">init_level4_pgt</span><span class="p">[</span><span class="mi">511</span><span class="p">]</span> <span class="o">=</span> <span class="n">early_level4_pgt</span><span class="p">[</span><span class="mi">511</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>后来还有一些函数调用和boot相关的，这里也不细说，最后调用<code>start_kernel</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">x86_64_start_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">real_mode_data</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">x86_64_start_reservations</span><span class="p">(</span><span class="n">real_mode_data</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">x86_64_start_reservations</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">real_mode_data</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">start_kernel</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>start_kernel</h3>

<p>下面进入<code>start_kernel</code>函数，该函数定义在<code>init/main.c</code>文件中。</p>

<p>里面调用了很多函数来做各种目的的初始化，其中和内存初始化相关的函数调用如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">setup_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">);</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">setup_per_cpu_areas</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">build_all_zonelist</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">page_alloc_init</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">mm_init</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">setup_per_cpu_pageset</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如下图所示（截图自<a href="http://guojing.me/linux-kernel-architecture/posts/init-mm-management/">这里</a>)：</p>

<p><img src="http://ytliu.info/images/2016-03-15-1.png" title="start kernel" alt="start_kernel" /></p>

<p>下面我们逐个函数进行介绍。</p>

<h4>setup_arch</h4>

<p>x86的<code>setup_arch</code>定义在<code>arch/x86/kernel/setup.c</code>文件中，其中和内存初始化相关的函数如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_arch</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cmdline_p</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">setup_memory_map</span><span class="p">();</span>
</span><span class='line'>  <span class="n">e820_reserve_setup_data</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">init_mm</span><span class="p">.</span><span class="n">start_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_text</span><span class="p">;</span>
</span><span class='line'>  <span class="n">init_mm</span><span class="p">.</span><span class="n">end_code</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_etext</span><span class="p">;</span>
</span><span class='line'>  <span class="n">init_mm</span><span class="p">.</span><span class="n">end_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_edata</span><span class="p">;</span>
</span><span class='line'>  <span class="n">init_mm</span><span class="p">.</span><span class="n">brk</span> <span class="o">=</span> <span class="n">_brk_end</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">e820_add_kernel_range</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">cleanup_highmap</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">init_mem_mapping</span><span class="p">();</span>
</span><span class='line'>  <span class="n">early_trap_pf_init</span><span class="p">();</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">x86_init</span><span class="p">.</span><span class="n">paging</span><span class="p">.</span><span class="n">pagetable_init</span><span class="p">();</span> <span class="c1">// native_pagetable_init() -&gt; paging_init (arch/x86/mm/init_64.c)</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，前面一直是在通过BIOS获得E820内存分布（e820请查阅<a href="http://ytliu.info/blog/2015/07/30/xende-qi-dong-zhi-nei-cun-xiang-guan-shi-xian/">这篇博客</a>)，以及初始化<code>init_mm</code>。我们从<code>cleanup_highmap</code>开始分析，该函数在<code>arch/x86/mm/init_64.c</code>中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * The head.S code sets up the kernel high mapping:</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> *   from __START_KERNEL_map to __START_KERNEL_map + size (== _end-_text)</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * phys_base holds the negative offset to the kernel, which is added</span>
</span><span class='line'><span class="cm"> * to the compile time generated pmds. This results in invalid pmds up</span>
</span><span class='line'><span class="cm"> * to the point where we hit the physaddr 0 mapping.</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * We limit the mappings to the region from _text to _brk_end.  _brk_end</span>
</span><span class='line'><span class="cm"> * is rounded up to the 2MB boundary. This catches the invalid pmds as</span>
</span><span class='line'><span class="cm"> * well, as they are located before _text:</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">cleanup_highmap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">__START_KERNEL_map</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr_end</span> <span class="o">=</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">KERNEL_IMAGE_SIZE</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_brk_end</span><span class="p">,</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">level2_kernel_pgt</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Native path, max_pfn_mapped is not set yet.</span>
</span><span class='line'><span class="cm">   * Xen has valid max_pfn_mapped set in</span>
</span><span class='line'><span class="cm">   *  arch/x86/xen/mmu.c:xen_setup_kernel_pagetable().</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">max_pfn_mapped</span><span class="p">)</span>
</span><span class='line'>    <span class="n">vaddr_end</span> <span class="o">=</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(;</span> <span class="n">vaddr</span> <span class="o">+</span> <span class="n">PMD_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">vaddr_end</span><span class="p">;</span> <span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PMD_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
</span><span class='line'>      <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">_text</span> <span class="o">||</span> <span class="n">vaddr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'>      <span class="n">set_pmd</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">__pmd</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码非常好理解，加上看注释，可以知道其功能就是将小于<code>_text</code>和大于<code>_brk_end</code>的地址都从页表中unmap掉。</p>

<p>接下来是<code>init_mem_mapping</code>这个函数，该函数位于<code>arch/x86/mm/init.c</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_mem_mapping</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">end</span> <span class="o">=</span> <span class="n">max_pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* the ISA range is always mapped regardless of memory holes */</span>
</span><span class='line'>  <span class="n">init_memory_mapping</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ISA_END_ADDRESS</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">memory_map_top_down</span><span class="p">(</span><span class="n">ISA_END_ADDRESS</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">max_pfn</span> <span class="o">&gt;</span> <span class="n">max_low_pfn</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* can we preseve max_low_pfn ?*/</span>
</span><span class='line'>    <span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">max_pfn</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">load_cr3</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
</span><span class='line'>  <span class="n">__flush_tlb_all</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">early_memtest</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_pfn_mapped</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里面虽然代码少，但是信息量还是蛮大的，我们一个一个来看。</p>

<p>首先是<code>init_memory_mapping</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Setup the direct mapping of the physical memory at PAGE_OFFSET.</span>
</span><span class='line'><span class="cm"> * This runs before bootmem is initialized and gets pages directly from</span>
</span><span class='line'><span class="cm"> * the physical memory. To access them they are temporarily mapped.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init_refok</span> <span class="nf">init_memory_mapping</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
</span><span class='line'>                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">map_range</span> <span class="n">mr</span><span class="p">[</span><span class="n">NR_RANGE_MR</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">nr_range</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;init_memory_mapping: [mem %#010lx-%#010lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>         <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mr</span><span class="p">));</span>
</span><span class='line'>  <span class="n">nr_range</span> <span class="o">=</span> <span class="n">split_mem_range</span><span class="p">(</span><span class="n">mr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_range</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">kernel_physical_mapping_init</span><span class="p">(</span><span class="n">mr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">mr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">,</span>
</span><span class='line'>               <span class="n">mr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page_size_mask</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">add_pfn_range_mapped</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">ret</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注释中提到的<code>PAGE_OFFSET</code>值为<code>0xffff880000000000</code>（<code>0xffff880000000000</code>到<code>0xffffc7ffffffffff</code>为所有物理地址的direct mapping）。</p>

<p>这里有两个主要的函数，我们先来看<code>split_mem_range</code>（位于<code>arch/x86/mm/init.c</code>）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="nf">split_mem_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_range</span> <span class="o">*</span><span class="n">mr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_range</span><span class="p">,</span>
</span><span class='line'>             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
</span><span class='line'>             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>里面代码比较复杂，和之前在分析xen代码中某个函数有点像，这里就不逐段分析。简单说一下它做了什么吧。<code>split_mem_range</code>的作用就是将整个物理地址段进行了一个分类，把所有地址分为三类：</p>

<ul>
<li>大于1G的地址段</li>
<li>2M到1G的地址段</li>
<li>其它</li>
</ul>


<p>然后将<code>start</code>到<code>end</code>的物理地址段分别塞进这些段中，然后将每个段的信息保存在<code>mr</code>这个数据结构中。这个数据结构包括了每个地址段的起始地址、结束地址、以及alignment。最后有一个merge过程，将<code>mr</code>中相邻且alignment相同的项进行合并。</p>

<p>最后分出来的地址段的结果如下图所示：</p>

<p><img src="http://ytliu.info/images/2016-03-15-2.png" title="split_mem_range" alt="split_mem_range" /></p>

<p>另外一个函数为<code>kernel_physical_mapping_init</code>（位于<code>arch/x86/mm/init_64.c</code>）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__meminit</span>
</span><span class='line'><span class="nf">kernel_physical_mapping_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
</span><span class='line'>           <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
</span><span class='line'>           <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_size_mask</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">bool</span> <span class="n">pgd_changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">,</span> <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span><span class='line'>  <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
</span><span class='line'>  <span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="n">PGDIR_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">PGDIR_SIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pgd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">pud</span> <span class="o">=</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">);</span>
</span><span class='line'>      <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pud_init</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
</span><span class='line'>             <span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">page_size_mask</span><span class="p">);</span>
</span><span class='line'>      <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pud</span> <span class="o">=</span> <span class="n">alloc_low_page</span><span class="p">();</span>
</span><span class='line'>    <span class="n">last_map_addr</span> <span class="o">=</span> <span class="n">phys_pud_init</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">__pa</span><span class="p">(</span><span class="n">end</span><span class="p">),</span>
</span><span class='line'>             <span class="n">page_size_mask</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pgd_populate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">pud</span><span class="p">);</span>
</span><span class='line'>    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">page_table_lock</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pgd_changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">pgd_changed</span><span class="p">)</span>
</span><span class='line'>    <span class="n">sync_global_pgds</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">__flush_tlb_all</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">last_map_addr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个非常关键的函数，它的作用就是填充页表，将所有之前探寻到并且分割好的物理地址映射到对应的虚拟内存中，并在页表中体现出来。我们来逐段分析：</p>

<p>首先通过<code>__va</code>这个宏将物理地址转换成其对应的（direct mapping）虚拟地址，即加上<code>0xffff880000000000</code>。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span><span class='line'>  <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后就是传统的走页表过程了，这里有个宏需要说明：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define swapper_pg_dir init_level4_pgt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">mm_struct</span> <span class="n">init_mm</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">.</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">swapper_pg_dir</span><span class="p">,</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define pgd_offset(mm, address) ((mm)-&gt;pgd + pgd_index((address)))</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define pgd_offset_k(address) pgd_offset(&amp;init_mm, (address))</span>
</span><span class='line'>
</span><span class='line'><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，在这个时候，pgt_dir从原来的<code>early_level4_pgt</code>变成了<code>init_level4_pgt</code>，这个数据结构同样是在<code>arch/x86/kernel/head_64.S</code>中定义的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span>   <span class="n">level3_ident_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_KERNPG_TABLE</span>
</span><span class='line'>  <span class="p">.</span><span class="n">org</span>    <span class="n">init_level4_pgt</span> <span class="o">+</span> <span class="n">L4_PAGE_OFFSET</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span>   <span class="n">level3_ident_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_KERNPG_TABLE</span>
</span><span class='line'>  <span class="p">.</span><span class="n">org</span>    <span class="n">init_level4_pgt</span> <span class="o">+</span> <span class="n">L4_START_KERNEL</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>  <span class="cm">/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span>   <span class="n">level3_kernel_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_PAGE_TABLE</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level3_ident_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level2_ident_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_KERNPG_TABLE</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">511</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level2_ident_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="cm">/* Since I easily can, map the first 1G.</span>
</span><span class='line'><span class="cm">   * Don&#39;t set NX because code runs from these pages.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">PMDS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">__PAGE_KERNEL_IDENT_LARGE_EXEC</span><span class="p">,</span> <span class="n">PTRS_PER_PMD</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，加上<code>init_level4_pgt</code>这个页表后，内存的分布图如下所示：</p>

<p><img src="http://ytliu.info/images/2016-03-15-3.png" title="init level4 pgt" alt="init level4 pgt" /></p>

<p>所以<code>kernel_physical_mapping_init</code>后面的代码就是根据不同<code>mr</code>数据结构中的地址段将这个页表进行填充，这里就不详述了。</p>

<p>在执行完<code>init_memory_mapping</code>之后，<code>init_mem_mapping</code>函数又执行了一个<code>memory_map_top_down</code>函数，里面其实也是根据不同的地址段，连续调用<code>init_range_memory_mapping</code>，从而间接调用<code>init_memory_mapping</code>函数。</p>

<p>最后，将<code>swapper_pg_dir</code>加载进<code>cr3</code>，完成页表的转换。</p>

<p>现在让我们回到<code>setup_arch</code>，调用<code>paging_init</code>（位于<code>arch/x86/mm/init_64.c</code>）。里面主要完成一些zones的初始化，不详述。</p>

<p>再次回到<code>start_kernel</code>，在<code>setup_arch</code>之后还陆续调用了几个和percpu以及memory zones，memory allocator相关的函数，这里也不详细说了。</p>

<p>这个系列就先简单介绍到这里，其实后面还有很多内容没有详细介绍，主要目的是搞清楚内核是如何创建页表的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内存初始化（汇编部分）]]></title>
    <link href="http://ytliu.github.io/blog/2016/03/14/linuxnei-cun-chu-shi-hua-assembly/"/>
    <updated>2016-03-14T20:47:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/03/14/linuxnei-cun-chu-shi-hua-assembly</id>
    <content type="html"><![CDATA[<p>之前有几篇博客详细介绍了Xen的内存初始化，确实感觉这部分内容蛮复杂的。这两天在看Linux内核启动中内存的初始化，也是看的云里雾里的，想尝试下边看边写，在写博客的过程中慢慢思考，最后也能把自己的思考分享给其它人。</p>

<!-- more -->


<p>这个系列主要分为两个部分，汇编部分和<a href="http://ytliu.info/blog/2016/03/15/linuxnei-cun-chu-shi-hua-c/">C语言部分</a>。</p>

<p>这篇博文主要介绍的是汇编部分。</p>

<p>注：这两篇博文介绍的都是64位系统。</p>

<h3>内核解压缩过程</h3>

<p>这个过程就不详述了，整个Linux内核是作为一个压缩过的镜像提供的，在执行内核代码之前，首先需要bootloader对其进行一个解压缩，对这部分有兴趣可以参看<a href="http://blog.sina.com.cn/s/blog_b02f77c80101db1t.html">这篇博客</a>。</p>

<h3>最初的页表什么样？</h3>

<p>解压结束后，会进行一个对elf格式的parse，然后对内核进行加载，最后进入<code>arch/x86/kernel/head_64.S</code>中的<code>startup_64</code>。</p>

<p><code>startup_64</code>主要完成分页功能启用，最后跳入C代码x86_64_start_kernel。在开始分析代码之前，我们要先来看看在内核的数据段中，初始化页表是长怎么样的？</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">__INITDATA</span>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">early_level4_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">511</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level3_kernel_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_PAGE_TABLE</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">early_dynamic_pgts</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">512</span><span class="o">*</span><span class="n">EARLY_DYNAMIC_PAGE_TABLES</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">.</span><span class="n">data</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">init_level4_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">512</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level3_kernel_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="n">L3_START_KERNEL</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>  <span class="cm">/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level2_kernel_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_KERNPG_TABLE</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level2_fixmap_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_PAGE_TABLE</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level2_kernel_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="n">PMDS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">__PAGE_KERNEL_LARGE_EXEC</span><span class="p">,</span>
</span><span class='line'>    <span class="n">KERNEL_IMAGE_SIZE</span><span class="o">/</span><span class="n">PMD_SIZE</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level2_fixmap_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">506</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level1_fixmap_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_PAGE_TABLE</span>
</span><span class='line'>  <span class="cm">/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">level1_fixmap_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">512</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段数据结构还是比较清楚的，你把下面这两个宏<code>NEXT_PAGE</code>和<code>PMDS</code>代入上面的数据结构：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define NEXT_PAGE(name) \</span>
</span><span class='line'><span class="cp">  .balign PAGE_SIZE; \</span>
</span><span class='line'><span class="cp">GLOBAL(name)</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* Automate the creation of 1 to 1 mapping pmd entries */</span>
</span><span class='line'><span class="cp">#define PMDS(START, PERM, COUNT)      \</span>
</span><span class='line'><span class="cp">  i = 0 ;           \</span>
</span><span class='line'><span class="cp">  .rept (COUNT) ;         \</span>
</span><span class='line'><span class="cp">  .quad (START) + (i &lt;&lt; PMD_SHIFT) + (PERM) ; \</span>
</span><span class='line'><span class="cp">  i = i + 1 ;         \</span>
</span><span class='line'><span class="cp">  .endr</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们就可以很轻易地画出下面这张图：</p>

<p><img src="http://ytliu.info/images/2016-03-14-1.png" title="Linux early page table in boot" alt="early page table" /></p>

<p>后面的初始化过程，就是建立在这个早期的页表结构中的。</p>

<h3>正式进入startup_64</h3>

<p>我们一段段来分析：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">startup_64:</span>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Compute the delta between the address I am compiled to run at and the</span>
</span><span class='line'><span class="cm">   * address I am actually running at.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="n">_text</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'>  <span class="n">subq</span>  <span class="err">$</span><span class="n">_text</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span><span class="p">,</span> <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Is the address not 2M aligned? */</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">andl</span>  <span class="err">$</span><span class="o">~</span><span class="n">PMD_PAGE_MASK</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">testl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">jnz</span> <span class="n">bad_address</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Is the address too large?</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="n">_text</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">shrq</span>  <span class="err">$</span><span class="n">MAX_PHYSMEM_BITS</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">jnz</span> <span class="n">bad_address</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的这段代码非常奇怪：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">leaq</span>  <span class="n">_text</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rbp</span>
</span><span class='line'>  <span class="n">subq</span>  <span class="err">$</span><span class="n">_text</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span><span class="p">,</span> <span class="o">%</span><span class="n">rbp</span>
</span></code></pre></td></tr></table></div></figure>


<p>我想了好久，现在终于在Liangpig的指导下有了点眉目。（不确定的）解释如下：</p>

<p>首先<code>leaq  _text(%rip), %rbp</code>是一个相对寻址的指令，其并不是直接将<code>_text</code>的地址和当前<code>%rip</code>的值相加，而是<code>%rip</code>加上一个<code>_text</code>和它的相对地址，其实就是<code>$-7</code>（因为该地址的长度为7，而当前的<code>%rip</code>就是<code>_text</code>地址加上<code>7</code>），这个相对值是在link的时候计算出来的，可以参看<a href="http://stackoverflow.com/questions/9354941/retrieving-data-in-x86-64">这个问题</a>和<a href="http://stackoverflow.com/questions/3250277/how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program">这个问题</a>。</p>

<p>这里另外需要注意的一点是，在当前这个时候，计算机还是通过实模式进行寻址的，所以内核的代码应该是被load到了一个低地址（而不是大于<code>0xffffffff8000000</code>的地址），因此，<code>%rbp</code>存储的也是一个低地址，表示的是内核的代码段被实际装载到内存到的地址，让我们假设是<code>0x3000000</code>。</p>

<p>那么<code>$_text - __START_KERNEL_map</code>是什么呢？我们来看下面的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define __START_KERNEL_map _AC(0xffffffff80000000, UL)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define __PHYSICAL_START  ALIGN(CONFIG_PHYSICAL_START, \</span>
</span><span class='line'><span class="cp">                        CONFIG_PHYSICAL_ALIGN)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define __START_KERNEL  (__START_KERNEL_map + __PHYSICAL_START)</span>
</span><span class='line'>
</span><span class='line'><span class="n">SECTIONS</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">.</span> <span class="o">=</span> <span class="n">__START_KERNEL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">.</span><span class="n">text</span> <span class="o">:</span> <span class="n">AT</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">LOAD_OFFSET</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_text</span> <span class="o">=</span> <span class="p">.;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#define </span>
</span></code></pre></td></tr></table></div></figure>


<p>首先，<code>__START_KERNEL_map</code>是<code>0xffffffff80000000</code>，即内核代码和数据段在64位的虚拟地址空间中的最低地址段（<code>0xffffffff80000000</code>到<code>0xffffffffa0000000</code>这512MB的虚拟机之空间映射了内核段）。而<code>_text</code>表示的是<code>__START_KERNEL_map</code>加上了一段编译过程中指定的地址，在我机器内核的<code>.config</code>文件中为<code>0x1000000</code>。也就是说，如果<code>__START_KERNEL_map</code>映射的是物理地址为<code>0</code>的内存的话，那么在编译中我们期望的真正的物理地址就为<code>0x1000000</code>，也就是说，<code>$_text - __START_KERNEL_map</code>表示的是我们在编译过程中期望的内核段被装载到内存的起始地址，因此<code>subq  $_text - __START_KERNEL_map, %rbp</code>表示将当前内核段真实被装载到内存中的地址和编译过程中期望被装载到内存中的地址的差值赋值给<code>%rbx</code>，在我们的例子中即为<code>0x2000000</code>（<code>0x3000000</code> - <code>0x1000000</code>）。</p>

<p>之后我们就对这个真实被装载到内存中的地址做一些检查，包括是否2M对齐，以及有没有超过最大大小等等，这里就不详述了。</p>

<p>然后做的一件事就是调整初始化页表中的物理地址映射：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Fixup the physical addresses in the page table</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="n">early_level4_pgt</span> <span class="o">+</span> <span class="p">(</span><span class="n">L4_START_KERNEL</span><span class="o">*</span><span class="mi">8</span><span class="p">)(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="n">level3_kernel_pgt</span> <span class="o">+</span> <span class="p">(</span><span class="mi">510</span><span class="o">*</span><span class="mi">8</span><span class="p">)(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="n">level3_kernel_pgt</span> <span class="o">+</span> <span class="p">(</span><span class="mi">511</span><span class="o">*</span><span class="mi">8</span><span class="p">)(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="n">level2_fixmap_pgt</span> <span class="o">+</span> <span class="p">(</span><span class="mi">506</span><span class="o">*</span><span class="mi">8</span><span class="p">)(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这又是一段相对寻址，由于页表处于数据段，所以需要根据其和<code>%rip</code>中的相对地址来定位到页表，然后将页表中的表项加上之前计算的相对偏移量。当然这里只处理了<code>early_level4_pgt</code>、<code>level3_kernel_pgt</code>和<code>level2_fixmap_pgt</code>，而真正映射内核段的<code>level2_kernel_pgt</code>会在之后进行fixup。</p>

<p>之后又进入了一段诡异的代码，来建立<code>identity mapping for the switchover</code>，我也不懂这里的<code>switchover</code>是什么，我们先来看下这段代码做了什么吧：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Set up the identity mapping for the switchover.  These</span>
</span><span class='line'><span class="cm">   * entries should *NOT* have the global bit set!  This also</span>
</span><span class='line'><span class="cm">   * creates a bunch of nonsense entries but that is fine --</span>
</span><span class='line'><span class="cm">   * it avoids problems around wraparound.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="n">_text</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="n">early_level4_pgt</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rbx</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdi</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">shrq</span>  <span class="err">$</span><span class="n">PGDIR_SHIFT</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">leaq</span>  <span class="p">(</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">_KERNPG_TABLE</span><span class="p">)(</span><span class="o">%</span><span class="n">rbx</span><span class="p">),</span> <span class="o">%</span><span class="n">rdx</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdx</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdx</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">addq</span>  <span class="err">$</span><span class="mi">4096</span><span class="p">,</span> <span class="o">%</span><span class="n">rdx</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdi</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">shrq</span>  <span class="err">$</span><span class="n">PUD_SHIFT</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">andl</span>  <span class="err">$</span><span class="p">(</span><span class="n">PTRS_PER_PUD</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdx</span><span class="p">,</span> <span class="mi">4096</span><span class="p">(</span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'>  <span class="n">incl</span>  <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">andl</span>  <span class="err">$</span><span class="p">(</span><span class="n">PTRS_PER_PUD</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdx</span><span class="p">,</span> <span class="mi">4096</span><span class="p">(</span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">addq</span>  <span class="err">$</span><span class="mi">8192</span><span class="p">,</span> <span class="o">%</span><span class="n">rbx</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rdi</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">shrq</span>  <span class="err">$</span><span class="n">PMD_SHIFT</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="err">$</span><span class="p">(</span><span class="n">__PAGE_KERNEL_LARGE_EXEC</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">_PAGE_GLOBAL</span><span class="p">),</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="p">(</span><span class="n">_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rcx</span>
</span><span class='line'>  <span class="n">shrq</span>  <span class="err">$</span><span class="n">PMD_SHIFT</span><span class="p">,</span> <span class="o">%</span><span class="n">rcx</span>
</span><span class='line'>  <span class="n">subq</span>  <span class="o">%</span><span class="n">rdi</span><span class="p">,</span> <span class="o">%</span><span class="n">rcx</span>
</span><span class='line'>  <span class="n">incl</span>  <span class="o">%</span><span class="n">ecx</span>
</span><span class='line'>
</span><span class='line'><span class="mi">1</span><span class="o">:</span>
</span><span class='line'>  <span class="n">andq</span>  <span class="err">$</span><span class="p">(</span><span class="n">PTRS_PER_PMD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%</span><span class="n">rdi</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'>  <span class="n">incq</span>  <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="err">$</span><span class="n">PMD_SIZE</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">decl</span>  <span class="o">%</span><span class="n">ecx</span>
</span><span class='line'>  <span class="n">jnz</span> <span class="mi">1</span><span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以稍微进行一个计算，首先<code>%rdi</code>保存了当前内核代码段的首地址，<code>%rbx</code>保存了<code>early_level4_pgt</code>的地址，<code>%rax</code>是内核代码首地址对于level4页表的index，在当前即为0。所以<code>leaq  (4096 + _KERNPG_TABLE)(%rbx), %rdx</code>表示的是将<code>early_level4_pgt</code>所在的地址加上一个页的地址，作为第3级页表页，再加上相应的权限位，保存在<code>%rdx</code>中，然后通过<code>movq  %rdx, 0(%rbx,%rax,8)</code>和<code>movq  %rdx, 8(%rbx,%rax,8)</code>指令把<code>%rdx</code>作为一个表项，存在<code>early_level4_pgt</code>的第0和第1项中。</p>

<p>然后将<code>%rdx</code>再加上一个页的大小，作为第2级页表页，找到内核代码段对于level3页表的index，然后将第2级页表页加上对应的权限作为一个页表项存在刚刚建立的level3页表的第0项和第1项。</p>

<p>然后将<code>%rbx</code>加上两个页的大小，即第2级页表的位置，找到从<code>_text</code>到<code>_end</code>所有内核代码段对于level2页表的索引，然后将对应的地址+权限作为页表项逐个填到这个第2级页表中。</p>

<p>我们可以在<code>arch/x86/kernel/head_64.S</code>文件中找到这几个新添加的页表页的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">__INITDATA</span>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">early_level4_pgt</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">511</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">level3_kernel_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span> <span class="o">+</span> <span class="n">_PAGE_TABLE</span>
</span><span class='line'>
</span><span class='line'><span class="n">NEXT_PAGE</span><span class="p">(</span><span class="n">early_dynamic_pgts</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">fill</span> <span class="mi">512</span><span class="o">*</span><span class="n">EARLY_DYNAMIC_PAGE_TABLES</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>即紧接着<code>early_level4_pgt</code>，被称为<code>early_dynamic_pgts</code>。这个就是所谓的<code>identity mapping for the switchover</code>，表示在之后的一小段页表转换过程中会被用到的identity mapping。因为在页表中虚拟地址从低地址到高地址转换的过程中不可避免的会通过低位的虚拟地址进行索引，所以需要预先做个identity mapping的准备。</p>

<p>至此，页表变成了这个样子。</p>

<p><img src="http://ytliu.info/images/2016-03-14-2.png" title="Linux early page table 2 in boot" alt="early page table 2" /></p>

<p><code>startup_64</code>最后一步就是fixup内核段真正的物理页对应的页表项了，代码如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">   * Fixup the kernel text+data virtual addresses. Note that</span>
</span><span class='line'><span class="cm">   * we might write invalid pmds, when the kernel is relocated</span>
</span><span class='line'><span class="cm">   * cleanup_highmap() fixes this up along with the mappings</span>
</span><span class='line'><span class="cm">   * beyond _end.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="n">level2_kernel_pgt</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">leaq</span>  <span class="mi">4096</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span> <span class="o">%</span><span class="n">r8</span>
</span><span class='line'>  <span class="cm">/* See if it is a valid page table entry */</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span>  <span class="n">testq</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">)</span>
</span><span class='line'>  <span class="n">jz</span>  <span class="mf">2f</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">)</span>
</span><span class='line'>  <span class="cm">/* Go to the next page */</span>
</span><span class='line'><span class="mi">2</span><span class="o">:</span>  <span class="n">addq</span>  <span class="err">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">cmp</span> <span class="o">%</span><span class="n">r8</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span><span class='line'>  <span class="n">jne</span> <span class="mi">1</span><span class="n">b</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Fixup phys_base */</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="o">%</span><span class="n">rbp</span><span class="p">,</span> <span class="n">phys_base</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">movq</span>  <span class="err">$</span><span class="p">(</span><span class="n">early_level4_pgt</span> <span class="o">-</span> <span class="n">__START_KERNEL_map</span><span class="p">),</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">jmp</span> <span class="mf">1f</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个过程的前半部分就是将<code>level2_kernel_pgt</code>中的表项进行一个个的检查，如果不是0（即为一个可能存在的页表项），则将其加上之前计算的真实地址和被期待地址的偏移量（<code>%rbp</code>）。</p>

<p>当这个fixup结束之后，将<code>%rbp</code>保存在<code>phys_base</code>这个地址中，然后再将<code>early_level4_pgt - __START_KERNEL_map</code>保存在<code>%rax</code>中。</p>

<p>接下来就进入<code>secondary_startup_64</code>。</p>

<h3>secondary_startup_64</h3>

<p>这部分代码的主要功能是一些模式的开启，以及相关数据结构的加载，我们同样逐段进行分析：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ENTRY</span><span class="p">(</span><span class="n">secondary_startup_64</span><span class="p">)</span>
</span><span class='line'>  <span class="cm">/* Enable PAE mode and PGE */</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="err">$</span><span class="p">(</span><span class="n">X86_CR4_PAE</span> <span class="o">|</span> <span class="n">X86_CR4_PGE</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rcx</span><span class="p">,</span> <span class="o">%</span><span class="n">cr4</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Setup early boot stage 4 level pagetables. */</span>
</span><span class='line'>  <span class="n">addq</span>  <span class="n">phys_base</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里开启了PAE和PGE模式，并将其写到<code>%cr4</code>中，同时将初始页表的第四级页表地址写入了<code>%cr3</code>。至此，分页模式开启！</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/* Ensure I am executing from virtual addresses */</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="err">$</span><span class="mf">1f</span><span class="p">,</span> <span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">jmp</span> <span class="o">*%</span><span class="n">rax</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Check if nx is implemented */</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="err">$</span><span class="mh">0x80000001</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">cpuid</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edi</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Setup EFER (Extended Feature Enable Register) */</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="err">$</span><span class="n">MSR_EFER</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
</span><span class='line'>  <span class="n">rdmsr</span>
</span><span class='line'>  <span class="n">btsl</span>  <span class="err">$</span><span class="n">_EFER_SCE</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>  <span class="cm">/* Enable System Call */</span>
</span><span class='line'>  <span class="n">btl</span> <span class="err">$</span><span class="mi">20</span><span class="p">,</span><span class="o">%</span><span class="n">edi</span>    <span class="cm">/* No Execute supported? */</span>
</span><span class='line'>  <span class="n">jnc</span>     <span class="mf">1f</span>
</span><span class='line'>  <span class="n">btsl</span>  <span class="err">$</span><span class="n">_EFER_NX</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">btsq</span>  <span class="err">$</span><span class="n">_PAGE_BIT_NX</span><span class="p">,</span><span class="n">early_pmd_flags</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span>  <span class="n">wrmsr</span>       <span class="cm">/* Make changes effective */</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Setup cr0 */</span>
</span><span class='line'><span class="cp">#define CR0_STATE (X86_CR0_PE | X86_CR0_MP | X86_CR0_ET | \</span>
</span><span class='line'><span class="cp">       X86_CR0_NE | X86_CR0_WP | X86_CR0_AM | \</span>
</span><span class='line'><span class="cp">       X86_CR0_PG)</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="err">$</span><span class="n">CR0_STATE</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="cm">/* Make changes effective */</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr0</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Setup a boot time stack */</span>
</span><span class='line'>  <span class="n">movq</span> <span class="n">stack_start</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rsp</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* zero EFLAGS after setting rsp */</span>
</span><span class='line'>  <span class="n">pushq</span> <span class="err">$</span><span class="mi">0</span>
</span><span class='line'>  <span class="n">popfq</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码进行了一系列的初始化，包括检查<code>nx</code>（non-execution）是否开启，创建EFER，创建cr0，以及设置一个启动时会用到的栈，并且将所有eflags清零。这里就不细讲了。</p>

<p>然后是加载早期的GDT：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">   * We must switch to a new descriptor in kernel space for the GDT</span>
</span><span class='line'><span class="cm">   * because soon the kernel won&#39;t have access anymore to the userspace</span>
</span><span class='line'><span class="cm">   * addresses where we&#39;re currently running on. We have to do that here</span>
</span><span class='line'><span class="cm">   * because in 32bit we couldn&#39;t load a 64bit linear address.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">lgdt</span>  <span class="n">early_gdt_descr</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>初始化段寄存器：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/* set up data segments */</span>
</span><span class='line'>  <span class="n">xorl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">ds</span>
</span><span class='line'>  <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">ss</span>
</span><span class='line'>  <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">es</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">fs</span>
</span><span class='line'>  <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">gs</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Set up %gs.</span>
</span><span class='line'><span class="cm">   *</span>
</span><span class='line'><span class="cm">   * The base of %gs always points to the bottom of the irqstack</span>
</span><span class='line'><span class="cm">   * union.  If the stack protector canary is enabled, it is</span>
</span><span class='line'><span class="cm">   * located at %gs:40.  Note that, on SMP, the boot cpu uses</span>
</span><span class='line'><span class="cm">   * init data section till per cpu areas are set up.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="err">$</span><span class="n">MSR_GS_BASE</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="n">initial_gs</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span>  <span class="n">initial_gs</span><span class="o">+</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">edx</span>
</span><span class='line'>  <span class="n">wrmsr</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里需要注意的是<code>%gs</code>的建立，它和per cpu变量相关，是一个比较关键的段寄存器。不过由于这个系列主要是和内存相关，所以这里就不详述了。</p>

<p>然后将参数传给<code>%rdi</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/* rsi is pointer to real mode structure with interesting info.</span>
</span><span class='line'><span class="cm">     pass it to C */</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="o">%</span><span class="n">rsi</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后就是一个通过far return的跳转：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="cm">/* Finally jump to run C code and to be on real kernel address</span>
</span><span class='line'><span class="cm">   * Since we are running on identity-mapped space we have to jump</span>
</span><span class='line'><span class="cm">   * to the full 64bit address, this is only possible as indirect</span>
</span><span class='line'><span class="cm">   * jump.  In addition we need to ensure %cs is set so we make this</span>
</span><span class='line'><span class="cm">   * a far return.</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="n">movq</span>  <span class="n">initial_code</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rax</span>
</span><span class='line'>  <span class="n">pushq</span> <span class="err">$</span><span class="mi">0</span>    <span class="err">#</span> <span class="n">fake</span> <span class="k">return</span> <span class="n">address</span> <span class="n">to</span> <span class="n">stop</span> <span class="n">unwinder</span>
</span><span class='line'>  <span class="n">pushq</span> <span class="err">$</span><span class="n">__KERNEL_CS</span>  <span class="err">#</span> <span class="n">set</span> <span class="n">correct</span> <span class="n">cs</span>
</span><span class='line'>  <span class="n">pushq</span> <span class="o">%</span><span class="n">rax</span>    <span class="err">#</span> <span class="n">target</span> <span class="n">address</span> <span class="n">in</span> <span class="n">negative</span> <span class="n">space</span>
</span><span class='line'>  <span class="n">lretq</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>initial_code</code>定义为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">GLOBAL</span><span class="p">(</span><span class="n">initial_code</span><span class="p">)</span>
</span><span class='line'>  <span class="p">.</span><span class="n">quad</span> <span class="n">x86_64_start_kernel</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里要注意的是，在<code>pushq $__KERNEL_CS</code>这条指令之前的寻址还是通过identity-map的页表进行寻址的，而在该指令之后，cs被赋值成<code>__KERNEL_CS</code>，就变成采用正常的页表进行寻址了，到这个时候，虚拟地址就变成高位的地址了（<code>0xffffffff80000000</code>~<code>0xffffffffa0000000</code>）。</p>

<p>最后我们提一下这个<code>lretq</code>，所谓的long return。可以参照<a href="http://docs.oracle.com/cd/E19620-01/805-4693/instructionset-68/index.html">这里</a>：</p>

<blockquote><p>For an intersegment (far) return, the address on the stack is a long pointer. The offset is popped first, followed by the selector.</p></blockquote>

<p>所以在rax之前，需要把<code>__KERNEL_CS</code>的selector也放在栈上。</p>

<p>最后一个问题：gdt是在什么时候初始化的？这个我一直都没有找到，这里就先不管了。</p>

<p>因此，最后进入了<code>x86_64_start_kernel</code>函数，这是一个C语言写的函数，所以，会在下一篇博客中进行介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2015]]></title>
    <link href="http://ytliu.github.io/blog/2016/01/01/wo-de-2015/"/>
    <updated>2016-01-01T14:06:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2016/01/01/wo-de-2015</id>
    <content type="html"><![CDATA[<p>又到了一年一度的总结时，回忆我的2015。</p>

<p>如果用三个词语来总结过去的这一年，我会选择：<code>忙碌</code>，<code>迷惘</code>，以及<code>改变</code>。我向来是一个比较悲观的人，所以在看待自己的生活和成长的时候也会抱着比较悲观的心态。虽然说对于比较遥远的未来，我还算是很有信心的，但是对于短期的“以后”，我确实还是心有所虑，毕竟对于未知的恐惧还是大过对于自我的信心。前两天在微信上看到一个词，叫做<code>冒充者综合征</code>，我觉得很符合自己目前的心态。不管怎么说，人总是在改变着，以及成长着，虽然有时候回过头去看过去的种种，会有一些碌碌无为的感觉，但是做过了的就是做过了，获得了的就摆在那里，失去了的也本来就不属于你。当2015年的都过去了，对于每个个体来说也就意味着新的一页的开始，不再追求那些不属于你的过去，去吸收那些曾经让你成长的挫折所带来的经验，骄傲于那些你在这一年所获得的成就，并重新开始追求属于你自己的生活。其实想想，人活着，本来应该很简单，但是就是无法做到你想要的“简单”，那就只能简单地让自己去过这些复杂的生活吧。所有这些不可避免的忙碌，磕磕撞撞的迷惘，以及那些该来的和不该来的改变，组成了我的2015，那个26岁的自己。</p>

<!-- more -->


<p>首先，依然是用Day One记录的流水账：</p>

<ul>
<li>1月，研究kvm和xen的I/O代码（vhost，virtio等，以及Xen的driver domain），整理了很多相关笔记和总结，开始写splitio的项目（虽然现在已经忘记那是个什么项目了。。。），写博士论文的开题报告，年终总结。</li>
<li>2月，继续写《开题报告》和《研究现状综述》，研究nested xen，研究XSA-113，在Yoga 3 Pro上安装Xen（需要研究xen的efi，最终以失败告终），回家过年，订婚。</li>
<li>3月，完成TinMan的Final version（研究TaintDroid），CSDI助教事宜，参加婚博会，研究kdump，研究串口调试，关于Xen的backend的CVE，研究RowHammer攻击，参加猫展，研究xen的qemu代码。</li>
<li>4月，研究uio、dpdk，在Xen上跑dpdk，研究efi，去苏州同学聚会，secage项目，学习sed和awk（写secage的脚本），开始写paper。</li>
<li>5月，CSDI助教事宜，secage项目debug，实验室去嵊泗春游，CCS投稿，secage专利事宜，整理XSA，secage文档整理，TinMan测试，租房子。</li>
<li>6月，继续TinMan测试，XSA整理，KSA整理，去厦门参加ChinaSys，CSDI助教事宜，去盐城吃小龙虾，参与ibox论文的final version，开始研究auto项目，搬家。</li>
<li>7月，准备Secage的验收，CCS rebuttal，开始nested xen项目，研究xen memory（写了相应博客），研究kernel crash，帮华为debug secage，想idea，迎接家里的新成员刘一刀！CCS的论文被接受！</li>
<li>8月，准备CCS的final version，帮忙xenav项目，老妈来上海，回家过暑假，做CCS的slide，办签证。</li>
<li>9月，研究wifi pineapple，参加MSRA PhD forum，准备出国开会事宜，auto项目，申请奖学金。</li>
<li>10月，回家参加杜毅婚礼，上ng的机器学习的课，去丹佛开会，auto项目，申请唐立新奖学金，实验室去泰山秋游。</li>
<li>11月，auto项目结题，去武汉参加NASAC优博论坛，学习SROP，发表freebuf。</li>
<li>12月，研究intel-ipt，想idea，研究ASLR，hacking车载。</li>
</ul>


<hr />

<p>2015年，在工作上，我最自豪的成就在于自己的论文在CCS上发表了，这是对自己最大的肯定。另外，我在MSRA PhD Forum和NASAC优博论坛上做了两次报告；两个我主要参与的项目（华为的Secage和国家项目auto项目）都顺利结题；三篇论文（一篇一作，两篇二作）被发表，除了CCS那篇，另外两篇是和斌哥合作的，被发表在EuroSys和一个期刊TCC上；同时获得了国家奖学金和唐立新奖学金；出国开会一次，国内开会两次。</p>

<p>另外，2015年最让我开心的是，我们家来了一个新成员，一只超级超级可爱的小猫咪，名字叫”刘一刀“，小公主和女汉子的结合体。从此，我变为一个正宗的猫奴：</p>

<p><img src="http://ytliu.info/images/2016-01-01-1.jpg" title="liu yidao" alt="liu yidao" /></p>

<p>2015年的最后一天，我也顺利从一名未婚男士变成了已婚男士，正式进入婚姻这个殿（fen）堂（mu）：</p>

<p><img src="http://ytliu.info/images/2016-01-01-2.jpg" title="marriage" alt="marriage" /></p>

<p>在这一年，我博客的访问量比过去三年的总和还多一半：</p>

<p><img src="http://ytliu.info/images/2016-01-01-3.png" title="blog" alt="blog" /></p>

<p>这一年，由于申请了某个奖学金的缘故，加入了一个充斥着交大各专业大神的组织（唐立新奖学金获得者组成的”新尚海“），由于自己平时太忙，加上比较闷骚，在组织中并不活跃，但是并不能阻止我感到荣幸，希望今后有更多的机会和来自不同专业的各位大神交流：</p>

<p><img src="http://ytliu.info/images/2016-01-01-7.jpg" title="xinshanghai" alt="xinshanghai" /></p>

<p>然后是例行的数据统计：</p>

<p>我的2015 - 电影篇</p>

<p><img src="http://ytliu.info/images/2016-01-01-4.png" title="movie in 2015" alt="2015-movie" /></p>

<p>我的2015 - 读书篇：</p>

<p><img src="http://ytliu.info/images/2016-01-01-5.png" title="book in 2015" alt="2015-book" /></p>

<p>我的2015 - 运动篇：</p>

<p><img src="http://ytliu.info/images/2016-01-01-6.png" title="sport in 2015" alt="2015-sport" /></p>

<hr />

<p>最后的最后，我想再写一些感受，不是如开头那种意识流式的瞬间的感受，而是自己这一年来经常会产生的一些想法，一些或许很肤浅但是很真实的想法。</p>

<p>从2012年开始读博士到现在，已经经过了3年零3个月了。时间过得越久，就会看到越多以前的同学慢慢都开始成家立业了，而我每次也都得和家里的亲戚、朋友解释说自己还要两年才能毕业。经常我都会想，如果我当年没有选择读博，现在会怎样呢？当然，很有可能我现在也有房子或者准备开始考虑买房子，甚至都有孩子了，然后呢？每个月能拿更多的工资？或者自己的烦恼会更少？压力会更小？我觉得这些都很有可能，甚至有时候我会在那么瞬间后悔自己之前的决定。然后我就变得很讨厌自己。</p>

<p>我会讨厌自己怎么老是在纠结这种琐事，讨厌自己目光怎么这么短浅，讨厌自己怎么不懂得知足，在这么好的实验室里得到了这么好的资源还不满足&#8230;</p>

<p>然后，我就会想，时间，对于我来说，到底是什么？</p>

<p>最近在看经济学的书，知道这就是典型的”机会成本“。相同时间的投入，如果我不选择做这个，我就可以做那个，相比于最高收益的投资，其它投资在机会成本的角度上来说都叫亏损。加上五年的博士，如果从初中开始算起，我的人生一共要花15年的时间在学校这个象牙塔下度过，虽然说读博相当于工作，也有工资（而且我们实验室给博士发的工资在国内的高校来看应该都算排前几了），但是和出去工作（特别是以码农的标准）来看，还是一个表面上的投入大于收益的对于时间的投资。而且就算博士毕业拿到了博士文凭，其实并不一定比本科生或者硕士生能找到更好的工作，甚至面更窄，反而更不好找工作。或许你的名声更好听（特别是在中国人看来），但是老实说，这对于我并没有什么用，至少从我自己从来不觉得博士比其他学历（工作）更高级。从另一个角度来说，很多时候在读博的几年里，你很有可能都在寻找一些本来可能并不存在的问题，或者仅仅为了所谓的毕业资格所谓的论文数量，去解决一些其实没有人在意的问题，这个比在很多工作中解决一些实际问题所获得的成就感可要差远了。</p>

<p>除了这些，还有很多其它问题，所有的这一切，似乎都不建议一个希望在时间的投资上获得最高收益的人去读博。（当然如果你一心想搞研究那不属于讨论范围之内）</p>

<p>但是，并没有什么但是。</p>

<p>这次我没有任何想要给读博做心灵鸡汤的想法，我就是觉得从对个人的投资来看，读博所获得最大收益的可能性远小于找到一份好的工作。</p>

<p>然后，我就觉得自己很残忍。</p>

<p>首先，我获得了很大的收益。我得到了大部分人读博都想得到的东西，好实验室，好导师，好机遇，好论文，好名声，奖学金，等等这些。其次，我相信自己选择读博所产生的收益一定会大于直接选择工作，这是我对自己未来的信心，至少从目前的发展来看应该是这样的。</p>

<p>那么，我干嘛还来说以上这些？</p>

<p>同样是首先，我得到的这些，很大程度上取决于我运气好。虽然这么说很残忍，但是我真的是这么觉得的。我遇到一个超级好的导师，工作在一个特别赞的实验室，遇到一个特别好的机遇（有一个非常有能力和上进心的小AP指导），我付出的大部分东西都能有回报，没有经历太多的逆境，等等，当然，我的努力和能力都应该有贡献，但是它不代表有努力和能力就能获得这些。我知道好多能力上比我强的人，但是结果并不一定是一个更好的happy ending。</p>

<p>同样是其次，我觉得每个人的选择很重要。如果你有一个从目前来看更好的选择，那么你真的不一定要考虑读博这个从长远来看<strong>可能</strong>会比这个选择更好的选择。特别是在中国现在这个时期，有太多的机遇比花五年时间待在学校更不会让人后悔。</p>

<p>最后还是讲一个心灵鸡汤，读博对我来说，或者对很多人来说，其实真的不是简单的投资获得收益那么简单。至少对于我来说，这段经历，是我把时间成本投入在其它地方所无法获得的，不要说其它的，至少，在交大认识了那么多好兄弟这一点，就是其它选择可望而不可及的。</p>

<hr />

<p>我还是吐槽下自己的“讨厌”，都当了这么久的大龄男博士了，还在年终总结的时候来讨论这么一个其实并不重要的问题。</p>

<p>我一直觉得有一个问题很傻X，那就是</p>

<blockquote><p>“如果时间回到最初，你还会这么选择吗？”</p></blockquote>

<p>我觉得这是一个毫无意义的问题，如果时间回到最初，回到当时的情景，以每个人当时的心境，你必然还是会选择你走过的路。每个人在每个时间段所作出的每个选择，从他自己的角度来说，必定是在那个时间点对于他自己最优的。</p>

<p>但是如果换一个问题，“如果时间回到3年前，当你知道之后三年将会发生什么，你还会作出读博的选择吗？”</p>

<p>我的答案是：“那必须会啊！”</p>

<p>我都知道我之后能这么顺利了，我干嘛还不选啊？</p>

<p>所以得出结论，我是一个很“贱”的人，请不要在意我上面所说的那些话。</p>

<hr />

<p>2016，对于我来说是非常关键的一年，毕竟我要开始找工作啦，成家立业，我已成家，就等着立业了。希望自己在这一年还是能够一如既往的一帆风顺。当然，我也会尽自己最大的努力，去实现至少在现在看来还没有形成的“梦想”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable CONFIG_MODULE in Cyanogenmod Kernel]]></title>
    <link href="http://ytliu.github.io/blog/2015/12/14/enable-config-module-in-cyanogenmod-kernel/"/>
    <updated>2015-12-14T21:12:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/12/14/enable-config-module-in-cyanogenmod-kernel</id>
    <content type="html"><![CDATA[<p>I met a problem when trying to insert kernel module in the moto-g Android phone. My moto-g phone is built with Cyanogenmod falcon ROM, but by default, this ROM does not support installing modules.</p>

<p><img src="http://ytliu.info/images/2015-12-14-1.png" title="proc modules fail" alt="proc modules fail" /></p>

<p>Thus I&#8217;ve to enable it in the kernel config, re-compile and install the kernel. In this post I will give a short note about how to do it.</p>

<!-- more -->


<p>In this blog, I will take <code>falcon</code> as the example, since my device is moto-g.</p>

<p>Some materials:</p>

<p><a href="https://wiki.cyanogenmod.org/w/Build_for_falcon">How To Build CyanogenMod Android for Motorola Moto G (&#8220;falcon&#8221;)</a></p>

<p><a href="https://wiki.cyanogenmod.org/w/Doc:_integrated_kernel_building">integrated kernel building</a></p>

<hr />

<p>First, follow <a href="https://wiki.cyanogenmod.org/w/Build_for_falcon">this post</a>, you can download the source code for <code>falcon</code> device. Support our source code is in <code>~/android/system</code>，You need to do as follows to prepare before compiling the kernel:</p>

<pre><code>  $ cd ~/android/system
  $ source build/envsetup.sh
  $ breakfast falcon
  $ cd device/motorola/falcon
  $ ./extract-files.sh
  $ croot
</code></pre>

<p>NOTE: before executing <code>./extract-files.sh</code>，you need to plug the device to your computer.</p>

<p>After above operations, you need to refer to <a href="https://wiki.cyanogenmod.org/w/Doc:_integrated_kernel_building">this post</a> to prepare and compile the kernel.</p>

<h4>Add CONFIG_MODULE option in the kernel config</h4>

<p>First go to the kernel code directory:</p>

<pre><code>  $ cd kernel/motorola/msm8226
</code></pre>

<p>If you execute <code>make ARCH=arm help</code>, you can see many candidate defconfig options. In our example, we just need to use the <code>falcon_defconfig</code>, so we do as follows:</p>

<pre><code>  $ make ARCH=arm falcon_defconfig
</code></pre>

<p>This command will copy the <code>arch/arm/configs/falcon_defconfig</code> file to <code>.config</code>. If we open the <code>.config</code> file, we can see the <code>CONFIG_MODULE</code> option is disabled. In order to enable it, we execute:</p>

<pre><code>  $ make ARCH=arm menuconfig
</code></pre>

<p>This will open the menuconfig screen based on the <code>.config</code> default configuration. Then we only need to check the <code>Enable loadable module support</code> and some of the following options in the screen:</p>

<p><img src="http://ytliu.info/images/2015-12-14-2.png" title="menuconfig 1" alt="menuconfig 1" /></p>

<p><img src="http://ytliu.info/images/2015-12-14-3.png" title="menuconfig 2" alt="menuconfig 2" /></p>

<p>Then we exit and save the config, copy it to the <code>arch/arm/configs/falcon_defconfig</code>, and clear the config settings (that&#8217;s important, otherwise, it may fail in the next phase), finally go back to the root directory:</p>

<pre><code>  $ cp .config arch/arm/configs/falcon_defconfig
  $ make mrproper
  $ croot
</code></pre>

<h4>Compile and install kernel</h4>

<p>In this time, we can compile the kernel:</p>

<pre><code>  $ mka bootimage
</code></pre>

<p>After several minutes, the kernel compiling is done, the <code>out/target/product/falcon/boot.img</code> is generated.</p>

<p>If you want to flash the kernel to your device, you can type:</p>

<pre><code>  $ adb root
  $ adb remount
  $ installboot
  $ adb reboot
</code></pre>

<p>Or if you just want to test the kernel instead of flashing it:</p>

<pre><code>  $ adb reboot bootloader
  $ fastboot boot out/target/product/falcon/boot.img
</code></pre>

<p>Finally your newly built kernel works, and you can see the <code>/proc/modules</code> in the file system, which means you can insert your own modules!</p>

<p><img src="http://ytliu.info/images/2015-12-14-4.png" title="proc modules work" alt="proc modules work" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenSSL Authenticated Android Accessory Protocol]]></title>
    <link href="http://ytliu.github.io/blog/2015/12/05/openssl-authenticated-android-accessory-protocol/"/>
    <updated>2015-12-05T11:09:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/12/05/openssl-authenticated-android-accessory-protocol</id>
    <content type="html"><![CDATA[<p>前段时间在研究Android Auto（关于什么是Auto请自行google），里面涉及到两个比较关键的数据传输和加密协议：<code>Android Accessory Protocol</code>和<code>OpenSSL</code>。具体来说，auto和车载系统（之后称为headunit）之间数据的传输以及最初连接的建立是基于<a href="https://source.android.com/devices/accessories/protocol.html">Android Open Accessory （AOA）</a>协议的，而它们两个之间的认证过程以及数据的加密是基于<a href="https://www.openssl.org/">OpenSSL</a>的握手和加密协议。</p>

<p>在研究这两个协议的过程中，“如何将AOA协议和SSL协议结合起来”是一个很关键的问题。我在网上找了很多资料，但是并没有一个比较完整的教程，所以打算在这篇博客中做一个详细的介绍，并且将相关代码开源。</p>

<p><a href="https://github.com/ytliu/aoa-with-ssl">github上的源码</a></p>

<!-- more -->


<h3>关于Android Auto</h3>

<p>关于什么是<a href="https://www.android.com/auto/">Android Auto</a>，可以到google的官方网站上去查询。简单来说，就是Google开发的一套机制，可以将手机上的应用（包括地图、音乐、通话等）和车载系统进行交互，使得车载系统的功能更加丰富。如果要描述它的机制的话，可以用下面一张图来表示：</p>

<p><img src="http://ytliu.info/images/2015-12-05-1.png" title="Androi Auto Mechanism" alt="Androi Auto Mechanism" /></p>

<p>其中，负责和headunit进行交互的是GMS (Google Mobile Service)的Car Service，然后它会和Google开发的Auto应用联系，Auto应用负责和其它第三方应用程序交互，现在支持Android Auto的第三方应用程序有<a href="https://play.google.com/store/apps/collection/promotion_3001303_android_auto_all">这些</a>，可以看到大部分还是一些音乐和社交类的应用。这里有一个特殊的应用，那就是Google Map，它是直接整合在GMS里面的，可以直接和Car service进行交互，应该不需要经过Auto（当然这还仅仅是我的推测）。</p>

<h3>关于两个协议</h3>

<p>由于这篇博文主要介绍的是手机和车载的交互协议，因此我们主要关注的是GMS car service和headunit之间的交互，所以，我们把上面那张图简化一下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-2.png" title="AA and SSL Protocols" alt="AA and SSL Protocols" /></p>

<p>其中<code>Android Open Accessory（AOA）</code>协议发生在两台设备通过USB进行连接，其中一台作为<code>Accessory</code>，一台作为<code>Device</code>。在Auto的例子中，headunit的角色为<code>Accessory</code>，手机的角色为<code>Device</code>。<code>AOA</code>协议主要作用是关于<code>Accessory</code>和<code>Device</code>在初始化连接时候的互相识别，以及之后数据的传输。</p>

<p>关于<code>Accessory</code>和<code>Device</code>的概念可以看<a href="http://www.crifan.com/android_usb_usbaccessory_vs_usbdevice/">这篇博文</a>，这里就不详述了。</p>

<p>当<code>Accessory</code>和<code>Device</code>建立连接之后，两边就可以进行数据的传输了，但是由于一些隐私问题，传输的数据需要进行加密，因此就引入了<code>OpenSSL</code>协议。在OpenSSL协议中连接两端的实体被分为了<code>Server</code>和<code>Client</code>，这两个角色有什么区别会在之后提到。在这里我们只需要知道在Auto的例子中，headunit的角色为<code>Client</code>，手机的角色为<code>Server</code>。因此我们的图又被抽象为如下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-3.png" title="AA and SSL Protocols 2" alt="AA and SSL Protocols 2" /></p>

<p>好了，到现在为止，我们就完全和Auto撇清关系了，我们接下来要介绍的，就是两个实体，它们通过USB连接，一个作为AOA协议的<code>Accessory</code>和OpenSSL协议的<code>Client</code>，另一个作为AOA协议的<code>Device</code>和OpenSSL协议的<code>Server</code>。</p>

<h3>Android Open Accessory（AOA）协议</h3>

<p>当两个实体通过USB进行连接之后，最先做出反应的是<code>Accessory</code>，它会做以下几件事情：</p>

<h4>步骤1：获得和它连接的<code>Device</code>的VendorID和ProductID；</h4>

<h4>步骤2：判断它们是否匹配相应的数字；</h4>

<p>比如在Auto的例子中，headunit需要判断VendorID是否匹配<code>0x18D1</code>，ProductID是否匹配<code>0x2D00</code>或者<code>0x2D01</code>？）</p>

<ul>
<li>如果匹配，则表示该设备支持Android accessory模式，并且当前已经处于该模，所以<code>Accessory</code>可以直接和<code>Device</code>进行通信（直接跳到步骤5）；</li>
<li>否则，则表示该设备目前不处在Android accessory模式，但是不清楚其是否支持该模式，需要进行确认（继续执行步骤3~4）。</li>
</ul>


<h4>步骤3：Android accessory模式确认和重新连接；</h4>

<ul>
<li><p>通过USB发送一个请求：</p>

<pre><code>requestType:    USB_DIR_IN | USB_TYPE_VENDOR
request:        51
value:          0
index:          0
data:           protocol version number (16 bits little endian sent from the device to the accessory)
</code></pre></li>
<li><p>如果对方返回一个非零整数，则表示该设备支持Android accessory模式，该返回值表示支持的协议版本号；</p></li>
<li><p>发送另外的请求，该请求中包含一些字符串，用来表示<code>Device</code>中哪些应用程序可以来和<code>Accessory</code>进行交互：</p>

<pre><code>requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
request:        52
value:          0
index:          string ID
data            zero terminated UTF8 string sent from accessory to device
</code></pre></li>
<li><p>有效的string ID包含以下几类：</p>

<pre><code>manufacturer name:  0
model name:         1
description:        2
version:            3
URI:                4
serial number:      5
</code></pre></li>
<li><p>在Auto的例子中，headUnit在这个过程中会发送两个string ID：<code>manufacturer name = "Android"</code>，<code>model name = "Android Auto"</code>。该string ID会触发手机设备中<code>com.google.android.gms.car.FirstActivity</code>的<code>onCreate()</code>函数，从而使得GMS car service和headUnit进行accessory的连接；</p></li>
<li><p><code>Accessory</code>最后发送一个请求，告诉<code>Device</code>开始进入Android accessory模式，并且重新建立连接：</p>

<pre><code>requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
request:        53
value:          0
index:          0
data:           none
</code></pre></li>
</ul>


<h4>步骤4：重新检查；</h4>

<p>步骤3结束之后，<code>Device</code>会重新和<code>Accessory</code>进行连接，这时<code>Accessory</code>回到步骤1进行检查，如果检查通过，则进入步骤5，如果<code>Device</code>不支持Android accessory模式，或者没有匹配的应用程序，则<code>Device</code>会返回信息告诉<code>Accessory</code>，这时<code>Accessory</code>就只能等待下一个手机设备的接入。</p>

<h4>步骤5：开始通信.</h4>

<p>从这之后，<code>Accessory</code>和<code>Device</code>将通过Android Accessory协议进行通信，<code>Accessory</code>首先获得该USB连接中的一些配置元数据，包括接口类型（UsbInterface），端点信息（UsbEndpoint）等，从而获得对应的bulk endpoints，进行之后的通信过程。</p>

<p>在数据通信的过程中，<code>Accessory</code>通过<code>libusb</code>库提供的<code>libusb_control_transfer</code>和<code>libusb_bulk_transfer</code>接口进行数据的传输，其中，<code>libusb_control_transfer</code>用于传输一些指令数据，而<code>libusb_bulk_transfer</code>用于传输一些比较大的数据，比如音频数据，图像数据等；
而<code>Device</code>则通过Android <code>USBManager</code>提供的<code>openAccessory</code>接口获得一个文件描述符，然后通过其对应的<code>FileInputStream</code>和<code>FileOutputStream</code>进行数据的读写：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ParcelFileDescriptor</span> <span class="n">mFD</span> <span class="o">=</span> <span class="n">mUSBManager</span><span class="o">.</span><span class="na">openAccessory</span><span class="o">(</span><span class="n">acc</span><span class="o">);</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">mFD</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">FileDescripter</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">mFD</span><span class="o">.</span><span class="na">getFileDescriptor</span><span class="o">();</span>
</span><span class='line'>    <span class="n">mIS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>  <span class="c1">// use this to receive messages</span>
</span><span class='line'>    <span class="n">mOS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span> <span class="c1">// use this to send commands</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>OpenSSL协议</h3>

<p>在<code>Accessory</code>和<code>Device</code>建立连接，并且可以传输数据之后，它们就要开始建立OpenSSL的连接，对数据进行加解密了。这里主要分为了两个过程：握手过程和数据加解密过程。这里简单介绍下握手协议：</p>

<h4>OpenSSL握手协议</h4>

<p>握手协议的作用是身份的认证，该过程由<code>Client</code>端发起，这个协议的过程如下：</p>

<p><img src="http://ytliu.info/images/2015-12-05-4.png" title="OpenSSL Handshake Protocol" alt="OpenSSL Handshake Protocol" /></p>

<p>在这个过程中，<code>Client</code>首先会对<code>Server</code>提供的证书（Certificate）进行验证，<code>Server</code>也会对<code>Client</code>提供的证书进行验证。同时它们会用<code>Server</code>的公钥（包含在<code>Server</code>的证书中）和存在<code>Server</code>端的私钥进行秘钥的协商，最后通过这个协商好的秘钥（master key）对数据进行加解密。</p>

<p>这里推荐<a href="http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work">StackOverflow的一个帖子</a>，里面的前两个回答对OpenSSL握手协议进行了一个很棒的解释。</p>

<hr />

<h3>代码分析</h3>

<p>在进行了背景介绍之后，我们开始来分析下如何实现这整个过程。</p>

<p>源码可以在<a href="https://github.com/ytliu/aoa-with-ssl">这里</a>下载。</p>

<p>里面有两个目录：<code>aoa-dev-ssl-server</code>和<code>aoa-acc-ssl-client</code>，分别代表上面描述的两个实体。这两个目录是两个不同的Android应用，编译完之后可以通过<code>adb install</code>安装在Android平台的手机或者平板上。</p>

<h4>AOA协议的实现</h4>

<p>首先由<code>aoa-acc-ssl-client</code>发起，代码在<code>src/cn/sjtu/ipads/uas/UasTransport.java</code>文件中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">usb_acc_string_send</span><span class="o">(</span><span class="n">UsbDeviceConnection</span> <span class="n">connection</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="o">(</span><span class="n">string</span> <span class="o">+</span> <span class="s">&quot;\0&quot;</span><span class="o">).</span><span class="na">getBytes</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">controlTransfer</span><span class="o">(</span><span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_TYPE_VENDOR</span><span class="o">,</span>
</span><span class='line'>        <span class="n">OAP_SEND_STRING</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">usb_acc_strings_send</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">usb_acc_string_send</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">,</span> <span class="n">OAP_STR_MANUFACTURE</span><span class="o">,</span> <span class="s">&quot;SJTU&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">usb_acc_string_send</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">,</span> <span class="n">OAP_STR_MODEL</span><span class="o">,</span> <span class="s">&quot;SJTU IPADS&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">acc_mode_switch</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">acc_ver</span> <span class="o">=</span> <span class="n">usb_acc_version_get</span><span class="o">(</span><span class="n">m_usb_dev_conn</span><span class="o">);</span>
</span><span class='line'>    <span class="n">usb_acc_strings_send</span><span class="o">();</span>
</span><span class='line'>    <span class="n">m_usb_dev_conn</span><span class="o">.</span><span class="na">controlTransfer</span><span class="o">(</span><span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">UsbConstants</span><span class="o">.</span><span class="na">USB_TYPE_VENDOR</span><span class="o">,</span> <span class="n">OAP_START</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">usb_connect</span><span class="o">(</span><span class="n">UsbDevice</span> <span class="n">device</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">usb_open</span><span class="o">(</span><span class="n">device</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">usb_disconnect</span><span class="o">();</span>
</span><span class='line'>      <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dev_vend_id</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="na">getVendorId</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dev_prod_id</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="na">getProductId</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">dev_vend_id</span> <span class="o">==</span> <span class="n">USB_VID_GOO</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">dev_prod_id</span> <span class="o">==</span> <span class="n">USB_PID_OAP_NUL</span> <span class="o">||</span> <span class="n">dev_prod_id</span> <span class="o">==</span> <span class="n">USB_PID_OAP_ADB</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">acc_mode_connect</span><span class="o">();</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>      <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">acc_mode_switch</span><span class="o">();</span>
</span><span class='line'>    <span class="n">usb_disconnect</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个可以参照我之前讲的AOA协议来对照，这里当调用<code>usb_acc_strings_send()</code>将两个字符串发送出去之后，在<code>Device</code>端就会有相应的应用被唤醒，因为在该应用中定义了如下内容（在<code>aoa-dev-ssl-server</code>目录的<code>res/xml/usb_accessory_filter</code>文件中）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;usb-accessory</span> <span class="na">manufacturer=</span><span class="s">&quot;SJTU&quot;</span> <span class="na">model=</span><span class="s">&quot;SJTU IPADS&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在<code>aoa-dev-ssl-server</code>目录的<code>AndroidManifest.xml</code>文件中定义如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>  <span class="na">package=</span><span class="s">&quot;cn.sjtu.ipads.ual&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&quot;android.hardware.usb.accessory&quot;</span> <span class="na">android:required=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;application&gt;</span>
</span><span class='line'>    <span class="nt">&lt;uses-library</span> <span class="na">android:name=</span><span class="s">&quot;com.android.future.usb.accessory&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    ...
</span><span class='line'>    <span class="nt">&lt;activity</span>
</span><span class='line'>      <span class="na">android:name=</span><span class="s">&quot;UalTraActivity&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'>      <span class="nt">&lt;meta-data</span>
</span><span class='line'>        <span class="na">android:name=</span><span class="s">&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</span>
</span><span class='line'>        <span class="na">android:resource=</span><span class="s">&quot;@xml/usb_accessory_filter&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/activity&gt;</span>
</span><span class='line'>    ...
</span><span class='line'>  <span class="nt">&lt;/application&gt;</span>
</span><span class='line'><span class="nt">&lt;/manifest&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，<code>aoa-dev-ssl-server</code>这个应用会被唤醒，进入<code>UalTraActivity</code>的<code>onCreate()</code>函数。在该类中，会进行USB accessory的连接：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mDeviceHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="n">mUSBManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">UsbManager</span><span class="o">)</span> <span class="n">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">USB_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">connectToAccessory</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">connectToAccessory</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// bail out if we&#39;re already connected</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">mConnection</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>      <span class="k">return</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;connectToAccessory&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">// assume only one accessory (currently safe assumption)</span>
</span><span class='line'>    <span class="n">UsbAccessory</span><span class="o">[]</span> <span class="n">accessories</span> <span class="o">=</span> <span class="n">mUSBManager</span><span class="o">.</span><span class="na">getAccessoryList</span><span class="o">();</span>
</span><span class='line'>    <span class="n">UsbAccessory</span> <span class="n">accessory</span> <span class="o">=</span> <span class="o">(</span><span class="n">accessories</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span>
</span><span class='line'>        <span class="o">:</span> <span class="n">accessories</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">accessory</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">mUSBManager</span><span class="o">.</span><span class="na">hasPermission</span><span class="o">(</span><span class="n">accessory</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">openAccessory</span><span class="o">(</span><span class="n">accessory</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;no permission for accessory&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;mAccessory is null&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">openAccessory</span><span class="o">(</span><span class="n">UsbAccessory</span> <span class="n">accessory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;openAccessory&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">mConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UsbConnection</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">mUSBManager</span><span class="o">,</span> <span class="n">accessory</span><span class="o">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">mConnection</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;mConnection is null&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">finish</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>    <span class="n">performPostConnectionTasks</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>UsbConnection</code>这个类中会通过<code>UsbManager</code>的<code>openAccessory</code>接口得到一个文件描述符<code>mFileDescriptor</code>，之后的数据传输就是通过对这个<code>mFileDescriptor</code>的读写来进行的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="kd">public</span> <span class="nf">UsbConnection</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">,</span> <span class="n">UsbManager</span> <span class="n">usbManager</span><span class="o">,</span>
</span><span class='line'>      <span class="n">UsbAccessory</span> <span class="n">accessory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">mActivity</span> <span class="o">=</span> <span class="n">activity</span><span class="o">;</span>
</span><span class='line'>    <span class="n">mFileDescriptor</span> <span class="o">=</span> <span class="n">usbManager</span><span class="o">.</span><span class="na">openAccessory</span><span class="o">(</span><span class="n">accessory</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">mFileDescriptor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="s">&quot;UsbConnection&quot;</span><span class="o">,</span> <span class="s">&quot;mFileDescriptor&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="n">mAccessory</span> <span class="o">=</span> <span class="n">accessory</span><span class="o">;</span>
</span><span class='line'>      <span class="n">FileDescriptor</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">mFileDescriptor</span><span class="o">.</span><span class="na">getFileDescriptor</span><span class="o">();</span>
</span><span class='line'>      <span class="n">mInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>
</span><span class='line'>      <span class="n">mOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">fd</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">IntentFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntentFilter</span><span class="o">(</span><span class="n">ACTION_USB_PERMISSION</span><span class="o">);</span>
</span><span class='line'>    <span class="n">filter</span><span class="o">.</span><span class="na">addAction</span><span class="o">(</span><span class="n">UsbManager</span><span class="o">.</span><span class="na">ACTION_USB_ACCESSORY_DETACHED</span><span class="o">);</span>
</span><span class='line'>    <span class="n">mActivity</span><span class="o">.</span><span class="na">registerReceiver</span><span class="o">(</span><span class="n">mUsbReceiver</span><span class="o">,</span> <span class="n">filter</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到目前为止，<code>Accessory</code>和<code>Device</code>的连接已经建立，之后的数据传输就可以进行了。</p>

<p>在<code>Accessory</code>这端的数据读写是在jni层中，可以参阅<code>aoa-acc-ssl-client/jni/hu_usb.c</code>这个文件。</p>

<p>发数据的流程是这样的：</p>

<pre><code>hu_aap_usb_send() -&gt; hu_usb_send() -&gt; iusb_bulk_transfer(out)
</code></pre>

<p>接受数据的流程是这样的：</p>

<pre><code>hu_aap_usb_recv() -&gt; hu_usb_recv() -&gt; iusb_bulk_transfer(in)
</code></pre>

<p>具体代码这里不贴了，有兴趣自己去看。</p>

<p>在<code>Device</code>这端的数据读写是在java层，可以参阅<code>aoa-dev-ssl-server/src/cn/sjtu/ipads/ual/UalTraActivity.java</code>这个文件。</p>

<p>发数据就是调用了之前获得的<code>UsbConnection</code>类的这个接口：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">mConnection</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bufferLength</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>收数据类似：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">mConnection</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">().</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">bufferUsed</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">bufferUsed</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>AOA协议基本就实现完成了。</p>

<h4>OpenSSL握手协议</h4>

<p>握手协议由<code>aoa-acc-ssl-client</code>发起，在文件<code>aoa-acc-ssl-client/jni/hu_aap.c</code>中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">hu_aap_start</span> <span class="p">(</span><span class="n">byte</span> <span class="n">ep_in_addr</span><span class="p">,</span> <span class="n">byte</span> <span class="n">ep_out_addr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">hu_ssl_handshake</span> <span class="p">();</span> <span class="c1">// Do SSL Client Handshake with AA SSL server</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后就会经历上面提到的整个握手过程。</p>

<p>这里需要注意的是，这个OpenSSL握手和加解密过程的实现，和我们平时通过socket传输数据时所涉及到的过程有点不一样。</p>

<p>我们在网络编程的时候，一般会调用下面两个API：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span> <span class="o">=</span> <span class="n">SSL_new</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>  <span class="cm">/* get new SSL state with context */</span>
</span><span class='line'><span class="n">SSL_set_fd</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>  <span class="cm">/* set connection to SSL state */</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后的网络数据读写直接通过<code>SSL_write(ssl)</code>和<code>SSL_read(ssl)</code>来做就行了。因为SSL和这个负责读写数据的文件描述符<code>sockfd</code>已经绑定在一起了，在网络库的内部帮我们实现了网络buffer到SSL内部buffer的映射。</p>

<p>然而，当我们需要通过USB进行传输数据的时候就没有那么简单了。我们前面说过，我们同样可以通过对某个文件描述的读写操作来传送和接受USB数据，但是USB的库并没有帮我们实现其buffer到SSL内部buffer的映射。因此这步操作需要我们自己来实现。这里就用到了<code>OpenSSL</code>+<code>Memory BIO</code>的机制。</p>

<p>先提供一个参考资料：<a href="http://www.roxlu.com/2014/042/using-openssl-with-memory-bios">Using OpenSSL with Memory BIO</a></p>

<p>简单来说步骤是这样的：</p>

<ul>
<li>首先，我们需要配置OpenSSL的数据结构：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="n">ual_ssl_ctx</span> <span class="o">=</span> <span class="n">SSL_CTX_new</span><span class="p">(</span><span class="n">ual_ssl_method</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_CTX_use_certificate</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">,</span> <span class="n">x509_cert</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_CTX_use_PrivateKey</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">,</span> <span class="n">priv_key</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ual_ssl_ssl</span> <span class="o">=</span> <span class="n">SSL_new</span><span class="p">(</span><span class="n">ual_ssl_ctx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ual_ssl_rm_bio</span> <span class="o">=</span> <span class="n">BIO_new</span><span class="p">(</span><span class="n">BIO_s_mem</span><span class="p">());</span>
</span><span class='line'>  <span class="n">ual_ssl_wm_bio</span> <span class="o">=</span> <span class="n">BIO_new</span><span class="p">(</span><span class="n">BIO_s_mem</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">SSL_set_bio</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">ual_ssl_wm_bio</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我中间跳过了很多步，不过那些都不重要（可以去看源码），这里最重要的就是这句话：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SSL_set_bio</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">ual_ssl_wm_bio</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里将<code>ual_ssl_ssl</code>这个数据结构和两段内存联系在一起，这两段内存分别是<code>read BIO</code>和<code>write BIO</code>。</p>

<p>这有什么用呢？其实要解释清楚这个就需要先对OpenSSL的机制有一个初步的了解。</p>

<p>在SSL的所有操作中（比如证书验证，加密，解密等），说到底，就是从某段内存中读取数据，对其进行相应的操作，然后将结果写在另外一段内存中。因此这里的两段内存就分别对应了<code>read BIO</code>和<code>write BIO</code>。</p>

<p>似乎还是有点晕，那么我们来举个例子：</p>

<p>如果我们要进行数据加密，分解步骤是这样的：</p>

<ul>
<li>输入一段长度为<code>len</code>的明文数据<code>plain_buf</code>；</li>
<li>调用<code>SSL_write(ual_ssl_ssl, plain_buf, len)</code>，这时OpenSSL内部的逻辑就会对这段数据进行加密，并且将结果保存在<code>write BIO</code>中；</li>
<li>调用<code>BIO_read(ual_ssl_wm_bio, cipher_buf, DEFBUF)</code>，就可以将这段加密好的数据读出来保存在<code>cipher_buf</code>中；</li>
<li>最后，我们通过写USB对应的文件描述符就可以将这段加密的数据发送出去了。</li>
</ul>


<p>因此，整个加密的逻辑就可以是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_encrypt_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">plain_buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cipher_buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">bytes_written</span> <span class="o">=</span> <span class="n">SSL_write</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">BIO_read</span><span class="p">(</span><span class="n">ual_ssl_wm_bio</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">DEFBUF</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">bytes_read</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">ssl_encrypt_data</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">send_to_usb_fd</span><span class="p">(</span><span class="n">cipher_buf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的，解密的分解步骤是这样的：</p>

<ul>
<li>通过读USB对应的文件描述符读取一段长度为<code>len</code>的密文数据<code>cipher_buf</code>；</li>
<li>调用<code>BIO_write(ual_ssl_ssl, cipher_buf, len)</code>，将这段密文写入和SSL相关联的<code>read BIO</code>的内存中；</li>
<li>调用<code>SSL_read(ual_ssl_ssl, plain_buf, DEFBUF)</code>，将<code>read BIO</code>的数据进行解密，并将结果保存在<code>plain_buf</code>中；</li>
<li>最后，我们就可以对这段明文数据进行处理了。</li>
</ul>


<p>其相应的逻辑就变成这样了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_decrypt_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cipher_buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">plain_buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">bytes_written</span> <span class="o">=</span> <span class="n">BIO_write</span><span class="p">(</span><span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">SSL_read</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">,</span> <span class="n">DEFBUF</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">bytes_read</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">len</span> <span class="o">=</span> <span class="n">recv_from_usb_fd</span><span class="p">(</span><span class="n">cipher_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">ssl_decrypt_data</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">cipher_buf</span><span class="p">,</span> <span class="n">plain_buf</span><span class="p">);</span>
</span><span class='line'><span class="n">process</span><span class="p">(</span><span class="n">plain_buf</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>和加解密过程相比，握手的过程会比较复杂一些，但是相关原理是一样的。</p>

<p>不管在<code>Server</code>端还是在<code>Client</code>端，都需要调用<code>SSL_do_handshake(ual_ssl_ssl)</code>这个API，OpenSSL内部的逻辑就会根据当前的状态对<code>ual_ssl_rm_bio</code>的数据进行处理，并将结果写到<code>ual_ssl_wm_bio</code>中。在调用<code>SSL_do_handshake</code>这个API前，需要将相关的数据写到<code>read BIO</code>中（比如在<code>Server</code>端，第一次调用<code>SSL_do_handshake</code>前需要将<code>Client Hello</code>的数据通过<code>BIO_write</code>写进<code>ual_ssl_rm_bio</code>中）。所以说，一般情况下需要手动调用大于一次的<code>SSL_do_handshake</code>接口。</p>

<p>整个逻辑大概是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">ssl_hs_data_enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">BIO_write</span><span class="p">(</span><span class="n">ual_ssl_rm_bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">ssl_hs_data_dequeue</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">BIO_read</span><span class="p">(</span><span class="n">ual_ssl_wm_bio</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">DEFBUF</span> <span class="o">-</span> <span class="mi">6</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">ssl_handshake</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ret</span> <span class="o">=</span> <span class="n">SSL_do_handshake</span><span class="p">(</span><span class="n">ual_ssl_ssl</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">handshake</span> <span class="n">not</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">len</span> <span class="o">=</span> <span class="n">recv_from_usb_fd</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ssl_hs_data_enqueue</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ssl_handshake</span><span class="p">();</span>
</span><span class='line'>  <span class="n">length</span> <span class="o">=</span> <span class="n">ssl_hs_data_dequeue</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span><span class='line'>  <span class="n">send_to_usb_fd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>讲到这里，OpenSSL的整个流程也基本介绍完了。最后需要说明的一点，在<code>aoa-acc-ssl-client</code>中，数据的传输和加密都是在JNI层完成的，所以代码比较简单。但是在<code>aoa-dev-ssl-server</code>中，数据的传输是在Java层完成的，而加密是在JNI层实现的，所以中间有一个JNI调用的过程，会显得比较复杂。不过整体的原理是一样的。</p>

<p>关于JNI如何调用，网上有很多教程，也可以直接参照源码，这里就不详述了。</p>

<p>最后，关于整个项目的编译和运行，可以参照github中的<code>README.md</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转载】Sigreturn Oriented Programming (SROP) Attack - 攻击原理]]></title>
    <link href="http://ytliu.github.io/blog/2015/12/02/sigreturn-oriented-programming-srop-attack-gong-ji-yuan-li/"/>
    <updated>2015-12-02T18:43:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/12/02/sigreturn-oriented-programming-srop-attack-gong-ji-yuan-li</id>
    <content type="html"><![CDATA[<p>这篇文章我已经投稿在<a href="http://www.freebuf.com/">Freebuf</a>上，可以参看<a href="http://www.freebuf.com/articles/network/87447.html">这里</a>。所以版权肯定是算Freebuf的，虽然是我写的，但是也只得算是转载吧。</p>

<!-- more -->


<p>这次之所以选择把文章投在freebuf上，主要原因还是想要赚点稿费。不过不得不提的是，freebuf的阅读访问量还是很大的，仅仅过了一天就有10000+的点击，虽然我觉得可能大部分人点进来之后也不会细看，而且确实没有相关背景也很难理解。</p>

<p>在自己的博客中存个档，当然希望大家还是去freebuf上支持下~</p>

<hr />

<p>去年在Wooyun投了<a href="http://drops.wooyun.org/tips/3071">一篇文章</a>，介绍<a href="http://www.scs.stanford.edu/brop/">BROP攻击</a>。反响还挺好的，也帮助了很多人去理解这个非常smart的攻击原理。当然大家也可以去<a href="http://ytliu.info/blog/2014/06/01/blind-return-oriented-programming-brop-attack-er/">我的博客</a>看这个攻击的重现。
这次我想介绍另一个类ROP攻击，叫SROP，也是发表在<a href="http://www.ieee-security.org/TC/SP2014">Oakland 2014</a>，被评选为当年的<a href="http://www.ieee-security.org/TC/SP2014/awards.html">Best Student Papers</a>。论文的题目叫做<code>Framing Signals — A Return to Portable Shellcode</code>，作者是来自Vrije Universiteit Amsterdam的Erik Bosman，以下是相关paper和slides的链接：</p>

<p><a href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf">paper</a></p>

<p><a href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf">slides</a></p>

<p>首先，我觉得这也是一个非常有趣的攻击，虽然在去年就已经发表了，但是我在网上并没有找到太多相关的信息，在最近一年的研究领域也没有太多对它的<a href="https://scholar.google.com/scholar?cites=5919093237976555977&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN">引用</a>，所以我觉得很有必要推广一下。但是在我看完paper之后，觉得这篇paper写得并不是很容易让人理解，很多句子都晦涩难懂，不过这些都不重要，重要的是，这个攻击确实很有效，里面提到，在不同版本的Unix系统（如GNU Linux，BSD，iOS/Mac OS X等）中被使用了40多年的Signal机制，存在一个很容易被攻击者利用的设计缺陷，而这个缺陷所产生的相应的攻击，即文中所描述的SROP，和传统的ROP攻击相比显得更加简单，可靠，可移植。</p>

<p>接下来，我会从ROP攻击开始讲起，然后引入SROP的攻击原理，其中会涉及到Signal机制的相关背景，最后，我会介绍一些相应的防御措施。</p>

<h3>ROP背景介绍</h3>

<h4>ROP攻击的出现</h4>

<p><a href="https://zh.wikipedia.org/wiki/Stack_Overflow">Stack Overflow</a>和<a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">DEP (Data Execution Prevention)</a>我在这里就不介绍了，简单来说，就是最早的code injection攻击在现在的操作系统中基本上不能使用，因此出现了ROP，也就是所谓的Return Oriented Programming，其中也包括比较早期的Return-to-libc。ROP的主要思想就是攻击者不需要自己注入代码（因为在DEP的保护下，注入的代码不可执行），而是利用系统已有的代码片段来构造攻击。这里之所以叫ROP，是因为其改变控制流的方式是用系统中的return指令（比如x86中的<code>ret</code>）。</p>

<p>这里需要说明的是，在栈操作中，return指令是唯一一个可以通过控制栈上的数据改变指令流的指令，它的效果等同于：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pop</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'><span class="n">jmp</span> <span class="o">%</span><span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure>


<p>即将IP设置成栈上的某个值。因此如果我们可以控制栈上的数据，就可以控制执行流。</p>

<h4>ROP攻击的原理</h4>

<p>这里举一个最简单的例子来说明如何利用ROP来实现一条内存赋值语句：<code>Mem[v2] = v1</code>，其中<code>v2</code>是一个内存地址，<code>v1</code>是一个值。</p>

<p><img src="http://ytliu.info/images/2015-11-27-1.png" title="Simple ROP Example" alt="ROP example" /></p>

<p>这里我们先把<code>Mem[v2] = v1</code>这条内存赋值语句转化成汇编代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">mov</span> <span class="o">%</span><span class="n">eax</span> <span class="n">v1</span><span class="p">;</span>
</span><span class='line'><span class="n">mov</span> <span class="o">%</span><span class="n">ebx</span> <span class="n">v2</span><span class="p">;</span>
</span><span class='line'><span class="n">mov</span> <span class="p">[</span><span class="o">%</span><span class="n">ebx</span><span class="p">],</span> <span class="o">%</span><span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure>


<p>将<code>v1</code>的值赋给<code>%eax</code>，将<code>v2</code>的值（即内存地址）赋给<code>%ebx</code>，最后将<code>%eax</code>的值赋给<code>%ebx</code>地址指向的内存。</p>

<p>我们将这段代码翻译成可以通过ROP的方式执行的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">addr1:</span> <span class="n">pop</span> <span class="n">eax</span><span class="p">;</span> <span class="n">ret</span>
</span><span class='line'><span class="nl">addr2:</span> <span class="n">pop</span> <span class="n">ebx</span><span class="p">;</span> <span class="n">ret</span>
</span><span class='line'><span class="nl">addr3:</span> <span class="n">mov</span> <span class="p">[</span><span class="n">ebx</span><span class="p">],</span> <span class="n">eax</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>addr1</code>、<code>addr2</code>、<code>addr3</code>都是相应指令的内存地址，我们将每一行称为一个“gadget”。通过像上图中那样构造栈上的数据就可以完成和上面汇编相同的效果。如果不清楚可以自己代入试一试，这里就不详述了。</p>

<p>你可能会问，单纯构造一个内存赋值语句有什么用呢？其中最广泛的应用就是为参数赋值。假设我们希望用ROP的方式调用一个system call，那么我们就可以用上面的这种方式为这个system call填上参数，最后在栈上填上<code>syscall</code>（或者<code>int 80</code>）指令的内存地址就可以了。</p>

<h4>ROP攻击的前提条件</h4>

<p>讲到这里，如果你对上面有了初步的理解，就可能会觉得好像ROP确实很厉害，能够随意调用system call（比如调用<code>execve</code>来开启一个shell；或者调用<code>mprotect</code>来将栈设置成可执行，等等）。然而事实上ROP并没有想象中的那么简单。要完成一个成功的ROP攻击，需要有很多前提条件，这里列举几个最重要的：</p>

<ul>
<li>首先必须要有一个buffer overflow的漏洞（当然这个前提基本上所有攻击都必须得有）；</li>
<li>攻击者需要事先决定好完成攻击过程的所有gadgets。对于上面提到的赋值操作，总共只需要3个gadgets，每个gadget最长两条指令，但是如果需要进行一些复杂的操作，就有可能需要有很多gadgets；除了gadgets的数量多之外，单个gadget的指令数也需要考虑；</li>
<li>攻击者需要在被攻击程序所在的进程地址空间中找到所有的这些gadgets的首地址，并且将其填在栈的合适位置上。</li>
</ul>


<p>这三个前提条件，造成了传统的ROP对于攻击者来说具备了一定的难度，加上现在操作系统中的一系列保护机制（比如ASLR），使得寻找gadgets的地址变得更难了。而且对于攻击者来说，他攻击每个不同的应用程序都需要单独精心构造大量的gadgets，这也使得ROP的可复用性变得很差。</p>

<p>以上的这些，都是我们接下来将要介绍的SROP所想要解决的问题。</p>

<h3>SROP攻击原理</h3>

<p>SROP的全称是Sigreturn Oriented Programming。在这里<code>sigreturn</code>是一个系统调用，它在unix系统发生signal的时候会被间接地调用。</p>

<p>在开始介绍SROP的攻击原理之前，我们需要先对signal的背景进行一个简单的说明。</p>

<h4>Signal in Unix-like System</h4>

<p>Signal这套机制在1970年代就被提出来并整合进了UNIX内核中，它在现在的操作系统中被使用的非常广泛，比如内核要杀死一个进程（<code>kill -9 $PID</code>），再比如为进程设置定时器，或者通知进程一些异常事件等等。</p>

<p>如下图所示，当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）。</p>

<p><img src="http://ytliu.info/images/2015-11-27-2.png" title="Process of Signal Handling" alt="Signal Process" /></p>

<p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p>

<p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p>

<p><img src="http://ytliu.info/images/2015-11-27-3.png" title="Signal Frame" alt="Signal Frame" /></p>

<p>我们将这段内存称为一个<code>Signal Frame</code>。</p>

<p>在内核<code>sigreturn</code>系统调用处理函数中，会根据当前的栈指针指向的<code>Signal Frame</code>对进程上下文进行恢复，并返回用户态，从挂起点恢复执行。</p>

<p>看到这里，你看出什么问题了吗？如果还没有，建议你再倒回去仔细想想，因为我马上就要揭晓答案了。</p>

<h4>Signal机制缺陷利用</h4>

<p>好了，我们先来看看内核在这个过程中扮演了什么角色？首先，内核替用户进程将其上下文保存在<code>Signal Frame</code>中，然后，内核利用这个<code>Signal Frame</code>恢复用户进程的上下文，done！那么，问题来了：</p>

<ul>
<li>第一，这个<code>Signal Frame</code>是被保存在用户进程的地址空间中的，是用户进程可读写的；</li>
<li>第二，内核并没有将保存的过程和恢复的过程进行一个比较，也就是说，在<code>sigreturn</code>这个系统调用的处理函数中，内核并没有判断当前的这个<code>Signal Frame</code>就是之前内核为用户进程保存的那个<code>Signal Frame</code>。</li>
</ul>


<p>按照作者slides里面的说法，“kernel agnostic about signal handlers”既是一个优点，因为内核不需要花精力来记录其发起的signal，但是，这也是一个缺点，正因为内核对其的不可知性，使得恶意的用户进程可以对其进行伪造！</p>

<h4>例子：一个最简单的攻击</h4>

<p>让我们先来假设一个攻击者可以控制用户进程的栈，那么它就可以伪造一个<code>Signal Frame</code>，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-4.png" title="Faked Signal Frame" alt="Fake Signal Frame" /></p>

<p>在这个伪造的<code>Signal Frame</code>中，将<code>rax</code>设置成59（即<code>execve</code>系统调用号），将<code>rdi</code>设置成字符串<code>/bin/sh</code>的地址（该字符串可以是攻击者写在栈上的），将<code>rip</code>设置成系统调用指令<code>syscall</code>的内存地址，最后，将<code>rt_sigreturn</code>手动设置成<code>sigreturn</code>系统调用的内存地址。那么，当这个伪造的<code>sigreturn</code>系统调用返回之后，相应的寄存器就被设置成了攻击者可以控制的值，在这个例子中，一旦<code>sigreturn</code>返回，就会去执行<code>execve</code>系统调用，打开一个shell。</p>

<p>这是一个最简单的攻击。在这个攻击中，有4个前提条件：</p>

<ul>
<li>第一，攻击者可以通过stack overflow等漏洞控制栈上的内容；</li>
<li>第二，需要知道栈的地址（比如需要知道自己构造的字符串<code>/bin/sh</code>的地址）；</li>
<li>第三，需要知道<code>syscall</code>指令在内存中的地址；</li>
<li>第四，需要知道<code>sigreturn</code>系统调用的内存地址；</li>
</ul>


<p>和传统的ROP相比，这个最简单的SROP攻击只需要找到两个gadgets就可以了。但是在这个攻击中，攻击者所产生的效果只能调用一个syscall，当syscall返回之后就失去了对执行流的控制了，显然不能满足大部分要求。</p>

<h4>利用SROP构造系统调用串（System Call Chains）</h4>

<p>那么，我们如何利用上面这套机制来连续地进行系统调用呢？其实方法很简单，除了上面的步骤之外，只需要再额外添加一个对栈指针<code>rsp</code>的控制就行了，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-5.png" title="Faked Signal Frame for System Call Chain" alt="System Call Chain" /></p>

<p>另外我们需要把原来单纯的<code>syscall</code> gadget换成<code>syscall; ret</code> gadget。在这个过程中，每次<code>syscall</code>返回之后，栈指针都会指向下一个<code>Signal Frame</code>，因此，在这个时候执行<code>ret</code>指令，就会再次调用<code>sigreturn</code>系统调用。这样就可以通过操作栈来达到连续进行系统调用的效果。</p>

<h4>两个重要的gadgets</h4>

<p>那么，我们在哪里能找到上面提到的这两个gadgets呢？</p>

<p>对于第一个gadget <code>sigreturn</code>，这里需要提一下，<code>sigreturn</code>这个系统调用和别的系统调用有一个不同的地方，即一般的应用程序不会主动调用它，而是像之前介绍的，由内核将相应地址填到栈上，使得应用进程被动地调用。因此在系统中一般会有一段代码专门用来调用<code>sigreturn</code>，论文作者发现，在不同的类UNIX系统中，这段代码会出现在不同的位置，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-6.png" title="sigreturn gadget in memory" alt="sigreturn gadget location" /></p>

<p>其中在<code>Linux &lt; 3.11 ARM</code>（也就是大部分现在Android所使用的内核），以及<code>FreeBSB 9.2 x86_64</code>，都可以在固定的内存地址中找到这个gadget，而在其它系统中，一般被保存在<code>libc</code>库的内存中，如果有ASLR保护的话似乎没有那么容易找到。</p>

<p>而对于第二个gadget <code>syscall; ret</code>，如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-7.png" title="syscall ret gadget in memory" alt="syscall ret gadget location" /></p>

<p>如果是<code>Linux &lt; 3.3 x86_64</code>（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），则可以直接在固定地址[vsyscall]中找到这段代码片段。其中<code>vsyscall</code>是用来加速<code>time()</code>，<code>gettimeofday()</code>和<code>getcpu()</code>这三个系统调用的机制，虽然现在已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制所代替，但在稍微比较早一点的内核中依然是被默认支持的。具体可以看<a href="http://lwn.net">lwn</a>的<a href="https://lwn.net/Articles/446528/">这个post</a>。</p>

<p>除了上面提到的这两个可能存在在固定地址的gadgets之外，在其它系统中，这两个gadgets似乎并没有那么容易找到，特别是在有ALSR保护的系统中。但是，如果我们将其和传统的ROP来进行比较的话，就可以发现，它把整个攻击的代价拉低了一个档次，难怪作者认为SROP &#8220;is among the lowest hanging fruit available to an attacker.&#8221;</p>

<h4><code>sigreturn</code>这个gadget是必须的吗？</h4>

<p>如果我们将<code>sigreturn</code>当做一个系统调用来看待的话，那么其实这个单独的gadget并不是必须的。因为我们可以将<code>rax</code>寄存器设置成15（sigreturn的系统调用号），然后调用一个<code>syscall</code>，效果和调用一个<code>sigreturn</code>是一样一样的。那么，问题就从“如何找到一个<code>sigreturn</code> gadget”变成了“如何控制寄存器<code>rax</code>的值”。而<code>rax</code>这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制<code>rax</code>寄存器的值。具体的做法因人而异，但是这为攻击者提供了另外一个思路，有兴趣可以去看论文。在论文中，简单来说，作者在受害者进程调用对网络文件描述符进行<code>read</code>系统调用的时候传输不同数量的字节数来控制<code>read</code>调用的返回值，来最终达到控制<code>rax</code>寄存器的效果的，非常smart的一个做法！</p>

<h4>SROP应用场景</h4>

<p>正如上文所说，利用SROP，我们可以构造一系列的系统调用串，利用这个方法，我们可以做很多事情。</p>

<h5>应用场景一：后门（Backdoor）</h5>

<p>首先，作者提出，可以通过这种方法构造一个后门（backdoor）。后门的意思就是攻击者在系统中隐藏一个可以被触发的点，当某些比较少见的特定操作发生之后，会触发一个动作，这个动作一般是打开一个端口让攻击者通过网络连接进系统，从而对系统进行控制。后门最重要的特点是隐蔽，不容易被杀毒软件检查出来。所以说如果后门是一段可执行代码，那么就很容易被杀毒软件检测到，而如果后门是隐藏在数据域中，那么就能做到非常隐蔽。SROP就为其提供了一个强有力的工具：system call chain。整个过程如下图所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-8.png" title="SROP backdoor" alt="SROP backdoor" /></p>

<p>在这个过程中，攻击者利用<code>inotify API</code>来监控一个文件，当这个文件被访问（比如攻击者在发起的请求中读取这个文件的内容），则后续的系统调用链被触发，打开一个socket，等待连接。同时通过一个<code>alarm</code>系统调用设置一个定时器，如果在5秒钟没有人对这个socket发起连接请求，则将其关闭，否则建立连接，并调用<code>execve</code>系统调用打开一个shell。</p>

<p>这就是一个典型的后门，可以用SROP完成。</p>

<h5>应用场景二：系统调用代理（System call proxy）</h5>

<p>在这个应用场景中，作者提到了如何绕过诸如<code>iOS</code>、<code>Mac OS X</code>等系统进行的代码签名（code signing）保护机制。在代码签名保护机制下，程序中不能存在恶意代码片段（否则无法经过Apple官方的验证）。但是SROP可以解决这个问题，我们可以在代码中进行一个网络连接，然后通过构造特定的请求来执行一些恶意的操作。在这里，作者提出一种系统调用代理的机制，原理和我之前介绍的系统调用串的原理差不多，就是通过执行一系列的<code>read</code>系统调用来设置各个参数，最后利用这些参数构造一个特定的系统调用，如下如所示：</p>

<p><img src="http://ytliu.info/images/2015-11-27-9.png" title="SROP syscall proxy" alt="SROP syscall proxy" /></p>

<h3>SROP的防范</h3>

<p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p>

<h4>Gadgets Prevention</h4>

<p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p>

<p>当然这种方法并不能从本质上解决SROP的问题。</p>

<h4>Signal Frame Canaries</h4>

<p>这种方法借鉴于<a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p>

<p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p>

<h4>Break kernel agnostic</h4>

<p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p>

<h3>Proof of Concept（PoC）</h3>

<p>如果大家对这个攻击感兴趣，可以从这里下载一个非常简单的<a href="https://github.com/eQu1NoX/srop-poc">PoC</a>，当然按照其作者的说法，SROP已经被整合进<a href="https://binjitsu.readthedocs.org/">binjitsu</a>这个框架了。之后如果有时间，我也会对这个PoC以及binjitsu框架做一个介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hooking and Hijacking Android Native Code]]></title>
    <link href="http://ytliu.github.io/blog/2015/11/15/hooking-and-hijacking-android-native-code/"/>
    <updated>2015-11-15T15:04:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/11/15/hooking-and-hijacking-android-native-code</id>
    <content type="html"><![CDATA[<p>首先声明这是一篇中文博客。</p>

<p>先强烈推荐下<a href="http://appsrv.cse.cuhk.edu.hk/~mzheng/">Zheng Min</a>大神的<a href="http://drops.wooyun.org/author/%E8%92%B8%E7%B1%B3">安卓动态调试七种武器系列文章</a>，里面已经有两篇介绍我这次所要介绍的hooking的内容了，而且应该会比我这篇的内容更丰富。然而，任性的我还是要写这篇博客，原因除了自己太久没写博客了有点不好意思之外，更重要的是希望在写的过程中来理解这个技术。</p>

<p>当然了，这篇博文主要还是代码分析，采用的是<a href="http://www.mulliner.org/collin/">Collin Mulliner</a>的这个项目<a href="https://github.com/crmulliner/adbi">adbi</a>。当然他自己也有一个专门的<a href="http://www.mulliner.org/android/feed/binaryinstrumentationandroid_mulliner_summercon12.pdf">slide</a>来介绍里面用到的技术。</p>

<!-- more -->


<p>好了，开始进入正文。</p>

<p>首先clone这个项目：</p>

<pre><code>$ git clone https://github.com/crmulliner/adbi.git
</code></pre>

<p>在具体分析代码之前先简单介绍下这个项目的目的、用法、以及流程吧：</p>

<h4>目的</h4>

<p>对android中的某个进程所使用的某个native库<code>lib</code>中的某个函数<code>func</code>进行劫持，使得当这个进程调用到这个函数的时候，会首先进入我们的hook函数，在hook函数中做一些其它的事情，比如打印一些log之类的，然后再调用真正的函数<code>func</code>。</p>

<h4>用法</h4>

<ul>
<li><p>对项目进行编译，会生成一个可执行文件<code>hijack</code>和一个链接库文件<code>libexample.so</code>，将其放到<code>/data/local/tmp</code>目录下：</p>

<pre><code>$ adb push hijack/libs/armeabi/hijack /data/local/tmp/
$ adb push instruments/example/libs/armeabi/libexample.so /data/local/tmp/
</code></pre></li>
<li><p>然后进入android的adb shell里面，运行：</p>

<pre><code>$ adb shell
$ su
# cd /data/local/tmp
# ./hijack -d -p PID -l /data/local/tmp/libexample.so
</code></pre></li>
</ul>


<p>它的作用是劫持pid为<code>PID</code>的进程的<code>epoll_wait()</code>库函数调用，每当该函数被调用，就会进到<code>libexample.so</code>中的<code>my_epoll_wait()</code> hook函数，打印一行内容，并调用真正的<code>epoll_wait()</code>函数。</p>

<h4>流程</h4>

<p>上面这整个hijacking和hooking的流程是这样的：</p>

<ul>
<li>在hijack的过程中，会将一段<code>hijack code</code>放在目标进程的栈上，调用<code>mprotect</code>将栈设置为可执行，并且将<code>mprotect</code>调用的返回值设置成这段<code>hijack code</code>的地址，因此，在mprotect返回时，就开始执行这段<code>hijack code</code>；</li>
<li>这段<code>hijack code</code>所做的事情就是调用<code>dlopen</code>，加载<code>libexample.so</code>链接库；</li>
<li>在<code>libexample.so</code>库的初始化函数中，对目标进程所调用的<code>libc</code>库中的<code>epoll_wait</code>函数进行hook；</li>
<li>之后，只要目标进程一调用<code>epoll_wait</code>函数，就会首先进入hook函数。</li>
</ul>


<hr />

<p>好了，这个流程看上去很简单，但是里面用到了很多Linux相关的知识，是一个很不错的介绍如何对进程进行hook和hijack的实例，接下来的篇幅就主要来介绍这整个流程是如何通过几百行C代码实现的。</p>

<h4>代码结构</h4>

<p>这是adbi项目的代码结构：</p>

<pre><code>|-hijack
  |-jni
    |-Android.mk
  |-hijack.c
|-instruments
  |-base
    |-jni
      |-Android.mk
      |-Application.mk
    |-base.c
    |-base.h
    |-hook.c
    |-hook.h
    |-util.c
    |-util.h
  |-example
    |-jni
      |-Android.mk
    |-epoll.c
    |-epoll_arm.c
|-README.md
|-build.sh
|-clean.sh
</code></pre>

<p>可以看到，里面主要有两个目录：<code>hijack</code>和<code>instruments</code>。其中，<code>hijack</code>主要作用就是之前流程里面说的第一步，即：</p>

<ul>
<li>将一段<code>hijack code</code>放在目标进程的栈上，调用<code>mprotect</code>将栈设置为可执行，并且将<code>mprotect</code>调用的返回值设置成这段<code>hijack code</code>的地址，因此，在mprotect返回时，就开始执行这段<code>hijack code</code>。</li>
</ul>


<p>而<code>instruments</code>目录中包含了两个子目录，一个是<code>base</code>，主要是一些可以被调用的库函数，它最终会被编译成<code>libbase.a</code>静态链接库；另外一个是<code>example</code>，它用了一个非常简单的例子来展示如何利用<code>libbase.a</code>做hook，即之前流程里面的第三步：</p>

<ul>
<li>在<code>libexample.so</code>库的初始化函数中，对目标进程所调用的<code>libc</code>库中的<code>epoll_wait</code>函数进行hook。</li>
</ul>


<h4>hijack</h4>

<p>hijack目录中只有一个代码文件：<code>hijack.c</code>，以及一个和编译相关的文件：<code>jni/Android.mk</code>。</p>

<p>我们先来看这个<code>Android.mk</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'> <span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'> <span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">hijack</span>
</span><span class='line'> <span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">hijack</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'> <span class="n">LOCAL_ARM_MODE</span> <span class="o">:=</span> <span class="n">arm</span>
</span><span class='line'> <span class="n">LOCAL_CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="n">g</span>
</span><span class='line'>
</span><span class='line'> <span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_EXECUTABLE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实这就是一个很典型的Android应用的jni的编译文件，表示它要用<code>../hijack.c</code>这个源文件编译一个可执行文件（<code>$(BUILD_EXECUTABLE)</code>）<code>hijack</code>。</p>

<p>关于<code>hijack.c</code>这个文件，我们先来看一下<code>main</code>函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span> <span class="p">((</span><span class="n">opt</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;p:l:dzms:Z:D:&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nomprotect</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;mprotect&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mprotectaddr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ldl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libdl.so&quot;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ldl</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">ldl</span><span class="p">,</span> <span class="s">&quot;dlopen&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">dlclose</span><span class="p">(</span><span class="n">ldl</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">lkaddr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkaddr2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="n">lkaddr2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlopenaddr</span> <span class="o">-</span> <span class="n">lkaddr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Attach </span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot attach to %d, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">appname</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">zygote</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;/proc/%d/mem&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span><span class='line'>  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r3</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlopenaddr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// push library name to stack</span>
</span><span class='line'>  <span class="n">libaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="n">sc</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">libaddr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">stack_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">stack_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class='line'>    <span class="n">stack_start</span> <span class="o">=</span> <span class="n">stack_start</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'>    <span class="n">stack_end</span> <span class="o">=</span> <span class="n">stack_start</span> <span class="o">+</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// write library name to stack</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">libaddr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write library name (%s) to stack, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// write code to stack</span>
</span><span class='line'>  <span class="n">codeaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">codeaddr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write code, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// calc stack pointer</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// call mprotect() to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span> <span class="o">=</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// want to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span> <span class="o">=</span> <span class="n">stack_end</span> <span class="o">-</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// stack size</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span> <span class="o">=</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">;</span> <span class="c1">// protections</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// normal mode, first call mprotect</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nomprotect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// points to loading and fixing code</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">mprotectaddr</span><span class="p">;</span> <span class="c1">// execute mprotect()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// no need to execute mprotect on old Android versions</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// just execute the &#39;shellcode&#39;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// detach and continue</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">SIGCONT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里主要有几个重要的步骤：</p>

<ul>
<li>parse传进来的参数，这个这里就不解释了；</li>
<li>定位目标进程中<code>mprotect</code>函数的内存地址；</li>
<li>定位目标进程中<code>dlopen</code>函数的内存地址；</li>
<li>利用<code>ptrace</code>调用attach目标进程；</li>
<li>构建hijack所需要的context，这里是一个数据结构<code>sc</code>；</li>
<li>将<code>sc</code>写到栈上；</li>
<li>利用之前得到的<code>mprotect</code>将栈设置成可执行，并将<code>mprotect</code>的返回值设置成<code>sc</code>数据结构中的code首地址；</li>
<li>利用<code>ptrace(PTRACE_SETREGS)</code>设置目标进程的寄存器，使得上面的所有修改生效。</li>
</ul>


<p>这个时候目标进程就开始执行<code>mprotect</code>和<code>sc</code>中的code代码了。</p>

<p>接下来我们来逐一介绍各个步骤：</p>

<h5>定位目标进程中<code>mprotect</code>函数的内存地址；</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="s">&quot;mprotect&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mprotectaddr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们来看一下<code>find_name</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span>
</span><span class='line'><span class="nf">find_name</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">load_memmap</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmm</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">find_libc</span><span class="p">(</span><span class="n">libc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">libc</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">libcaddr</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">nmm</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">load_symtab</span><span class="p">(</span><span class="n">libc</span><span class="p">);</span>
</span><span class='line'>  <span class="n">lookup_func_sym</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>里面主要分为四个步骤：</p>

<ul>
<li><code>load_memmap</code>：主要是通过读取特定<code>/proc/PID/maps</code>文件，获得该进程打开的所有动态链接库的地址和其它相关内存地址（如栈的地址），并将所有这些信息存储在<code>mm</code>这个数据结构中；</li>
<li><code>find_libc</code>：在mm中查找<code>libc</code>，并将其首地址填到<code>libcaddr</code>变量中；</li>
<li><code>load_symtab</code>：打开libc对应的库文件，根据elf格式将里面的symbol table解析出来，并且填入数据结构<code>symtab_t</code>中，并返回；</li>
<li><code>lookup_func_sym</code>：在这一堆的symbol table里面找到对应的函数名，并且写入变量<code>addr</code>中。</li>
</ul>


<p>通过以上四个步骤，即可得到进程中<code>mprotect</code>的内存地址。</p>

<h5>定位目标进程中<code>dlopen</code>函数的内存地址；</h5>

<p>获取<code>dlopen</code>的方法和之前获取<code>mprotect</code>的方法不太一样，主要原因是在于<code>dlopen</code>所在的库<code>libdl.so</code>在程序运行时是不会显示在该进程对应的<code>/proc/PID/maps</code>中的，因此需要先在本进程中先用<code>dlopen</code>开启<code>libdl.so</code>，然后通过相对地址的计算方法来获得目标进程中dlopen的内存地址，具体步骤如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ldl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libdl.so&quot;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ldl</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">ldl</span><span class="p">,</span> <span class="s">&quot;dlopen&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">dlclose</span><span class="p">(</span><span class="n">ldl</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">lkaddr2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">getpid</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">lkaddr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">find_linker</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkaddr2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dlopenaddr</span> <span class="o">=</span> <span class="n">lkaddr2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlopenaddr</span> <span class="o">-</span> <span class="n">lkaddr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>首先在本进程调用<code>dlopen</code>打开<code>libdl.so</code>（dlopen的用法可参照<a href="http://linux.die.net/man/3/dlopen">这里</a>)；</li>
<li>利用<code>dlsym</code>获得<code>libdl.so</code>中<code>dlopen</code>函数的内存地址；</li>
<li>分别获得本进程和目标进程中<code>linker</code>的地址；</li>
<li>通过<code>dlopen</code>和<code>linker</code>的相对偏移一样的原理来计算目标进程中<code>dlopen</code>的真正内存地址。</li>
</ul>


<p>获得linder的内存地址的方法和获得<code>mprotect</code>函数内存地址的方法类似，这里就不阐述了，主要代码在<code>find_linker_mem</code>和<code>find_linker</code>这两个函数中。</p>

<h5>利用<code>ptrace</code>调用attach目标进程；</h5>

<p>这个步骤就两句话：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class="c1">// Attach </span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="err">；</span>
</span><span class='line'>  <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于什么是<code>ptrace</code>和<code>waitpid</code>，以及如何使用它们，请参考我之前的一篇博客：<a href="http://ytliu.info/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace/">系统调用学习笔记 - Ptrace和wait</a>，这里就不详细说了。</p>

<h5>构建hijack所需要的context，这里是一个数据结构<code>sc</code>；</h5>

<p>其实<code>sc</code>就是一个长度为20的<code>unsigned int</code>数组：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="mh">0xe59f0040</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #64]   ; 48 &lt;.text+0x48&gt;</span>
</span><span class='line'><span class="mh">0xe3a01000</span><span class="p">,</span> <span class="c1">//        mov     r1, #0  ; 0x0</span>
</span><span class='line'><span class="mh">0xe1a0e00f</span><span class="p">,</span> <span class="c1">//        mov     lr, pc</span>
</span><span class='line'><span class="mh">0xe59ff038</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #56]   ; 4c &lt;.text+0x4c&gt;</span>
</span><span class='line'><span class="mh">0xe59fd02c</span><span class="p">,</span> <span class="c1">//        ldr     sp, [pc, #44]   ; 44 &lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe59f0010</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #16]   ; 30 &lt;.text+0x30&gt;</span>
</span><span class='line'><span class="mh">0xe59f1010</span><span class="p">,</span> <span class="c1">//        ldr     r1, [pc, #16]   ; 34 &lt;.text+0x34&gt;</span>
</span><span class='line'><span class="mh">0xe59f2010</span><span class="p">,</span> <span class="c1">//        ldr     r2, [pc, #16]   ; 38 &lt;.text+0x38&gt;</span>
</span><span class='line'><span class="mh">0xe59f3010</span><span class="p">,</span> <span class="c1">//        ldr     r3, [pc, #16]   ; 3c &lt;.text+0x3c&gt;</span>
</span><span class='line'><span class="mh">0xe59fe010</span><span class="p">,</span> <span class="c1">//        ldr     lr, [pc, #16]   ; 40 &lt;.text+0x40&gt;</span>
</span><span class='line'><span class="mh">0xe59ff010</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #16]   ; 44 &lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r0</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r1 </span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r2 </span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     r3 </span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     lr </span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     pc</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     sp</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     addr of libname</span>
</span><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     dlopenaddr</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>sc[0]</code>~<code>sc[10]</code>是一段汇编指令，而<code>sc[11]</code>~<code>sc[19]</code>则是保存了<code>r0~r3</code>、<code>lr</code>、<code>pc</code>和<code>sp</code>这六个寄存器的值，以及需要加载的库libname的地址，和<code>dlopen</code>函数的内存地址。</p>

<p>其中，这六个寄存器的值是通过：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>从目标进程中获得的，而<code>dlopenaddr</code>就是之前获得的<code>dlopen</code>的地址。<code>libaddr</code>的获得是通过这段代码获得的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">libaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'><span class="n">sc</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">libaddr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>n*4</code>是需要加载的库（即<code>/data/local/tmp/libexample.so</code>）的文件名长度，所以，<code>/data/local/tmp/libexample.so</code>这个字符串就被放在了<code>sc</code>数据结构的下方。</p>

<p>有了以上的值，我们来具体看看这段汇编指令到底在做什么：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe59f0040</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #64]   ; 48 &lt;.text+0x48&gt;</span>
</span><span class='line'><span class="mh">0xe3a01000</span><span class="p">,</span> <span class="c1">//        mov     r1, #0  ; 0x0</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有一个trick需要先解释一下，即如何通过<code>pc</code>来进行寻址。<code>pc</code>即表示当前程序运行指令的内存地址，<code>[pc, #n]</code>则表示<code>pc+n</code>指针所指向的那个地址。但是这里有一点需要注意的，在我们执行这条语句的时候：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ldr</span>     <span class="n">r0</span><span class="p">,</span> <span class="p">[</span><span class="n">pc</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>pc</code>已经不再是当前指令的内存地址了，而是自动被加了8，即这里的<code>pc</code>其实是<code>pc+8</code>那条指令的内存地址，所以<code>[pc, #64]</code>其实指向的是和当前指令内存地址偏移72 bytes的地址，如果你算一下会发现是</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe1a00000</span><span class="p">,</span> <span class="c1">//        nop                     addr of libname</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，<code>r0</code>的值就是指向<code>/data/local/tmp/libexample.so</code>这个字符串的地址。而<code>r1</code>的值是1，即<code>RTLD_LAZY</code>的值。</p>

<p>而接下来的这两条指令：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe1a0e00f</span><span class="p">,</span> <span class="c1">//        mov     lr, pc</span>
</span><span class='line'><span class="mh">0xe59ff038</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #56]   ; 4c &lt;.text+0x4c&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先将<code>pc</code>值（<code>pc+8</code>的地址）付给了<code>lr</code>，即调用完函数之后的返回值，然后同样利用<code>pc</code>的寻址方式将<code>dlopenaddr</code>的值赋给了<code>pc</code>，因此，接下来就会调用<code>dlopen</code>函数，第一个参数是<code>r0</code>的值，即指向<code>/data/local/tmp/libexample.so</code>字符串的指针，第二个参数是<code>r1</code>的值，即<code>RTLD_LAZY</code>。</p>

<p>当<code>dlopen</code>返回之后，程序的执行流会跳到<code>lr</code>指向的内存地址，即接下来的这段代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0xe59fd02c</span><span class="p">,</span> <span class="c1">//        ldr     sp, [pc, #44]   ; 44 &lt;.text+0x44&gt;</span>
</span><span class='line'><span class="mh">0xe59f0010</span><span class="p">,</span> <span class="c1">//        ldr     r0, [pc, #16]   ; 30 &lt;.text+0x30&gt;</span>
</span><span class='line'><span class="mh">0xe59f1010</span><span class="p">,</span> <span class="c1">//        ldr     r1, [pc, #16]   ; 34 &lt;.text+0x34&gt;</span>
</span><span class='line'><span class="mh">0xe59f2010</span><span class="p">,</span> <span class="c1">//        ldr     r2, [pc, #16]   ; 38 &lt;.text+0x38&gt;</span>
</span><span class='line'><span class="mh">0xe59f3010</span><span class="p">,</span> <span class="c1">//        ldr     r3, [pc, #16]   ; 3c &lt;.text+0x3c&gt;</span>
</span><span class='line'><span class="mh">0xe59fe010</span><span class="p">,</span> <span class="c1">//        ldr     lr, [pc, #16]   ; 40 &lt;.text+0x40&gt;</span>
</span><span class='line'><span class="mh">0xe59ff010</span><span class="p">,</span> <span class="c1">//        ldr     pc, [pc, #16]   ; 44 &lt;.text+0x44&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的作用就是恢复这6个寄存器，最后会恢复<code>pc</code>，因此程序重新回到原来的执行流中。</p>

<p>总结一下，<code>sc</code>里面的<code>hijack code</code>的主要作用就是调用一下<code>dlopen</code>加载<code>/data/local/tmp/libexample.so</code>，然后回到正常的执行流中。</p>

<h5>将<code>sc</code>写到栈上；</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// write code to stack</span>
</span><span class='line'>  <span class="n">codeaddr</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">write_mem</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">codeaddr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cannot write code, error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>write_mem</code>的实现非常简单，就是调用了<code>ptrace(PTRACE_POKETEXT)</code>将数据写到目标进程的内存空间中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Write NLONG 4 byte words from BUF into PID starting</span>
</span><span class='line'><span class="cm">   at address POS.  Calling process must be attached to PID. */</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span>
</span><span class='line'><span class="nf">write_mem</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlong</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlong</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKETEXT</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">pos</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>利用之前得到的<code>mprotect</code>将栈设置成可执行，并将<code>mprotect</code>的返回值设置成<code>sc</code>数据结构中的code首地址；</h5>

<p>代码如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// calc stack pointer</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">.</span><span class="n">ARM_sp</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="mi">4</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// call mprotect() to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r0</span> <span class="o">=</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// want to make stack executable</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r1</span> <span class="o">=</span> <span class="n">stack_end</span> <span class="o">-</span> <span class="n">stack_start</span><span class="p">;</span> <span class="c1">// stack size</span>
</span><span class='line'>  <span class="n">regs</span><span class="p">.</span><span class="n">ARM_r2</span> <span class="o">=</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">;</span> <span class="c1">// protections</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// normal mode, first call mprotect</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nomprotect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_lr</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// points to loading and fixing code</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">mprotectaddr</span><span class="p">;</span> <span class="c1">// execute mprotect()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// no need to execute mprotect on old Android versions</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">regs</span><span class="p">.</span><span class="n">ARM_pc</span> <span class="o">=</span> <span class="n">codeaddr</span><span class="p">;</span> <span class="c1">// just execute the &#39;shellcode&#39;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要就是计算出栈的首地址和长度，然后将目标进程的<code>pc</code>设置成<code>mprotectaddr</code>，将返回地址<code>lr</code>设置成<code>sc</code>中<code>hijack code</code>的起始地址。这样在调用完<code>mprotect</code>之后就能直接执行<code>hijack code</code>了。</p>

<h5>利用<code>ptrace(PTRACE_SETREGS)</code>设置目标进程的寄存器，使得上面的所有修改生效。</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="c1">// detach and continue</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regs</span><span class="p">);</span>
</span><span class='line'>  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">SIGCONT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，hijack的全部功能就实现了，现在<code>/data/local/tmp/libexample.so</code>已经被加载到了目标进程的内存空间中，接下来就要看下这个库里面到底是如何实现特定函数的hook的。</p>

<h4>hook</h4>

<p>在<code>instruments</code>这个目录下有两个子目录，其中<code>base</code>相当于是一个函数库，它会被编译成静态链接库<code>libbase.a</code>，我们可以看下<code>instruments/base/jni/Android.mk</code>这个文件：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">util</span><span class="p">.</span><span class="n">c</span> <span class="p">..</span><span class="o">/</span><span class="n">hook</span><span class="p">.</span><span class="n">c</span> <span class="p">..</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">LOCAL_ARM_MODE</span> <span class="o">:=</span> <span class="n">arm</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_STATIC_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>而<code>example</code>里面的代码会将<code>libbase.a</code>静态链接进来，然后生成一个动态链接库<code>libexample.so</code>，可以从其编译文件<code>instruments/example/jni/Android.mk</code>看出来：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">LOCAL_PATH</span> <span class="o">:=</span> <span class="err">$</span><span class="p">(</span><span class="n">call</span> <span class="n">my</span><span class="o">-</span><span class="n">dir</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'><span class="n">LOCAL_MODULE</span> <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">base</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">libbase</span><span class="p">.</span><span class="n">a</span>
</span><span class='line'><span class="n">LOCAL_EXPORT_C_INCLUDES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">base</span>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">PREBUILT_STATIC_LIBRARY</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">CLEAR_VARS</span><span class="p">)</span>
</span><span class='line'><span class="n">LOCAL_MODULE</span>    <span class="o">:=</span> <span class="n">libexample</span>
</span><span class='line'><span class="n">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="p">..</span><span class="o">/</span><span class="n">epoll</span><span class="p">.</span><span class="n">c</span>  <span class="p">..</span><span class="o">/</span><span class="n">epoll_arm</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">arm</span>
</span><span class='line'><span class="n">LOCAL_CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="n">g</span>
</span><span class='line'><span class="n">LOCAL_SHARED_LIBRARIES</span> <span class="o">:=</span> <span class="n">dl</span>
</span><span class='line'><span class="n">LOCAL_STATIC_LIBRARIES</span> <span class="o">:=</span> <span class="n">base</span>
</span><span class='line'><span class="n">include</span> <span class="err">$</span><span class="p">(</span><span class="n">BUILD_SHARED_LIBRARY</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个example非常简单，它也只有一个文件（<code>epoll.c</code>），里面只有几十行代码，我们先来看下这个库的初始化函数<code>my_init</code>，这个函数会在该库被加载的时候运行一次：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">counter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">log</span><span class="p">(</span><span class="s">&quot;%s started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">set_logfunction</span><span class="p">(</span><span class="n">my_log</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eph</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="s">&quot;libc.&quot;</span><span class="p">,</span> <span class="s">&quot;epoll_wait&quot;</span><span class="p">,</span> <span class="n">my_epoll_wait_arm</span><span class="p">,</span> <span class="n">my_epoll_wait</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>里面主要是调用了<code>libbase.a</code>提供的<code>hook</code>函数（源文件为<code>instruments/base/hook.c</code>）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">libname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">funcname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hook_arm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hook_thumb</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">find_name</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">libname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strncpy</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">thumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">hook_arm</span><span class="p">;</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe59ff000</span><span class="p">;</span> <span class="c1">// LDR pc, [pc, #0]</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="n">h</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数其实是区分了ARM指令集和THUMB指令集的，为了简化，我们暂时只考虑ARM指令，即这里的<code>(addr % 4 == 0)</code>的情况。</p>

<p>首先，这里先找到需要被hook的目标库（<code>libname</code>）的目标函数（<code>funcname</code>）的内存地址，这里需要注意的，由于<code>libexample.so</code>这个库已经是在目标进程的进程空间中运行了，所以其获得的地址即为目标函数在目标进程中的地址。这里的<code>find_name</code>所用到的技术和<code>hijack.c</code>里面用到的技术基本是一样的，这里就不详述了。</p>

<p>在获得目标函数代码的首地址之后，将其赋值给<code>h-&gt;orig</code>这个变量，将这个该函数的前三条指令保存在<code>h-&gt;store</code>这个数组中，并将以下三条指令覆盖（overwrite）目标函数的前三条指令：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xe59ff000</span><span class="p">;</span> <span class="c1">// LDR pc, [pc, #0]</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
</span><span class='line'>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>h-&gt;patch</code>即为hook函数的地址，在example里面是<code>my_epoll_wait</code>。同样的，这里又一次用到了利用<code>pc</code>进行寻址的技术，可以看前面的内容，这里也不详述了。</p>

<p>最后，调用了一个<code>hook_cacheflush</code>函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的主要作用就是刷新指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了，再执行的话，CPU可能会优先执行缓存中的指令，使得修改的指令得不到执行。所以我们需要使用一个隐藏的系统调用来刷新一下缓存。</p>

<p>至此，目标进程目标函数的hook工作也就完成了。最后我们来看一下这个hook函数<code>my_epoll_wait</code>做了什么：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">my_epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">orig_epoll_wait</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">eph</span><span class="p">.</span><span class="n">orig</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">hook_precall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eph</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">orig_epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">counter</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">hook_postcall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eph</span><span class="p">);</span>
</span><span class='line'>    <span class="n">log</span><span class="p">(</span><span class="s">&quot;epoll_wait() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">counter</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">counter</span><span class="p">)</span>
</span><span class='line'>      <span class="n">log</span><span class="p">(</span><span class="s">&quot;removing hook for epoll_wait()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实这个函数非常简单，就是在前<code>count</code>次调用<code>epoll_wait</code>的时候打印一下。这里面有两个<code>libbase.a</code>中的函数：<code>hook_precall</code>和<code>hook_postcall</code>。我们来分别看一下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">hook_precall</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">storet</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>hook_precall</code>的主要作用是恢复目标函数的前三条指令，这里同样对ARM指令和THUMB指令做了区分。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">hook_postcall</span><span class="p">(</span><span class="k">struct</span> <span class="n">hook_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">thumb</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>      <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">jump</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">hook_cacheflush</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">orig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">jumpt</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而<code>hook_postcall</code>则是重新用hook函数覆盖目标函数的前三条指令。</p>

<hr />

<p>好了，到这里，adbi里面的代码基本上就分析完了。最后简单描述下什么是ARM指令和THUMB指令吧。</p>

<h4>ARM vs. THUMB</h4>

<p>在传统的RISC模式的指令集中，指令都是定长的，比如ARM指令的长度都是32-bits。定长的好处在于处理器处理起来效率高，但是缺点也是显而易见的，即浪费空间。所以又引入了THUMB指令。</p>

<p>THUMB指令可以看作是ARM指令压缩形式的子集，所谓子集，即THUMB指令集中的所有指令都可以被32-bits的ARM指令所替代，而并非所有ARM指令都有对应的THUMB指令。</p>

<p>所以可以说THUMB模式是ARM在时间和空间中的一个权衡，因此，在普通的ARM可执行文件中，ARM指令和THUMB指令是同时存在的，所以在做诸如分析、攻击等操作的时候需要同时考虑两种模式的存在，这也是adbi为什么会需要区分对待ARM和THUMB的原因吧。</p>

<p>ARM和THUMB的具体区别这里就不介绍了，网上这种资料一搜一大堆，有兴趣的还是自己慢慢研究吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes in CCS 2015 (Denver)]]></title>
    <link href="http://ytliu.github.io/blog/2015/10/18/notes-in-ccs-2015/"/>
    <updated>2015-10-18T14:41:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/10/18/notes-in-ccs-2015</id>
    <content type="html"><![CDATA[<p>This week I&#8217;ve been to Denver, Colorado, to attend the CCS 2015 and present our work SeCage, which is a hypervisor-enforced approach for intra-domain isolation.</p>

<p>The main conference lasts for 3 days (10.13 ~ 10.15). There are 3 parallel tracks for 36 sessions, for specific reasons, I have only attended 6 sessions.</p>

<p>Following are some of the notes about what I&#8217;ve heard from these sessions.</p>

<!-- more -->


<h4>Session 1B: iOS and MAC OS Security</h4>

<p>This is a very interesting session that shows the security of iOS/Mac OS. There are 2 papers in this session.</p>

<p>The first is presented by Luyi Xing from Indiana Univercity Bloomington. As he shows, from 2010 to yesterday, in the 4 top security conferences (S&amp;P, Usenix securiy, CCS, NDSS), there were 0 session with 3 papers discussing about iOS security, compared to the 17 sessions with 88 papers about Android security.</p>

<p>The paper presented by Xing is titled <em>&#8220;Cracking App Isolation on Apple: Unauthorized Cross-App Resource Access on MAC OS X and iOS&#8221;</em>. This is an attack paper that shows several ways to attack iOS/Mac OS with full protection (e.g., sandboxing isolating, indirect interaction, direct communication, vetting), and results in the leakage of private data like passwords, tokens, cookies, etc.</p>

<p>This presentation only shows 2 kinds of so-called Unauthorized cross-app resource access (XARA) approaches. the first one is to crack keychain and steal password, while the second one is to intercept IPC using the bugs in distributed objects mechanism, and steal the tokens from Evernote server.</p>

<p>The details can be found in the paper, it shows many interesting points, like the lessons of unclear boundary of responsibilities between developer and Apple, etc. This paper is also armed with 3 Apple CVEs (CVE-2015-3786, CVE-2015-5835, CVE-2015-5836). Thus it is a very typical security paper. I&#8217;m going to read it later.</p>

<p>The second presentation is from Brendan Saltaformaggio, Purdue University. It is noted that Brendan have 3 papers in this year&#8217;s CCS, one of which wins the best paper award!</p>

<p>In this presentation, he starts with a very interesting statistics:</p>

<p>As Apple claimed, all applications will be protected by the vetting mechanism. However how well is the vetting performed is under question. In 2015 till now, there are 1.5 million new applications created in apple store, which means 556 application vetting per day! Therefore it is reasonable to say that the vetting process is fast, lightweight, &#8216;almost&#8217; automatic and may use static program analysis.</p>

<p>This paper is targeted at solving the problem of finding private API abuse in the application. Private API is supposed only used by Apple Internal. However since the function call in Objective-C can be called by sending a message to object, e.g.,</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">object_msgSend</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>can be used to invoke a function <code>foo</code> of object <code>obj</code>. Thus following trick can alse be leveraged to invoke <code>foo</code> function:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">char</span> <span class="n">sel</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'><span class="n">strcpy</span> <span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="err">“</span><span class="n">f</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="n">strcat</span> <span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="err">“</span><span class="n">oo</span><span class="err">”</span><span class="p">)</span>
</span><span class='line'><span class="n">object_msgSend</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>So it is really hard for static analysis to detect such private API abuse (if foo is a private API).</p>

<p>This this paper, they use static analyssi + Guided forced exection (dynamic analysis) to solve such problem. For static analysis, they use backward slicing, which is vulnerable for obfuscation. Then they use an approach called <code>force execution</code>, to complete the analysis. During force execution, in every branch, the condition is flipped, so that every branch can be reached.</p>

<p>Since I&#8217;m not familiar with program analysis, it is a little hard for me to fully understand it. More details can be found in the paper.</p>

<h4>Session 2C: Password Security</h4>

<p>Honestly speaking, I&#8217;m not quite interested in papers of this session, just have a simple note for each of the paper:</p>

<ul>
<li>The 1st one is titled <em>&#8220;Monte Carlo Strength Evaluation: Fast and Reliable Password Checking&#8221;</em>, is to use the probabilistic password models to design a scientifically sound password strength meter.</li>
<li>The 2nd one is titled <em>&#8220;Surpass: System-initiated user-replaceable passwords&#8221;</em>, the motivation is that random passwords are secure, but hard to memorized. Thus they design a mechanism that user can replace password initialized by system randomly for memorable. They have done many surveys on the tradeoff between entropy and memorability, and provide some statistic conclusion. Some interesting points is that they use large-scale amazone mechanical turk for recruiting 5312 anticipator, and use hashcat for cracking passwords.</li>
<li>The 3rd paper is titled <em>&#8220;Optimal Distributed Password Verification&#8221;</em>, the problem it wants to solve is the single server/point of failure, which may cause the whole data of password stolen, and offline dictionary attacks can be conducted. In this paper, it proposes a distributed password verification mechanism, so that even one server is under attack, the password data are still safe.</li>
</ul>


<h4>Session 3B: Memory Randomization</h4>

<p>In this session, I only listen to 3 presentations.</p>

<p>The first one is titled <em>&#8220;It&#8217;s a TRAP: Table Randomization and Protection against Function Reuse Attacks&#8221;</em>. This is a paper targeted at solving Counterfeit OOP (COOP), shamefully I&#8217;m not familiar with this attack! I can only tell that this paper proposes to randomize vtable. But I&#8217;m not quite clear about the challenges and solution, since I&#8217;m newbie for C++.</p>

<p>The second one is very interesting, it is called <em>&#8220;Heisenbyte: Thwarting Memory Disclosure Attacks using Destructive Code Reads&#8221;</em>. It uses a technique called <code>destructive code read</code> to solve the problem of code disclosure attack for ASLR, e.g., JIT-ROP. The main idea is that for systems where data/code are mixed, all memory can be read, but executale memory should be mediated after reading. So different with previous solutions like XnR, this paper thinks, we do not need to prohibit the executable memory read, since it is not compatible for systems especially like Windows. We only need to take care if we found the executable memory is read. Therefore, they use the EPT mechanism, because EPT seperate read permission with executable permission, to mediate the executable memory after reading.</p>

<p>The third one is titled <em>&#8220;Timely Rerandomization for Mitigating Memory Disclosures&#8221;</em>, it is also relate to attacks like JIT-ROP, the core idea is to synchronize with the attacker, more specifically, it is to</p>

<ul>
<li>identify disclosure time</li>
<li>identify memory corruption time</li>
<li>and rerandomize in between.</li>
</ul>


<p>which means, if we know when the code memory is leaked, we can rerandomize the memory, so that the JIT-ROP is prevented. Therefore, they choose to rerandomize after some I/O system calls, since attackers must leak the memory from network I/O.</p>

<h4>Session 5B Understanding Android Apps</h4>

<p>There are 2 papers in this session.</p>

<p>The 1st one <em>&#8220;Towards Automatic Generation of Security-Centric Descriptions for Android Apps&#8221;</em> is done by Mu Zhang from NEC Laboratories America. The authors list also includes Heng Yin from Syracuse University. The motivation of this paper is that in Android there are 2 mechanisms to describe the application, permission and textual description. However, permission is not inadequate and hard to understand, while textual decription is devated with permission, and not related to security. So the goal of this paper is to automatically generate the textual description by analyse the whole program, and to help average users to understand security risk in semantic level. The techniques they use are</p>

<ul>
<li>behavior graph generation</li>
<li>subgraph mining &amp; graph compression</li>
<li>natural language generation</li>
</ul>


<p>The 2nd paper is called <em>&#8220;AUTOREB: Automatically Understanding the Review-to-Behavior Fidelity in Android Applications&#8221;</em>, by Deguang Kong from Samsung Research America. This paper is quite simple, it just focus on user comments and app behaviors, and infer security issues from user reviews. They need to solve some challenges by some approaches:</p>

<ul>
<li>review semantic (appraoches: featuer augmentation, relevance feedback, co-occurrenc, feature correlation)</li>
<li>security concern (approaches: security feature extraction, machine learning)</li>
<li>credibility of users (approach: crowdsourcing)</li>
</ul>


<p>More details can be found in the paper if you are interested in it.</p>

<h4>Session 8B: Control Flow Integrity</h4>

<p>CFI is still popular in this year, there are totally 5 presentations in this session, the 1st one is to show the problems of current static analysis for CFG generation; The 2nd one is to generate CFG per input, to reduce the number of edges for the CFG; The 3rd one is named <em>&#8220;Practical Context-Sensitive CFI&#8221;</em>, it uses LBR to enforece context-sensitive CFI during runtime; The 4th one is <em>&#8220;CCFI: Cryptographically Enforced Control Flow Integrity&#8221;</em>, which uses some MAC mechanism to protect the control flow; And the last is <em>&#8220;Losing Control: On the Effectiveness of Control-Flow Integrity under Stack Attack&#8221;</em>, it shows one stack-based attak, though I&#8217;m not quite convinced why it is stack-based.</p>

<h4>Session 12C: Side Channel</h4>

<p>This is the session including my presentation, though I&#8217;m quite confused why my paper is located in this session, in my paper, we claimed that we don&#8217;t consider about DoS and side-channel attacks.</p>

<p>There are 4 papers in total, I&#8217;ve listened for 2, except my own.</p>

<p>The 1st is titled <em>&#8220;Mitigating Storage Side Channels Using Statistical Privacy Mechanisms&#8221;</em>. It is by Qiuyu Xiao from University of North Carolina and Yinqian Zhang from The Ohio State University. This paper leverages differential privacy to solve the side channle attack by revealing private information (e.g., which website you are scanning) from <code>procfs</code> (like memory/cpu states). It adds some noise to procfs, while remaining most of the correctness.</p>

<p>The 2nd one is <em>&#8220;Nomad: Mitigating Arbitrary Cloud Side Channels via Provider-Assisted Migration&#8221;</em> by Soo-Jin Moon from Carnegie Mellon University. The goal of this paper is realize a general deployable system to defend against cloud side-channel attack. It simply use migration to mitigate such attacks, make sure the VMs not share the same physical machine for long time.</p>

<hr />

<p>My prenstation is the last one in the last session. I should say it is OK with the talk (though still a little nervous), but for Q/A, it is quite embarrassed, 4 people ask 5 questions. However many of them are not clearly understood by myself.</p>

<p>3 about static analysis:</p>

<ul>
<li>OpenSSL complicated, how to analysis it.</li>
<li>Prateek ask about whether do we consider about control dependence.</li>
<li>Why static is useful according to our mechanism</li>
</ul>


<p>1 about VMFUNC security by prateek</p>

<p>1 about selective plaintext attack? Not quite understand.</p>

<p>The good thing is though I&#8217;m the last presentor, there are still a lot of questions, which means lots of people are interested in my work. The bad things is I&#8217;m quite awkful!</p>

<hr />

<h4>Other topics and papers</h4>

<p>There are some other papers I&#8217;m quite interested in but failed to listen to for some specific reasons. Simply list them here, and I&#8217;m going to read the paper later.</p>

<h5>Session 1B: MAC OS and iOS Security</h5>

<ul>
<li><em>Cracking App Isolation on Apple: Unauthorized Cross-App Resource Access on MAC OS X and iOS</em> by Luyi Xing (from Indiana University Bloomington)</li>
</ul>


<h5>Session 3B: Memory Randomization</h5>

<ul>
<li><em>Heisenbyte: Thwarting Memory Disclosure Attacks using Destructive Code Reads</em> by Adrian Tang (from Columbia University)</li>
<li><em>ASLR-Guard: Stopping Address Space Leakage for Code Reuse Attacks</em> by Kangjie Lu (from Georgia Institute of Technology)</li>
</ul>


<h5>Session 4B: Software Vulnerabilities</h5>

<ul>
<li><em>Unearthing Stealthy Program Attacks Buried in Extremely Long Execution Paths</em> by Xiaokui Shu (from Virginia Tech)</li>
<li><em>From Collision to Exploitation: Unleashing Use-After-Free Vulnerabilities in Linux Kernel</em> by Wen Xu (from SJTU)</li>
</ul>


<h5>Session 8C: Enhancing Trust</h5>

<ul>
<li><em>TrustOTP: Transforming Smartphones into Secure One-Time Password Tokens</em> by Kun Sun (from College of William and Mary)</li>
<li><em>Clean Application Compartmentalization with SOAAP</em> by Khilan Gudka (from University of Cambridge)</li>
</ul>


<h5>Session 10B: Mobile Device Attacks</h5>

<ul>
<li><em>From System Services Freezing to System Server Shutdown in Android: All You Need Is a Loop in an App</em> by Heqing Huang (from The Pennsylvania State University)</li>
<li><em>When Good Becomes Evil: Keystroke Inference with Smartwatch</em> by Xiangyu Liu (from The Chinese University of Hong Kong)</li>
</ul>


<hr />

<h4>People meet in CCS</h4>

<p>In CCS, I find myself not quite active in socializing with others. Most people I met and talked with are Chinese, either professors like Yan Huang, Kun Sun, Li Depeng, Yinqian Zhang, Yin Heng, Dongyan Xu, Long Lu, Xiapu Luo, or students like Guoxing Chen, Jian Liu, Xiaokuan Zhang, Qiuyu Xiao, Yaohui Chen.</p>

<p>I find there are so many Chinese in this community, this is the first time for me to step into this community, I hope there are other oppotunities in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Wifi Pineapple]]></title>
    <link href="http://ytliu.github.io/blog/2015/09/03/chu-shi-wifi-pineapple/"/>
    <updated>2015-09-03T15:45:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/09/03/chu-shi-wifi-pineapple</id>
    <content type="html"><![CDATA[<p>前段时间乃正回国的时候叫他帮我带回来一个“大菠萝”——Wifi Pineapple！不过时隔了好久到现在才有时间和心情开始玩它：</p>

<p><img src="http://ytliu.info/images/2015-09-03-1.png" title="wifi pineapple" alt="wifi pineapple" /></p>

<p>这是干嘛的呢？用专业术语来说，它是一个专门用来做无线安全渗透测试的小机器，这个小机器内置了一个重度修改的OpenWRT网络操作系统，其拥有者可以让它成为一个对外提供无线网络信号的系统，然后通过一系列配置来对连接上它的客户端进行渗透测试。如果换个说法，这就是一个可以伪装成无线信号点的攻击利器，当你在一些公共场合（如学校、咖啡店）的时候如果不小心（有意或者无意）连上了这个无线信号，那不好意思，你上网的所有隐私都会被攻击者获取。</p>

<p>很直观的来说，如果你将这个大菠萝连上电源，启动之后（绿灯和蓝灯亮起）：</p>

<p><img src="http://ytliu.info/images/2015-09-03-2.png" title="wifi pineapple boot" alt="wifi boot" /></p>

<p>就可以在你其它设备（如手机、电脑）的无线信号中搜索出一个新的信号：</p>

<p><img src="http://ytliu.info/images/2015-09-03-7.png" title="new wifi result" alt="wifi search" /></p>

<p>如果你连接上这个信号，则你所有的流量就会走大菠萝这个系统，从而攻击者就可以通过一些中间人攻击的方法获取你所有隐私，或者植入恶意软件之类的了。</p>

<p>具体的可以看<a href="http://wiki.wifipineapple.com/#!pineapple.md">这里</a>，<a href="http://www.freebuf.com/tools/9265.html">这里</a>，以及<a href="http://www.freebuf.com/articles/wireless/30874.html">这里</a>。这里就不详述了。</p>

<!-- more -->


<h4>硬件接口</h4>

<p>Wifi pineapple有如下几个接口：</p>

<ul>
<li>如下图，从左到右依次为：以太网口，USB接口，电源接口；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-3.png" title="wifi pineapple interface 1" alt="wifi pineapple interface 1" /></p>

<p>其中以太网口可以用于连接计算机来<a href="http://wiki.wifipineapple.com/#!ics.md">共享计算机的无线网络</a>，USB接口可以用来连接Android手机来<a href="http://wiki.wifipineapple.com/#!ics.md#Android_ICS">共享手机的无线网络</a>，电源接口就是用来插电源线或者电池的。</p>

<ul>
<li>如下图：串口；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-4.png" title="wifi pineapple interface 2" alt="wifi pineapple interface 2" /></p>

<p>我们可以利用串口连接线（比如下图的CP2012模块）和计算机连接，然后通过串口这个通道来连Wifi pineapple，从而进行对其的配置：</p>

<p><img src="http://ytliu.info/images/2015-09-03-8.png" title="usb to ttl" alt="usb to ttl" /></p>

<ul>
<li>如下图：DIP switches；</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-5.png" title="wifi pineapple interface 3" alt="wifi pineapple interface 3" /></p>

<p>用于控制启动的模式，比如可以对机器进行出厂值重置等。</p>

<ul>
<li>如下图：MicroUSB插槽。</li>
</ul>


<p><img src="http://ytliu.info/images/2015-09-03-6.png" title="wifi pineapple interface 4" alt="wifi pineapple interface 4" /></p>

<p>这相当于一个外部存储。</p>

<p>具体的这些硬件配置怎么用可以看<a href="http://wiki.wifipineapple.com/#">wifi pineapple的Wiki</a>。</p>

<p>另外，<a href="http://wiki.wifipineapple.com/#!pineapple_university.md#Hardware_Overview">这个视频</a>介绍的超级详细，强烈推荐！</p>

<h4>Wifi pineapple的启动</h4>

<p>当你插上电源，大菠萝就会自动启动。在第一次启动的时候会等比较久，因为它要进行初始化，比如找到查找文件，刷firmware之类的，在这个时候你可以看到各种颜色的灯一直闪着，不要着急，你可以参看下图来了解各个颜色的灯闪烁模式分别代表什么意思：</p>

<p><img src="http://ytliu.info/images/2015-09-03-9.png" title="wifi pineapple boot" alt="pineapple boot" /></p>

<p>也就是说在绿灯和蓝灯都完全亮起来（不再闪烁）的时候，就代表启动成功了。这个时候你查看你的wifi信号应该就可以看到大菠萝发出的信号了。</p>

<h4>连接和配置Wifi pineapple</h4>

<p>这个是最重要的，因为我希望对其具有完全的掌控权，所以我要能进到这个系统。最理想的方法是通过ssh登录进去，然后“为所欲为”。</p>

<p>其中Linux和Windows可以很方便的登录进去，如果你有一根网线的话。方法可以参看<a href="http://wiki.wifipineapple.com/#!ics.md">这里</a>。不过最方便的是用Android的USB Tether了，把大菠萝和android用USB连起来，然后在Android的<code>设置-&gt;无线和网络-&gt;网络共享和便携式热点</code>里面把<code>USB网络共享</code>打开就行了。然后就可以通过<code>ssh root@172.16.42.1</code>连接进去了。</p>

<p><img src="http://ytliu.info/images/2015-09-03-10.png" title="wifi pineapple ssh" alt="pineapple ssh" /></p>

<p>另外，当你知道wifi pineapple的IP之后，你也可以通过浏览器输入<code>172.16.42.1:1471</code>来访问其Web UI：</p>

<p><img src="http://ytliu.info/images/2015-09-03-11.png" title="wifi pineapple web ui" alt="pineapple web ui" /></p>

<p>有了这些之后，就可以干很多很多事啦！这些就是后话了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xen的启动之内存相关实现]]></title>
    <link href="http://ytliu.github.io/blog/2015/07/30/xende-qi-dong-zhi-nei-cun-xiang-guan-shi-xian/"/>
    <updated>2015-07-30T21:36:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/07/30/xende-qi-dong-zhi-nei-cun-xiang-guan-shi-xian</id>
    <content type="html"><![CDATA[<p><a href="http://ytliu.info/blog/2015/07/28/xende-nei-cun-bu-ju/">上篇博客</a>介绍了Xen的整体内存分布情况，这篇博文主要从Xen的启动入手，介绍Xen在启动的时候是如何初始化它的内存，包括如何分配内存区域，如何初始化页表，以及如何在不同阶段初始化不同的内存分配器等等。</p>

<!-- more -->


<p>这篇博文借鉴了一些<a href="http://bbs.chinacloud.cn/attachment.aspx?attachmentid=397">这篇文章</a>的内容，不过主要介绍的是最新版本的Xen在64位机器下的内存相关实现。</p>

<p>好，现在开始进入正题！</p>

<h3>Xen的启动</h3>

<p>在介绍Xen启动的内存实现之前，先大致介绍下Xen的启动的整个流程（参考<a href="http://bbs.chinacloud.cn/attachment.aspx?attachmentid=397">这里</a>)：</p>

<h4>汇编部分：</h4>

<p>汇编部分代码都在<code>xen-source/xen/arch/x86/boot/</code>目录下</p>

<p><code>head.S</code>，这个是整个Xen的入口：<code>ENTRY(start)</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ENTRY</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</span><span class='line'>        <span class="n">jmp</span>     <span class="n">__start</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>里面主要做了下面几件事：</p>

<ul>
<li>装入GDT (trampoline_gdt)：</li>
</ul>


<table>
<thead>
<tr>
<th align="left">GDT项 </th>
<th align="left"> 说明 </th>
<th align="left"> 段选择子</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1 </td>
<td align="left"> ring0 code, 32-bit mode </td>
<td align="left"> BOOT_CS32 (0x0008)</td>
</tr>
<tr>
<td align="left">2 </td>
<td align="left"> ring0 code, 64-bit mode </td>
<td align="left"> BOOT_CS64 (0x0010)</td>
</tr>
<tr>
<td align="left">3 </td>
<td align="left"> ring0 data </td>
<td align="left"> BOOT_DS (0x0018)</td>
</tr>
<tr>
<td align="left">4 </td>
<td align="left"> real-mode code </td>
<td align="left"> BOOT_PSEUDORM_CS (0x0020)</td>
</tr>
<tr>
<td align="left">5 </td>
<td align="left"> real-mode data </td>
<td align="left"> BOOT_PSEUDORM_DS (0x0028)</td>
</tr>
</tbody>
</table>


<ul>
<li>获取Multiboot相关的信息，放置在某段内存空间，之后启动的时候会被用到；</li>
<li>初始化BSS；</li>
<li>初始化最早期的页表<code>l3_bootmap</code>和<code>l2_bootmap</code>，注意这个时候还没有开启分页功能。这个部分会在后面进行详细介绍；</li>
<li>解析早期命令行参数；</li>
<li>调整<code>trampoline.S</code>代码的内存位置,移动到 BOOT_TRAMPOLINE(0x8c00处);</li>
<li>跳转到 trampoline_boot_cpu_entry。</li>
</ul>


<p><code>trampoline.S</code>，主要工作为：</p>

<ul>
<li>进入实模式,读取内存,磁盘,视频信息；</li>
<li>进入保护模式，将页表基地址<code>idle_pg_table</code>载入CR3，<code>idle_pg_table</code>会在之后进行详细的介绍；</li>
<li>开启EFER（Extended Feature Enable Register）；</li>
<li>开启分页模式，同时将<code>CR0</code>中的<code>PG, AM, WP, NE, ET, MP, PE</code>位都设上；</li>
<li>进入<code>__high_start</code>，即<code>x86_64.S</code>的代码。</li>
</ul>


<p><code>x86_64.S</code>，主要工作为：</p>

<ul>
<li>重新载入GDT (gdt_descr)：</li>
</ul>


<table>
<thead>
<tr>
<th align="left">GDT项 </th>
<th align="left"> 说明 </th>
<th align="left"> 段选择子</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0xe001 </td>
<td align="left"> ring0 code, 64-bit mode </td>
<td align="left"> __HYPERVISOR_CS64 (0xe008)</td>
</tr>
<tr>
<td align="left">0xe002 </td>
<td align="left"> ring0 data </td>
<td align="left"> __HYPERVISOR_DS32 (0xe010)</td>
</tr>
<tr>
<td align="left">0xe003 </td>
<td align="left"> reserved </td>
<td align="left"> -</td>
</tr>
<tr>
<td align="left">0xe004 </td>
<td align="left"> ring 3 code, compatibility </td>
<td align="left"> FLAT_RING3_CS32 (0xe023)</td>
</tr>
<tr>
<td align="left">0xe005 </td>
<td align="left"> ring 3 data </td>
<td align="left"> FLAT_RING3_DS32 (0xe02b)</td>
</tr>
<tr>
<td align="left">0xe006 </td>
<td align="left"> ring 3 code, 64-bit mode </td>
<td align="left"> FLAT_RING3_CS64 (0xe033)</td>
</tr>
<tr>
<td align="left">0xe007 </td>
<td align="left"> ring 0 code, compatibility </td>
<td align="left"> __HYPERVISOR_CS32 (0xe038)</td>
</tr>
<tr>
<td align="left">0xe008~0xe009 </td>
<td align="left"> TSS </td>
<td align="left"> -</td>
</tr>
<tr>
<td align="left">0xe00a~0xe00b </td>
<td align="left"> LDT </td>
<td align="left"> -</td>
</tr>
<tr>
<td align="left">0xe00c </td>
<td align="left"> per-cpu entry </td>
<td align="left"> -</td>
</tr>
</tbody>
</table>


<ul>
<li>装入堆栈指针：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">mov</span> <span class="n">stack_start</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="o">%</span><span class="n">rsp</span>
</span><span class='line'><span class="n">or</span>  <span class="err">$</span><span class="p">(</span><span class="n">STACK_SIZE</span><span class="o">-</span><span class="n">CPUINFO_sizeof</span><span class="p">),</span><span class="o">%</span><span class="n">rsp</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，Xen会通过<code>or $(STACK_SIZE-CPUINFO_sizeof),%rsp</code>方式在栈顶预留一个<code>cpu_info</code>结构，这个结构包含很多重要的成员：</p>

<pre><code>1. 客户系统的切换上下文 
2. 当前运行的`vcpu`指针
3. 物理处理器编号
...
</code></pre>

<ul>
<li>跳转到<code>__start_xen</code>。</li>
</ul>


<h4>C部分：</h4>

<p>即<code>xen-source/xen/arch/x86/setup.c</code>文件中的<code>__start_xen</code>函数，主要逻辑如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">__start_xen</span><span class="p">(</span><span class="n">multiboot_info_t</span> <span class="o">*</span><span class="n">mbi</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 注意,默认的情况下,参数 mbi 将从堆栈传递,这个值是前面汇编代码中的ebx值 </span>
</span><span class='line'>  <span class="c1">// 初始化IDT table</span>
</span><span class='line'>  <span class="c1">// 初始化系统相关table和描述符，包括TSS，GDT，LDT，TR等</span>
</span><span class='line'>  <span class="c1">// 解析命令行</span>
</span><span class='line'>  <span class="c1">// 初始化 console</span>
</span><span class='line'>  <span class="c1">// 内存初始化，这些是这篇博文的重点</span>
</span><span class='line'>  <span class="c1">// 其它的一些设备初始化</span>
</span><span class='line'>  <span class="c1">// trap_init,初始化 IDT</span>
</span><span class='line'>  <span class="c1">// CPU的初始化</span>
</span><span class='line'>  <span class="c1">// 创建domaim-0，下一篇博文的重点</span>
</span><span class='line'>  <span class="c1">// `domain_unpause_by_systemcontroller(dom0)`,调度domain-0 </span>
</span><span class='line'>  <span class="c1">// `reset_stack_and_jump(init_done)`，Xen进入idle循环</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>内存初始化</h3>

<p>在介绍完Xen大致的的启动流程之后，我们就要开始来重点介绍和内存相关的具体实现了。以下的内容主要回答下面几个问题：</p>

<ul>
<li>Xen是如何从实模式启动，然后进入保护模式，并开启分页模式的？</li>
<li>Xen的页表是如何建立的？即如何建立虚拟内存到物理内存的映射？</li>
<li>Xen在启动过程中是如何进行内存分配的？</li>
<li>整个系统运行起来之后，Xen是如何管理自己的内存的？</li>
</ul>


<p>对于第一个问题，简单来说，Xen在启动的时候是处于实模式的，也就是可以直接访问物理内存，通过预先定义的ENTRY地址<code>start</code>开始执行最初的汇编代码。在开启分页机制之前，Xen会先初始化一段最基本的页表，即在页表中映射物理内存的0~16M地址空间，其中包括了Xen所需的最基本的代码和数据，然后通过设置<code>CR0</code>中的某些位开启分页机制。</p>

<p>为了回答余下的三个问题，我们先来看看Xen页表的组织结构：</p>

<figure class='code'><figcaption><span>xen/arch/x86/boot/x86_64.S </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">__page_tables_start</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">......</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* Top-level master (and idle-domain) page directory. */</span>
</span><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">idle_pg_table</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l3_bootmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="n">L4_PAGETABLE_ENTRIES</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">l4_table_offset</span><span class="p">(</span><span class="n">DIRECTMAP_VIRT_START</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l3_identmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="p">.</span><span class="n">elseif</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">l4_table_offset</span><span class="p">(</span><span class="n">XEN_VIRT_START</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l3_xenmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="p">.</span><span class="k">else</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endif</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">idle_pg_table</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">idle_pg_table</span>
</span><span class='line'>
</span><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">__page_tables_end</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>idle_pg_table</code>是页表的基地址，也就是第四级页表l4的地址，会在<code>trampoline.S</code>里，在开启分页机制之前被载入cr3：</p>

<figure class='code'><figcaption><span>trampoline.S </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>        <span class="cm">/* Load pagetable base register. */</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">idle_pg_table</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>        <span class="n">add</span>     <span class="n">bootsym_rel</span><span class="p">(</span><span class="n">trampoline_xen_phys_start</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">cr3</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，它的第0项是<code>l3_bootmap</code>：</p>

<figure class='code'><figcaption><span>x86_64.S </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">idle_pg_table</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l3_bootmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>l3_bootmap</code>和<code>l2_bootmap</code>在<code>head.S</code>启动代码里面被初始化了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>        <span class="cm">/* Initialise L2 boot-map page table entries (16MB). */</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_bootmap</span><span class="p">),</span><span class="o">%</span><span class="n">edx</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="n">PAGE_HYPERVISOR</span><span class="o">|</span><span class="n">_PAGE_PSE</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="mi">8</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span>      <span class="n">mov</span>     <span class="o">%</span><span class="n">eax</span><span class="p">,(</span><span class="o">%</span><span class="n">edx</span><span class="p">)</span>
</span><span class='line'>        <span class="n">add</span>     <span class="err">$</span><span class="mi">8</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>
</span><span class='line'>        <span class="n">add</span>     <span class="err">$</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">L2_PAGETABLE_SHIFT</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>        <span class="n">loop</span>    <span class="mi">1</span><span class="n">b</span>
</span><span class='line'>        <span class="cm">/* Initialise L3 boot-map page directory entry. */</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_bootmap</span><span class="p">)</span><span class="o">+</span><span class="n">__PAGE_HYPERVISOR</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l3_bootmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span>
</span><span class='line'>        <span class="cm">/* Hook 4kB mappings of first 2MB of memory into L2. */</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="err">$</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l1_identmap</span><span class="p">)</span><span class="o">+</span><span class="n">__PAGE_HYPERVISOR</span><span class="p">,</span><span class="o">%</span><span class="n">edi</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="o">%</span><span class="n">edi</span><span class="p">,</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_xenmap</span><span class="p">)</span>
</span><span class='line'>        <span class="n">mov</span>     <span class="o">%</span><span class="n">edi</span><span class="p">,</span><span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_bootmap</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，<code>l3_bootmap</code>的第0项是<code>l2_bootmap</code>的地址，而<code>l2_bootmap</code>第0项是<code>l1_identmap</code>，它会以4K的页的方式映射0~2M的物理内存地址空间，而1~7项则是以7个2M的大页映射了2~16M的物理内存。而在这0~16M的物理内存中，存放了Xen的代码、数据的信息，需要在启动的时候被用到，所以需要在最初始的阶段映射到虚拟地址空间中。</p>

<p>继续看<code>idle_page_table</code>，如果<code>idx</code>为<code>l4_table_offset(XEN_VIRT_START)</code>，即第261项，则在该项填上<code>l3_xenmap</code>的地址；如果<code>idx</code>为<code>l4_table_offset(DIRECTMAP_VIRT_START)</code>，即第262项，则在该项上填上<code>l3_identmap</code>的地址，其余的地址在这个时候都被设置为0。</p>

<p>接下来我们来看看<code>l3_xenmap</code>和<code>l3_identmap</code>分别是什么：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">l2_xenmap</span><span class="p">)</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="mi">8</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">__image_base__</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">L2_PAGETABLE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_HYPERVISOR</span> <span class="o">|</span> <span class="n">_PAGE_PSE</span><span class="p">)</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fill</span> <span class="n">L2_PAGETABLE_ENTRIES</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l2_xenmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l2_xenmap</span>
</span><span class='line'>
</span><span class='line'><span class="nl">l3_xenmap:</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="n">L3_PAGETABLE_ENTRIES</span>
</span><span class='line'>        <span class="p">.</span><span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">l3_table_offset</span><span class="p">(</span><span class="n">XEN_VIRT_START</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_xenmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="p">.</span><span class="n">elseif</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">l3_table_offset</span><span class="p">(</span><span class="n">FIXADDR_TOP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_fixmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="p">.</span><span class="k">else</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endif</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l3_xenmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l3_xenmap</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们这里只需要关注这个<code>l2_xenmap</code>，也就是<code>l3_xenmap</code>的第322项（l3_table_offset(XEN_VIRT_START)），里面0~7项以2M大页的方式映射了<code>__image_base__</code>的内容：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define sym_phys(sym)     ((sym) - __XEN_VIRT_START)</span>
</span><span class='line'>
</span><span class='line'><span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">__image_base__</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">L2_PAGETABLE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_HYPERVISOR</span> <span class="o">|</span> <span class="n">_PAGE_PSE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以从<code>xen/arch/x86/xen.lds.S</code>文件中看到：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">SECTIONS</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">.</span> <span class="o">=</span> <span class="n">__XEN_VIRT_START</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__image_base__</span> <span class="o">=</span> <span class="p">.;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，<code>__image_base__</code>即为<code>__XEN_VIRT_START</code>的地址，所以，<code>l2_xenmap</code>映射的内存也是0~16M的物理内存。</p>

<p>再来看<code>l3_identmap</code>，可以从下面的代码看出来，<code>l3_identmap</code>的0~3项映射了4个连续的第二级页表页，以<code>l2_identmap</code>作为起始地址。而<code>l2_identmap</code>和<code>l2_bootmap</code>一样，也是第0项映射了一个L1的页表页<code>l1_identmap</code>，第1~7项以7个2M大页的形式映射了2~16M的物理内存。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Mapping of first 16 megabytes of memory. */</span>
</span><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">l2_identmap</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l1_identmap</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="mi">7</span>
</span><span class='line'>        <span class="n">pfn</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PAGETABLE_ORDER</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAGE_HYPERVISOR</span> <span class="o">|</span> <span class="n">_PAGE_PSE</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fill</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">L2_PAGETABLE_ENTRIES</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l2_identmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l2_identmap</span>
</span><span class='line'>
</span><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">l3_identmap</span><span class="p">)</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="mi">4</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_identmap</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fill</span> <span class="n">L3_PAGETABLE_ENTRIES</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l3_identmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l3_identmap</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看<code>l1_identmap</code>，它位于<code>xen/arch/x86/boot/head.S</code>文件中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Mapping of first 2 megabytes of memory. This is mapped with 4kB mappings</span>
</span><span class='line'><span class="cm"> * to avoid type conflicts with fixed-range MTRRs covering the lowest megabyte</span>
</span><span class='line'><span class="cm"> * of physical memory. In any case the VGA hole should be mapped with type UC.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">l1_identmap</span><span class="p">)</span>
</span><span class='line'>        <span class="n">pfn</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="n">L1_PAGETABLE_ENTRIES</span>
</span><span class='line'>        <span class="cm">/* VGA hole (0xa0000-0xc0000) should be mapped UC. */</span>
</span><span class='line'>        <span class="p">.</span><span class="k">if</span> <span class="n">pfn</span> <span class="o">&gt;=</span> <span class="mh">0xa0</span> <span class="o">&amp;&amp;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="mh">0xc0</span>
</span><span class='line'>        <span class="p">.</span><span class="kt">long</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAGE_HYPERVISOR_NOCACHE</span> <span class="o">|</span> <span class="n">MAP_SMALL_PAGES</span>
</span><span class='line'>        <span class="p">.</span><span class="k">else</span>
</span><span class='line'>        <span class="p">.</span><span class="kt">long</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">PAGE_HYPERVISOR</span> <span class="o">|</span> <span class="n">MAP_SMALL_PAGES</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endif</span>
</span><span class='line'>        <span class="p">.</span><span class="kt">long</span> <span class="mi">0</span>
</span><span class='line'>        <span class="n">pfn</span> <span class="o">=</span> <span class="n">pfn</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l1_identmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l1_identmap</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到它其实就是以4K的正常页的方式映射了0~2M的物理内存地址空间。</p>

<p>到此为止，我们可以画一张最基本的页表分布图：</p>

<p><img src="http://ytliu.info/images/2015-07-30-1.png" title="xen boot pagetable 1" alt="xen boot pagetable 1" /></p>

<hr />

<p>好了，到现在为止，我们介绍了在进入<code>__start_xen</code>之前，页表是如何初始化的，在这个过程中，0~16M（即Xen的代码和数据）的物理内存被映射在了三段虚拟内存空间中，它们分别是：</p>

<ul>
<li>0~16M的的虚拟地址空间；</li>
<li>XEN_VIRT_STAET ~ XEN_VIRT_START + 16M，即0xffff82d080000000~0xffff82d081000000的虚拟地址空间中；</li>
<li>DIRECTMAP_VIRT_START ~ DIRECTMAP_VIRT_START + 16M，即0xffff830000000000~0xffff830001000000的虚拟地址空间中</li>
</ul>


<p>接下来，在<code>__start_xen</code>的代码中将对这段虚拟内存空间进行一次调整，并且将其他物理内存映射到相应的虚拟内存空间中，同时在不同的阶段初始化不同的内存分配器。具体来说，它将完成以下几个内存相关的步骤：</p>

<ul>
<li>获取E820物理内存分布；</li>
<li>将16M~4G的内存空间进行大页的映射，同时将0~16M的地址空间映射到更高的虚拟地址空间中；</li>
<li>计算modules（kernel和initrd）的地址，并且预留内存空间给它们；</li>
<li>遍历所有的物理内存，将它们映射到虚拟地址空间中，对于16M~4G的内存，会把原来的小页（4K page）也进行映射，并且通过<code>init_boot_pages</code>创建boot内存分配器，对于4G以上的内存，直接映射（1G，2M或者4K）的页；</li>
<li>将modules的内存映射到Xen的虚拟地址空间中；</li>
<li>初始化frametable；</li>
<li>end_boot_allocator，并且初始化堆分配器；</li>
<li>创建页表中其它虚拟地址空间的映射；</li>
<li>初始化Domain-0的内存</li>
</ul>


<p>除了最后一个步骤，其它步骤都会在接下来的部分进行介绍。</p>

<h4>获取E820物理内存分布</h4>

<p>什么是E820？其实就是BIOS的一个中断（具体来说是<code>int 0x15</code>），在触发这个中断时如果<code>EAX</code>是<code>0xe820</code>，那么BIOS就能返回系统的物理内存布局。由于系统内存会有很多段，而且每段的类型属性也不一样，所以我们得到的E820内存分布也被分成了很多个不同类型的内存段。</p>

<p>在Xen的<code>__start_xen</code>代码里，会通过下列代码来打印出当前系统物理内存的分段情况：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="cm">/* Sanitise the raw E820 map to produce a final clean version. */</span>
</span><span class='line'>    <span class="n">max_page</span> <span class="o">=</span> <span class="n">raw_max_page</span> <span class="o">=</span> <span class="n">init_e820</span><span class="p">(</span><span class="n">memmap_type</span><span class="p">,</span> <span class="n">e820_raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e820_raw_nr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Create a temporary copy of the E820 map. */</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_e820</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e820</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">e820</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过命令：</p>

<pre><code>$ xl dmesg
</code></pre>

<p>可以看到系统E820的分布情况，比如我的E820是这样的：</p>

<p><img src="http://ytliu.info/images/2015-07-30-2.png" title="xen e820" alt="xen e820" /></p>

<p>这是我在自己计算机上启动Xen所得到的数据，其中usable的区间就是实际被映射到物理内存上的地址空间，可以看到在我的例子中有七个可用的物理地址区间，大约32GB：</p>

<pre><code>0000000000000000 - 0000000000058000 (usable) ~352K
0000000000059000 - 00000000000a0000 (usable) ~156K
0000000000100000 - 00000000a63d9000 (usable) ~2659M
00000000a63e0000 - 00000000a7404000 (usable) ~4M
00000000a7961000 - 00000000b9f97000 (usable) ~295M
00000000bafff000 - 00000000bb000000 (usable) ~4K
0000000100000000 - 000000083f600000 (usable) ~29686M
</code></pre>

<p>其它几个选项代表不同的意思，如下所示（参考<a href="http://deltamaster.is-programmer.com/posts/37297.html">这里</a>）：</p>

<ul>
<li>Usable：已经被映射到物理内存的物理地址；</li>
<li>Reserved：这些区间是没有被映射到任何地方，不能当作RAM来使用，但是kernel可以决定将这些区间映射到其他地方，比如PCI设备。通过检查<code>/proc/iomem</code>这个虚拟文件，就可以知道这些reserved的空间，是如何进一步分配给不同的设备来使用了。</li>
<li>ACPI data：映射到用来存放ACPI数据的RAM空间，操作系统应该将ACPI Table读入到这个区间内。</li>
<li>ACPI NVS：映射到用来存放ACPI数据的非易失性存储空间，操作系统不能使用。</li>
<li>Unusable：表示检测到发生错误的物理内存。这个在上面例子里没有，因为比较少见。</li>
</ul>


<p>得到这些物理内存的分布之后，我们就需要将可用（usable）的那些映射到对应的虚拟地址空间中了。</p>

<h4>第一轮映射</h4>

<p>在第一轮映射中，主要是将16M~4G的物理内存以大页（2M page）的形式映射到对应的虚拟地址空间，同时将0~16M的地址空间从原来的0~16M的虚拟地址空间映射到更高的虚拟地址空间中，这是由于一些兼容性的原因，因为大部分系统0~16M虚拟地址空间是有其它作用的。</p>

<p>这一段代码非常复杂，这里就不详细说明了，主要是要注意以下几点：</p>

<ul>
<li>这里有两个阈值：<code>BOOTSTRAP_MAP_BASE</code>和<code>limit</code>：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define BOOTSTRAP_MAP_BASE (16UL &lt;&lt; 20)</span>
</span><span class='line'><span class="n">limit</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">l2_identmap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">L2_PAGETABLE_SHIFT</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>它们最后的取值分别是16M和4G。当物理内存地址位于16M~4G时，且是usable的时候，会通过<code>map_pages_to_xen</code>函数将它们map到对应的虚拟内存中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>        <span class="n">s</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">BOOTSTRAP_MAP_BASE</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">boot_e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RAM</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
</span><span class='line'>            <span class="n">set_pdx_range</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'>            <span class="n">map_pages_to_xen</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
</span><span class='line'>                             <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如在<a href="http://ytliu.info/blog/2015/07/28/xende-nei-cun-bu-ju/">上篇博客</a>提到过的，这里<code>__va(s)</code>即将物理地址s映射在direct map的那一段内存中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__maddr_to_virt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ma</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">ASSERT</span><span class="p">(</span><span class="n">pfn_to_pdx</span><span class="p">(</span><span class="n">ma</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">DIRECTMAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">DIRECTMAP_VIRT_START</span> <span class="o">+</span>
</span><span class='line'>                    <span class="p">((</span><span class="n">ma</span> <span class="o">&amp;</span> <span class="n">ma_va_bottom_mask</span><span class="p">)</span> <span class="o">|</span>
</span><span class='line'>                     <span class="p">((</span><span class="n">ma</span> <span class="o">&amp;</span> <span class="n">ma_top_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pfn_pdx_hole_shift</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define maddr_to_virt(ma)   __maddr_to_virt((unsigned long)(ma))</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define __va(x)             (maddr_to_virt(x))</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以所有16M~4G的物理内存<code>s</code>都被映射在了<code>s+DIRECTMAP_VIRT_START</code>的那段虚拟内存中，比如物理内存<code>0x1000000</code>(16M)被映射在了<code>0xffff830001000000</code>虚拟地址上。</p>

<ul>
<li>另外一点需要注意的是，在这个过程中，并不需要分配新的页表，而且在这个阶段并没有初始化任何内存分配器，所以也无法分配新的内存页来作为页表。那么它是如何做到这点的呢？</li>
</ul>


<p>如果对之前提到的页表有印象的话，应该还记得，我们在<code>l3_identmap</code>中创建了4个<code>l2_identmap</code>页表项：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">GLOBAL</span><span class="p">(</span><span class="n">l3_identmap</span><span class="p">)</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">rept</span> <span class="mi">4</span>
</span><span class='line'>        <span class="p">.</span><span class="n">quad</span> <span class="n">sym_phys</span><span class="p">(</span><span class="n">l2_identmap</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">__PAGE_HYPERVISOR</span>
</span><span class='line'>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">.</span><span class="n">endr</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fill</span> <span class="n">L3_PAGETABLE_ENTRIES</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span> <span class="n">l3_identmap</span><span class="p">,</span> <span class="p">.</span> <span class="o">-</span> <span class="n">l3_identmap</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中只有第一个<code>l2_identmap</code>的前8项（0~16M）被初始化了，而其余的并没有初始化。一个常识是，每一个L3页表项代表了1个G的内存，那么我们有4个L3的页表项，那么就代表了4G的内存！而且所有这些页表项指向的L2的页表也已经存在了，所以说不需要重新分配新的页表页，就能够处理4G以内的所有以大页形式描述的内存了。</p>

<ul>
<li>最后一个问题，也就是如何将0~16M的物理内存映射到更高的虚拟地址空间中？</li>
</ul>


<p>在这里我就不具体说它是如何重映射的了，无非就是找到一个连续的地址空间，然后将内存从0~16M拷贝到新的地址空间，并且将原来的page table entries的内容拷贝到新的page table entries。这里来说下它是如何选择这块新的虚拟地址空间的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define reloc_size ((__pa(&amp;_end) + mask) &amp; ~mask)</span>
</span><span class='line'>        <span class="cm">/* Is the region suitable for relocating Xen? */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">xen_phys_start</span> <span class="o">&amp;&amp;</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="n">limit</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="cm">/* Don&#39;t overlap with modules. */</span>
</span><span class='line'>            <span class="n">end</span> <span class="o">=</span> <span class="n">consider_modules</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">reloc_size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">,</span>
</span><span class='line'>                                   <span class="n">mod</span><span class="p">,</span> <span class="n">mbi</span><span class="o">-&gt;</span><span class="n">mods_count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="n">end</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">l4_pgentry_t</span> <span class="o">*</span><span class="n">pl4e</span><span class="p">;</span>
</span><span class='line'>            <span class="n">l3_pgentry_t</span> <span class="o">*</span><span class="n">pl3e</span><span class="p">;</span>
</span><span class='line'>            <span class="n">l2_pgentry_t</span> <span class="o">*</span><span class="n">pl2e</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">uint64_t</span> <span class="n">load_start</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="cm">/* Select relocation address. */</span>
</span><span class='line'>            <span class="n">e</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">reloc_size</span><span class="p">;</span>
</span><span class='line'>            <span class="n">xen_phys_start</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">load_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_start</span> <span class="o">-</span> <span class="n">XEN_VIRT_START</span><span class="p">;</span>
</span><span class='line'>            <span class="n">barrier</span><span class="p">();</span>
</span><span class='line'>            <span class="n">move_memory</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">load_start</span><span class="p">,</span> <span class="n">load_start</span><span class="p">,</span> <span class="n">_end</span> <span class="o">-</span> <span class="n">_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="p">...</span>
</span><span class='line'>            <span class="c1">// update page tables and reload cr3 to invalidate TLB.</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有几个重要的变量：<code>end</code>，<code>reloc_size</code>。</p>

<p>对于<code>end</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>            <span class="n">end</span> <span class="o">=</span> <span class="n">consider_modules</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">reloc_size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">,</span>
</span><span class='line'>                                   <span class="n">mod</span><span class="p">,</span> <span class="n">mbi</span><span class="o">-&gt;</span><span class="n">mods_count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们暂且不需要知道<code>consider_modules</code>是如何计算的，这个步骤主要是要得出在0~4G的物理地址空间中，最大的那个usable的，并且是2M对其的那个地址。从E820可以看出，4G之内最大的那个地址段是<code>00000000a7961000 - 00000000b9f97000</code>，而里面最大的2M对齐的地址即为<code>0xb9e00000</code>。</p>

<p>而对于<code>reloc_size</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define reloc_size ((__pa(&amp;_end) + mask) &amp; ~mask)</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>_end</code>是Xen的代码和数据段的结束的地址，它在<code>xen.lds.S</code>中定义，它表示的是xen的所有代码和数据的最大的内存地址。所以<code>reloc_size</code>即表示xen的代码和数据段所占的内存空间有多大（最后会被1M向上对齐）。在我的系统中，它是0x400000，即4M的大小。</p>

<p>所以，这段需要被relocate的地址<code>xen_phys_start</code>即为<code>end - reloc_size</code>，所以说，Xen的代码和数据段最后被重映射到了4G内存之内的最大的地址空间中。可以看到，Xen先通过<code>move_memory</code>将内容拷贝到高地址，然后再更新页表。</p>

<h4>第二轮映射</h4>

<p>在第二轮映射中，它会遍历所有的物理内存（包括小于16M和大于4G的内存），将它们映射到虚拟地址空间中。对于0~4G的内存，会把原来未映射的小页（4K page）也进行映射，而对于4G以上的内存，则直接映射（1G，2M或者4K）的页。并且它还通过<code>init_boot_pages</code>将所有可用的物理页加入数据结构<code>bootmem_region_list</code>中，建立boot内存分配器，用于在boot阶段分配内存。</p>

<p>这是这段代码的主体部分。在这段代码中有好多个条件判断，主要作用就是将需要映射的物理内存的地址范围做一个划分，我们通过注释来说明这个过程。</p>

<p>首先通过一张图来更好地解释其划分的依据：</p>

<p><img src="http://ytliu.info/images/2015-07-30-3.png" title="xen memory mapping helper" alt="xen memory mapping helper" /></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">boot_e820</span><span class="p">.</span><span class="n">nr_map</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 最小对齐为4K页粒度 */</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">boot_e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* 起始地址4K向上对齐 */</span>
</span><span class='line'>        <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">boot_e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">+</span> <span class="n">boot_e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* 尾地址4K向下对齐 */</span>
</span><span class='line'>        <span class="n">s</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">);</span> <span class="cm">/* 1M地址以内的不进行考虑 */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">boot_e820</span><span class="p">.</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">E820_RAM</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">)</span> <span class="p">)</span> <span class="cm">/* 只考虑usable的内存 */</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">set_pdx_range</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">e</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span> <span class="cm">/* 设置pdx_range，之后具体介绍 */</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* 以下开始对内存范围进行划分，划分的两个重要依据是图中的A点（16M）和B点（4G） */</span>
</span><span class='line'>        <span class="n">map_s</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">BOOTSTRAP_MAP_BASE</span><span class="p">);</span>
</span><span class='line'>        <span class="n">map_e</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">l2_identmap</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">L2_PAGETABLE_SHIFT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">init_boot_pages</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">map_s</span><span class="p">,</span> <span class="n">e</span><span class="p">));</span> <span class="cm">/* 先将A点以下的内存区域加入boot分配器 */</span>
</span><span class='line'>        <span class="n">s</span> <span class="o">=</span> <span class="n">map_s</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">map_e</span> <span class="p">)</span> <span class="cm">/* 将A点到e或者B点（如果e大于B点）的大页内存区域加入boot分配器 */</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">L2_PAGETABLE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">map_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* 首地址2M向上对齐 */</span>
</span><span class='line'>            <span class="n">map_e</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* 尾地址2M向下对齐 */</span>
</span><span class='line'>            <span class="n">init_boot_pages</span><span class="p">(</span><span class="n">map_s</span><span class="p">,</span> <span class="n">map_e</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">map_s</span> <span class="o">&gt;</span> <span class="n">map_e</span> <span class="p">)</span> <span class="cm">/* 如果内存范围在A点之内，则这个过程结束 */</span>
</span><span class='line'>            <span class="n">map_s</span> <span class="o">=</span> <span class="n">map_e</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">map_e</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="p">)</span>  <span class="cm">/* 如果e位在B点之上 */</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">uint64_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">__pa</span><span class="p">(</span><span class="n">HYPERVISOR_VIRT_END</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span> <span class="n">map_e</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">)</span> <span class="cm">/* 先映射B点到HYPERVISOR_VIRT_END的地址空间，并且将其加入boot内存分配器 */</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">map_pages_to_xen</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">map_e</span><span class="p">),</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">map_e</span><span class="p">),</span>
</span><span class='line'>                                 <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">map_e</span><span class="p">),</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>                <span class="n">init_boot_pages</span><span class="p">(</span><span class="n">map_e</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span><span class='line'>                <span class="n">map_e</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">map_e</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="p">)</span> <span class="cm">/* 映射HYPERVISOR_VIRT_END到e的地址空间 */</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="cm">/* This range must not be passed to the boot allocator and</span>
</span><span class='line'><span class="cm">             * must also not be mapped with _PAGE_GLOBAL. */</span>
</span><span class='line'>            <span class="n">map_pages_to_xen</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">map_e</span><span class="p">),</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">map_e</span><span class="p">),</span>
</span><span class='line'>                             <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">map_e</span><span class="p">),</span> <span class="n">__PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">map_s</span> <span class="p">)</span> <span class="cm">/* 将A点到B点的4K页内存区域进行映射，并且加入boot分配器 */</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">map_pages_to_xen</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
</span><span class='line'>                             <span class="p">(</span><span class="n">map_s</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>            <span class="n">init_boot_pages</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">map_s</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以这就是划分不同的内存段进行映射，并且将可用的内存加入boot分配器。由于0~4G的内存区域中的2M的大页已经在之前被映射了，所以在这个阶段主要就是把它们加入boot分配器，同时映射4G以上的内存区域。</p>

<p>下面我们来重点分析3个函数：</p>

<ul>
<li><code>set_pdx_range</code></li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define PDX_GROUP_SHIFT L2_PAGETABLE_SHIFT</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define PDX_GROUP_COUNT ((1 &lt;&lt; PDX_GROUP_SHIFT) / \</span>
</span><span class='line'><span class="cp">                         (sizeof(*frame_table) &amp; -sizeof(*frame_table)))</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">set_pdx_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">emfn</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eidx</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">idx</span> <span class="o">=</span> <span class="n">pfn_to_pdx</span><span class="p">(</span><span class="n">smfn</span><span class="p">)</span> <span class="o">/</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">;</span>
</span><span class='line'>    <span class="n">eidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfn_to_pdx</span><span class="p">(</span><span class="n">emfn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">)</span> <span class="o">/</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">eidx</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span> <span class="p">)</span>
</span><span class='line'>        <span class="n">__set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pdx_group_valid</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是啥意思呢？比较好理解的是，<code>PDX_GROUP_COUNT</code>表示的是在一个L2大页（2M）的内存中可以装多少个<code>frame_table</code>数据结构。这里有一个比较tricky的地方，就是这个<code>(sizeof(*frame_table) &amp; -sizeof(*frame_table))</code>。这里顺便普及一个知识：</p>

<blockquote><p>“x &amp; -x” means that the greatest power of 2 that is a factor of x.</p></blockquote>

<p>在我们这里，<code>sizeof(*frame_table)</code>的值是0x20，所以<code>PDX_GROUP_COUNT</code>即为<code>0x10000（64K）</code>。</p>

<p>另外如果跟进代码的话会发现，<code>pfn_to_pdx(pfn)</code>其实就是<code>pfn</code>，所以<code>set_pdx_range</code>即找到<code>smfn</code>到<code>emfn</code>所对应的那些2M的大页，并且把<code>pdx_group_valid</code>中对应的bit给设上，表示说这些内存空间对应的pdx是valid的，这在之后有用。</p>

<ul>
<li><code>init_boot_pages</code></li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">bootmem_region_add</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bootmem_region_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>        <span class="n">bootmem_region_list</span> <span class="o">=</span> <span class="n">mfn_to_virt</span><span class="p">(</span><span class="n">s</span><span class="o">++</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">e</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bootmem_regions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span> <span class="p">)</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
</span><span class='line'>            <span class="p">(</span><span class="n">nr_bootmem_regions</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bootmem_region_list</span><span class="p">));</span>
</span><span class='line'>    <span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bootmem_region</span><span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">nr_bootmem_regions</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_boot_pages</span><span class="p">(</span><span class="n">paddr_t</span> <span class="n">ps</span><span class="p">,</span> <span class="n">paddr_t</span> <span class="n">pe</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">ps</span> <span class="o">=</span> <span class="n">round_pgup</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pe</span> <span class="o">=</span> <span class="n">round_pgdown</span><span class="p">(</span><span class="n">pe</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="n">pe</span> <span class="o">&lt;=</span> <span class="n">ps</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bootmem_region_add</span><span class="p">(</span><span class="n">ps</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">pe</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码非常简单，就是将ps到pe的内存空间给加到<code>bootmem_region_list</code>中，之后进行分配内存的时候会被用到。</p>

<ul>
<li><code>map_pages_to_xen</code></li>
</ul>


<p>这个函数特别复杂，也是Xen里面非常重要的一个函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">map_pages_to_xen</span><span class="p">(</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">virt</span><span class="p">,</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mfn</span><span class="p">,</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_mfns</span><span class="p">,</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">......</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里就不展开来说，它所做的就是将以<code>virt</code>开头的<code>nr_mfns</code>个页映射到<code>mfn</code>的物理地址空间中。它的做法就是从<code>idle_page_table</code>开始走页表，最后凑齐所有的龙珠，哦不，所有的页表，然后在最后一级页表对应的页表项上写上mfn及其相应的flags。需要注意的是，它会根据你的虚拟地址来判断是否要用大页，以及用多大的大页（1G or 2M）。当然，如果需要新建一个页表，在boot阶段会通过<code>alloc_boot_pages(nr_pfns, pfn_align)</code>来分配对应的内存页：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">alloc_boot_pages</span><span class="p">(</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pfns</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_align</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nr_bootmem_regions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">bootmem_region</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="n">pg</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">-</span> <span class="n">nr_pfns</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pfn_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">pg</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">s</span> <span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">_e</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
</span><span class='line'>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">=</span> <span class="n">pg</span><span class="p">;</span>
</span><span class='line'>        <span class="n">bootmem_region_add</span><span class="p">(</span><span class="n">pg</span> <span class="o">+</span> <span class="n">nr_pfns</span><span class="p">,</span> <span class="n">_e</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">pg</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">BOOT_BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实也就是从我们之前通过<code>init_boot_pages</code>加到<code>bootmem_region_list</code>的内存来获取相应的内存页。这里就不详述了。</p>

<h4>modules（kernel，initrd）的内存映射</h4>

<p>这个步骤非常简单，就是运行了下面这段代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mbi</span><span class="o">-&gt;</span><span class="n">mods_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">set_pdx_range</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_start</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_start</span> <span class="o">+</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_end</span><span class="p">));</span>
</span><span class='line'>        <span class="n">map_pages_to_xen</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mfn_to_virt</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_start</span><span class="p">),</span>
</span><span class='line'>                         <span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_start</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">PFN_UP</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mod_end</span><span class="p">),</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些函数之前都介绍过了，这里就不具体讲了。一般情况下，系统中会有两个modules，一个是kernel，还有一个是initrd，所以这个循环会进行两次，每次将不同的module映射到对应的地址空间。</p>

<h4><code>page_info</code>数据结构列表FrameTable的初始化</h4>

<p>这个过程对应的函数是<code>init_frametable</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_frametable_chunk</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">;</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">step</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cpu_has_page1gb</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                       <span class="o">!</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">L3_PAGETABLE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">?</span>
</span><span class='line'>                       <span class="n">L3_PAGETABLE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span> <span class="o">:</span>
</span><span class='line'>                       <span class="n">L2_PAGETABLE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span> <span class="n">step</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">e</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>            <span class="n">step</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGETABLE_ORDER</span><span class="p">;</span>
</span><span class='line'>        <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mfn</span> <span class="o">=</span> <span class="n">alloc_boot_pages</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">mfn</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGETABLE_ORDER</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mfn</span> <span class="p">)</span>
</span><span class='line'>            <span class="n">panic</span><span class="p">(</span><span class="s">&quot;Not enough memory for frame table&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">map_pages_to_xen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mfn</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">e</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_frametable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_pdx</span> <span class="o">+</span> <span class="n">PDX_GROUP_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">sidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">sidx</span> <span class="o">=</span> <span class="n">nidx</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">eidx</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">pdx_group_valid</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">sidx</span><span class="p">);</span>
</span><span class='line'>        <span class="n">nidx</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">pdx_group_valid</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">eidx</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">nidx</span> <span class="o">&gt;=</span> <span class="n">max_idx</span> <span class="p">)</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="n">init_frametable_chunk</span><span class="p">(</span><span class="n">pdx_to_page</span><span class="p">(</span><span class="n">sidx</span> <span class="o">*</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">),</span>
</span><span class='line'>                              <span class="n">pdx_to_page</span><span class="p">(</span><span class="n">eidx</span> <span class="o">*</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">end_pg</span> <span class="o">=</span> <span class="n">pdx_to_page</span><span class="p">(</span><span class="n">max_pdx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">top_pg</span> <span class="o">=</span> <span class="n">mem_hotplug</span> <span class="o">?</span> <span class="n">pdx_to_page</span><span class="p">(</span><span class="n">max_idx</span> <span class="o">*</span> <span class="n">PDX_GROUP_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>                         <span class="o">:</span> <span class="n">end_pg</span><span class="p">;</span>
</span><span class='line'>    <span class="n">init_frametable_chunk</span><span class="p">(</span><span class="n">pdx_to_page</span><span class="p">(</span><span class="n">sidx</span> <span class="o">*</span> <span class="n">PDX_GROUP_COUNT</span><span class="p">),</span> <span class="n">top_pg</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">end_pg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">top_pg</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end_pg</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在搞清楚这段代码之前，我们需要先有一个概念。frametable其实是位于<code>0xffff82e000000000 - 0xffff82ffffffffff</code>内存中的一堆<code>struct page_info</code>的数据结构，每一个<code>page_info</code>记录了一个物理页的相应的信息。另外，之前提到的那个<code>pdx</code>，全称为<code>page descriptor index</code>，在我的机器上，有大约32G的内存，也就是从<code>0x0~0x83f600000</code>。前面计算过<code>PDX_GROUP_COUNT</code>为<code>0x10000</code>，所以在我的机器中最大的pdx即为<code>0x83f600000 &gt;&gt; 12 &gt;&gt; 16 = 84</code>（向上对齐）。</p>

<p>所以这段代码就是找到从0到84中所有在之前通过<code>set_pdx_range</code>设上的pdx，然后将其映射到对应的<code>page_info</code>的内存上。在我的机器上，<code>0x0~0xc</code>，以及<code>0x10~0x84</code>是在之前通过<code>set_pdx_range</code>设上的pdx，所以通过<code>init_frametable_chunk</code>将它们对应的<code>page_info</code>映射到frametable的虚拟地址空间中。</p>

<ul>
<li>堆分配器的初始化</li>
</ul>


<p>在前面的所有操作完成之后，<code>__start_xen</code>会调用<code>end_boot_allocator()</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="n">__init</span> <span class="nf">end_boot_allocator</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nr_bootmem_regions</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">bootmem_region</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_region_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">e</span> <span class="p">)</span>
</span><span class='line'>            <span class="n">init_heap_pages</span><span class="p">(</span><span class="n">mfn_to_page</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">),</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">-</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init_heap_pages</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">bootmem_region_list</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>它会调用<code>init_heap_pages</code>初始化堆分配器。</p>

<p>堆分配器是Xen的主内存分配器,这是一个和Linux的内存分配器类似的分配器。这里就不对其进行介绍了，反正之后的内存分配都是依靠这个堆分配器了。</p>

<ul>
<li>其它虚拟地址空间在页表中的映射</li>
</ul>


<p>到此为止，变量<code>system_state</code>已经从<code>SYS_STATE_early_boot</code>变成了<code>SYS_STATE_boot</code>。之后所有的内存分配也从boot allocator变成了<code>alloc_xenheap_page()</code>或者<code>alloc_domheap_page()</code>。另外Xen已经将所有的物理内存都映射到了<code>DIRECTMAP_VIRT_START</code>到<code>DIRECTMAP_VIRT_END</code>之间。</p>

<p>接下来就是对虚拟地址空间中其它区域进行映射。在<a href="http://ytliu.info/blog/2015/07/28/xende-nei-cun-bu-ju/">上篇博客</a>里面提到在Xen的虚拟地址空间中还有好多其它区域，比如MPT，vmap等。这些区域也需要在xen启动的时候进行初始化，主要通过下面两个函数：</p>

<ul>
<li><code>vm_init()</code>：</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">vm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr</span><span class="p">;</span>
</span><span class='line'>     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">va</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>     <span class="n">vm_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">VMAP_VIRT_START</span><span class="p">;</span>
</span><span class='line'>     <span class="n">vm_end</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">arch_vmap_virt_end</span><span class="p">()</span> <span class="o">-</span> <span class="n">vm_base</span><span class="p">);</span>
</span><span class='line'>     <span class="n">vm_low</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">((</span><span class="n">vm_end</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
</span><span class='line'>     <span class="n">nr</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">((</span><span class="n">vm_low</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
</span><span class='line'>     <span class="n">vm_top</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>     <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">va</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vm_bitmap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">va</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span> <span class="p">)</span>
</span><span class='line'>     <span class="p">{</span>
</span><span class='line'>         <span class="k">struct</span> <span class="n">page_info</span> <span class="o">*</span><span class="n">pg</span> <span class="o">=</span> <span class="n">alloc_domheap_page</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>         <span class="n">map_pages_to_xen</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">page_to_mfn</span><span class="p">(</span><span class="n">pg</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_HYPERVISOR</span><span class="p">);</span>
</span><span class='line'>         <span class="n">clear_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">bitmap_fill</span><span class="p">(</span><span class="n">vm_bitmap</span><span class="p">,</span> <span class="n">vm_low</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>     <span class="cm">/* Populate page tables for the bitmap if necessary. */</span>
</span><span class='line'>     <span class="n">map_pages_to_xen</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vm_low</span> <span class="o">-</span> <span class="n">nr</span><span class="p">,</span> <span class="n">MAP_SMALL_PAGES</span><span class="p">);</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>vm_init()</code>主要就是映射一部分物理内存到VMAP_VIRT_START开始的一段虚拟地址空间中。</p>

<ul>
<li><code>paging_init()</code></li>
</ul>


<p>这个函数复杂很多，它主要用来map好几个不同的machine-to-physical table (MPT)，这些MPT我目前为止还不太清楚用来做什么，之后慢慢补上，以及创建linear guest page table。这里就不详述了。</p>

<p>到目前为止，Xen启动阶段内存的虚拟化就告一段落了，接下来就要进行CPU、设备的初始化，以及Domain-0的创建了。关于Domain-0的创建会在下一篇博文中进行介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xen的内存布局]]></title>
    <link href="http://ytliu.github.io/blog/2015/07/28/xende-nei-cun-bu-ju/"/>
    <updated>2015-07-28T21:06:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/07/28/xende-nei-cun-bu-ju</id>
    <content type="html"><![CDATA[<p>我会在接下来几篇博客里面介绍Xen的memory。这些都是我在看了各种资料，并且研究了Xen的代码之后的个人总结。之所以写这个系列，是感觉现在网络上没有什么比较具体介绍Xen内存的资料，<a href="http://bbs.chinacloud.cn/attachment.aspx?attachmentid=397">这里</a>有一个，但是是比较老的版本，而且主要介绍的是32位的系统。而我现在看的是Xen最新的版本（4.6），然后介绍的主要是64位的系统，希望能把自己花时间学到的东西分享出去。如果有什么错误的，或者解释的不清楚的地方，也希望各位指出来，共同讨论。</p>

<p>我应该会从五个方面来介绍Xen的内存：</p>

<ul>
<li><a href="http://ytliu.info/blog/2015/07/28/xende-nei-cun-bu-ju/">Xen的内存布局总体概览</a></li>
<li><a href="http://ytliu.info/blog/2015/07/30/xende-qi-dong-zhi-nei-cun-xiang-guan-shi-xian/">Xen启动的内存相关实现</a></li>
<li>Domain-0启动的内存相关实现</li>
<li>Domain-U启动的内存相关实现</li>
<li>虚拟机运行时内存相关实现</li>
</ul>


<p>现在我也还在研究中，所以这些应该会随着我自己学习的深入慢慢的进行整理。</p>

<p>好啦，不说废话了，直接进入这篇博客的主题：Xen内存布局的总体概览。</p>

<!-- more -->


<p>一般情况下我们讨论一个虚拟化系统中的内存，我们主要考虑的是客户虚拟机的内存机制，所以我们会提到shadow page table（影子页表），或者硬件内存虚拟化机制EPT（for Intel）/NPT（for AMD）等。然而这些其实都是针对于客户虚拟机来说的，也就是说对于客户虚拟机来说，它所看到的内存是怎么样的。但是如果我们从Xen本身的角度来考虑的话，Xen所看到的内存又是怎么样的呢？另外，对于整个系统来说，它的内存又是如何分布的呢？</p>

<p>首先我们要搞清楚几个概念：</p>

<p>第一，Xen有一个自己的页表，它是Xen的虚拟地址到物理地址的映射，这也是我们今天主要介绍的内容；</p>

<p>第二，客户虚拟机也有一个自己的页表，但是这个页表是关于客户虚拟机客户虚拟地址到客户物理地址的映射，Xen帮其维护了一个客户物理地址到机器物理地址的映射，这个会在之后的系列进行详细介绍；</p>

<p>第三，特权级虚拟机（即Domain-0）的内存管理和普通的客户虚拟机的内存管理不同。这也会在之后进行介绍。</p>

<p>好了，大致了解了上述几个概念，我们开始介绍Xen的虚拟内存布局。换句话说，在Xen的内存实现中，不同的虚拟地址范围对应的都是什么物理地址？在第一点里提到的Xen的那个页表到底是如何对虚拟内存进行映射的？</p>

<p>在Xen源码的<code>xen/include/asm-x86/config.h</code>文件中描述了该映射：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> * Memory layout:</span>
</span><span class='line'><span class="cm"> *  0x0000000000000000 - 0x00007fffffffffff [128TB, 2^47 bytes, PML4:0-255]</span>
</span><span class='line'><span class="cm"> *    Guest-defined use (see below for compatibility mode guests).</span>
</span><span class='line'><span class="cm"> *  0x0000800000000000 - 0xffff7fffffffffff [16EB]</span>
</span><span class='line'><span class="cm"> *    Inaccessible: current arch only supports 48-bit sign-extended VAs.</span>
</span><span class='line'><span class="cm"> *  0xffff800000000000 - 0xffff803fffffffff [256GB, 2^38 bytes, PML4:256]</span>
</span><span class='line'><span class="cm"> *    Read-only machine-to-phys translation table (GUEST ACCESSIBLE).</span>
</span><span class='line'><span class="cm"> *  0xffff804000000000 - 0xffff807fffffffff [256GB, 2^38 bytes, PML4:256]</span>
</span><span class='line'><span class="cm"> *    Reserved for future shared info with the guest OS (GUEST ACCESSIBLE).</span>
</span><span class='line'><span class="cm"> *  0xffff808000000000 - 0xffff80ffffffffff [512GB, 2^39 bytes, PML4:257]</span>
</span><span class='line'><span class="cm"> *    ioremap for PCI mmconfig space</span>
</span><span class='line'><span class="cm"> *  0xffff810000000000 - 0xffff817fffffffff [512GB, 2^39 bytes, PML4:258]</span>
</span><span class='line'><span class="cm"> *    Guest linear page table.</span>
</span><span class='line'><span class="cm"> *  0xffff818000000000 - 0xffff81ffffffffff [512GB, 2^39 bytes, PML4:259]</span>
</span><span class='line'><span class="cm"> *    Shadow linear page table.</span>
</span><span class='line'><span class="cm"> *  0xffff820000000000 - 0xffff827fffffffff [512GB, 2^39 bytes, PML4:260]</span>
</span><span class='line'><span class="cm"> *    Per-domain mappings (e.g., GDT, LDT).</span>
</span><span class='line'><span class="cm"> *  0xffff828000000000 - 0xffff82bfffffffff [256GB, 2^38 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    Machine-to-phys translation table.</span>
</span><span class='line'><span class="cm"> *  0xffff82c000000000 - 0xffff82cfffffffff [64GB,  2^36 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    vmap()/ioremap()/fixmap area.</span>
</span><span class='line'><span class="cm"> *  0xffff82d000000000 - 0xffff82d03fffffff [1GB,   2^30 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    Compatibility machine-to-phys translation table.</span>
</span><span class='line'><span class="cm"> *  0xffff82d040000000 - 0xffff82d07fffffff [1GB,   2^30 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    High read-only compatibility machine-to-phys translation table.</span>
</span><span class='line'><span class="cm"> *  0xffff82d080000000 - 0xffff82d0bfffffff [1GB,   2^30 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    Xen text, static data, bss.</span>
</span><span class='line'><span class="cm"> *  0xffff82d0c0000000 - 0xffff82dffbffffff [61GB - 64MB,       PML4:261]</span>
</span><span class='line'><span class="cm"> *    Reserved for future use.</span>
</span><span class='line'><span class="cm"> *  0xffff82dffc000000 - 0xffff82dfffffffff [64MB,  2^26 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    Super-page information array.</span>
</span><span class='line'><span class="cm"> *  0xffff82e000000000 - 0xffff82ffffffffff [128GB, 2^37 bytes, PML4:261]</span>
</span><span class='line'><span class="cm"> *    Page-frame information array.</span>
</span><span class='line'><span class="cm"> *  0xffff830000000000 - 0xffff87ffffffffff [5TB, 5*2^40 bytes, PML4:262-271]</span>
</span><span class='line'><span class="cm"> *    1:1 direct mapping of all physical memory.</span>
</span><span class='line'><span class="cm"> *  0xffff880000000000 - 0xffffffffffffffff [120TB,             PML4:272-511]</span>
</span><span class='line'><span class="cm"> *    PV: Guest-defined use.</span>
</span><span class='line'><span class="cm"> *  0xffff880000000000 - 0xffffff7fffffffff [119.5TB,           PML4:272-510]</span>
</span><span class='line'><span class="cm"> *    HVM/idle: continuation of 1:1 mapping</span>
</span><span class='line'><span class="cm"> *  0xffffff8000000000 - 0xffffffffffffffff [512GB, 2^39 bytes  PML4:511]</span>
</span><span class='line'><span class="cm"> *    HVM/idle: unused</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * Compatibility guest area layout:</span>
</span><span class='line'><span class="cm"> *  0x0000000000000000 - 0x00000000f57fffff [3928MB,            PML4:0]</span>
</span><span class='line'><span class="cm"> *    Guest-defined use.</span>
</span><span class='line'><span class="cm"> *  0x00000000f5800000 - 0x00000000ffffffff [168MB,             PML4:0]</span>
</span><span class='line'><span class="cm"> *    Read-only machine-to-phys translation table (GUEST ACCESSIBLE).</span>
</span><span class='line'><span class="cm"> *  0x0000000100000000 - 0x0000007fffffffff [508GB,             PML4:0]</span>
</span><span class='line'><span class="cm"> *    Unused.</span>
</span><span class='line'><span class="cm"> *  0x0000008000000000 - 0x000000ffffffffff [512GB, 2^39 bytes, PML4:1]</span>
</span><span class='line'><span class="cm"> *    Hypercall argument translation area.</span>
</span><span class='line'><span class="cm"> *  0x0000010000000000 - 0x00007fffffffffff [127TB, 2^46 bytes, PML4:2-255]</span>
</span><span class='line'><span class="cm"> *    Reserved for future use.</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有几个比较关键的地址空间（注：PML4:M-N表示该地址空间占用了第四级页表的第M到第N项）：</p>

<ul>
<li><code>0x0000000000000000 - 0x00007fffffffffff [128TB, PML4:0-255]</code>是为客户虚拟机准备的虚拟地址空间，这个会在之后的系列里面讨论，我现在也还不是很清楚它们是如何被使用的。</li>
<li><code>0xffff800000000000 - 0xffff803fffffffff [256GB, PML4:256]</code>是客户虚拟机只读的machine-to-physical table（MPT），MPT会在介绍客户虚拟机的时候进行介绍，现在只需要知道它是记录了HPA到GPA的映射的表。</li>
<li><code>0xffff804000000000 - 0xffff807fffffffff [256GB, PML4:256]</code>是Xen和虚拟机共享shared info信息的内存地址，shared info会在虚拟机启动的时候进行介绍，其主要是一些Xen需要让客户虚拟机启动时用到的一些信息。</li>
<li><code>0xffff810000000000 - 0xffff817fffffffff [512GB, PML4:258]</code>记录了每个客户虚拟机的page table，这个在客户虚拟机部分进行介绍，现在暂时还不清楚是用来干嘛的。</li>
<li><code>0xffff818000000000 - 0xffff81ffffffffff [512GB, PML4:259]</code>记录shadow page table的信息。</li>
<li><code>0xffff820000000000 - 0xffff827fffffffff [512GB, PML4:260]</code>这是记录每个虚拟机的(per-domain mapping)一些相关信息，包括一些GDT，LDT之类的，也是在之后客户虚拟机部分进行介绍。</li>
<li><code>0xffff828000000000 - 0xffff82bfffffffff [256GB, PML4:261]</code>这个也是MPT，但是客户虚拟机不可访问，现在我还不太清楚具体是做什么的，我猜它应该是P2M。</li>
<li><code>0xffff82c000000000 - 0xffff82cfffffffff [64GB, PML4:261]</code>用于vmap()/ioremap()/fixmap，现在还不清楚是做什么的。</li>
<li><code>0xffff82d080000000 - 0xffff82d0bfffffff [1GB, PML4:261]</code>这个最重要，映射了Xen的code和data，还包括bss之类的。这也是在Xen启动的时候会被最早映射到物理内存中的内容。</li>
<li><code>0xffff82dffc000000 - 0xffff82dfffffffff [64MB, PML4:261]</code>这个用于记录一些superpage相关的信息。</li>
<li><code>0xffff82e000000000 - 0xffff82ffffffffff [128GB, PML4:261]</code>这个也非常关键，Xen会为每个物理页都生成一个page frame的数据结构，里面记录了每个物理页相关的信息。</li>
<li><code>0xffff830000000000 - 0xffff87ffffffffff [5TB, PML4:262-271]</code>这个是一个一对一的直接映射，即每一个物理地址都会在这个地址空间中找到一个相应的虚拟地址的映射。在Xen的代码里面<code>__va()</code>这个宏就是对应了这个地址空间中的某个地址。</li>
<li><code>0xffff880000000000 - 0xffffffffffffffff [120TB, PML4:272-511]</code>用于PV的客户虚拟机，这个之后介绍，现在也不清楚要如何用。</li>
<li><code>0xffff880000000000 - 0xffffff7fffffffff [119.5TB, PML4:272-510]</code>用于HVM客户虚拟机。</li>
</ul>


<p>当然还有一些其它的，现在我也还暂时不清楚到底是用来做什么的，先在这里列出来吧：</p>

<ul>
<li><code>0xffff808000000000 - 0xffff80ffffffffff [512GB, PML4:257]</code>用于ioremap for PCI mmconfig space。</li>
<li><code>0xffff82d000000000 - 0xffff82d03fffffff [1GB, PML4:261]</code>又是一个MPT，叫做Compatibility MPT，现在不清楚是做什么的。</li>
<li><code>0xffff82d040000000 - 0xffff82d07fffffff [1GB, PML4:261]</code>又是一个MPT，叫做High read-only compatibility MPT。</li>
</ul>


<p>这里有几个点需要强调一下：</p>

<p>首先，上面所说的这个内存分布状况会被反映在Xen的页表中，同时某些信息也会被映射在虚拟机的内存空间中，至于有哪些我们在之后的系列慢慢介绍。</p>

<p>另外，所有虚拟内存到物理内存的映射都会在<code>[PML4:262-271]</code>，也就是direct map那里反映出来，如果我们看<code>__va()</code>的实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__maddr_to_virt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ma</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">ASSERT</span><span class="p">(</span><span class="n">pfn_to_pdx</span><span class="p">(</span><span class="n">ma</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">DIRECTMAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">DIRECTMAP_VIRT_START</span> <span class="o">+</span>
</span><span class='line'>                    <span class="p">((</span><span class="n">ma</span> <span class="o">&amp;</span> <span class="n">ma_va_bottom_mask</span><span class="p">)</span> <span class="o">|</span>
</span><span class='line'>                     <span class="p">((</span><span class="n">ma</span> <span class="o">&amp;</span> <span class="n">ma_top_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pfn_pdx_hole_shift</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define maddr_to_virt(ma)   __maddr_to_virt((unsigned long)(ma))</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define __va(x)             (maddr_to_virt(x))</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>DIRECTMAP_VIRT_START</code>就是direct map虚拟地址的首地址：<code>0xffff830000000000</code>。</p>

<p>另外，对于page frame，也即前面提到的，Xen会为每一个物理页生成一个对应的page_info数据结构：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">page_info</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">page_list_entry</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'>        <span class="n">paddr_t</span> <span class="n">up</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">page_sharing_info</span> <span class="o">*</span><span class="n">sharing</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count_info</span><span class="p">;</span>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type_info</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">inuse</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>   <span class="cm">/* What kind of shadow is this? */</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pinned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Is the shadow pinned? */</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">head</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Is this the first page of the shadow? */</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="o">:</span><span class="mi">25</span><span class="p">;</span> <span class="cm">/* Reference count */</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">sh</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">bool_t</span> <span class="n">need_tlbflush</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">__pdx_t</span> <span class="n">_domain</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">inuse</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">__pdx_t</span> <span class="n">back</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">sh</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="n">free</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">u32</span> <span class="n">tlbflush_timestamp</span><span class="p">;</span>
</span><span class='line'>        <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">u16</span> <span class="n">nr_validated_ptes</span><span class="p">;</span>
</span><span class='line'>            <span class="n">s8</span> <span class="n">partial_pte</span><span class="p">;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>        <span class="n">u32</span> <span class="n">shadow_flags</span><span class="p">;</span>
</span><span class='line'>        <span class="n">__pdx_t</span> <span class="n">next_shadow</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中主要记录了该页相关的一些信息，比如它是什么类型（normal page，或者是页表页，或者是free的）？被引用的次数（count_info）？以及和其它page之间的链表关系等。这些信息在相关page被回收或者分配的时候会被用到。</p>

<p>其它的内存映射的具体细节就需要在之后慢慢进行介绍了。</p>

<p>最后我们画一张图，来总体描述一下各个内存地址空间在整个页表中的分布情况：</p>

<p><img src="http://ytliu.info/images/2015-07-28-1.png" title="xen page table" alt="xen page table" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XSM-FLASK学习笔记]]></title>
    <link href="http://ytliu.github.io/blog/2015/06/10/xsm-flaskxue-xi-bi-ji/"/>
    <updated>2015-06-10T10:40:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/06/10/xsm-flaskxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>XSM-FLASK全称为：<strong>X</strong>en <strong>S</strong>ecurity <strong>M</strong>odules - <strong>FL</strong>ux <strong>A</strong>dvanced <strong>S</strong>ecurity <strong>K</strong>ernel。这篇博文对其进行一个简单的介绍，资料主要翻译自<a href="http://wiki.xen.org/wiki/Xen_Security_Modules_:_XSM-FLASK">这里</a>。</p>

<p>XSM是Xen提供的一个安全框架，允许管理者对整个系统进行细粒度的控制，换句话说，即运行管理者定义一套规则来管理虚拟机之间，虚拟机与Xen之间的交互，以及对系统资源（memory，device）的访问。</p>

<p>FLASK是XSM中的一个模块实现，当然，之后可能还有其他的模块，那就是后话了。下面是一些例子，列举了XSM-FLASK可以做的几件事：</p>

<ul>
<li>禁止两台虚拟机之间通过event channel和grant table进行通信；</li>
<li>将一些需要特权级别的操作安全地grant给某些非特权级虚拟机；</li>
<li>控制哪些虚拟机能使用device passthrough；</li>
<li>限制或者审计特权虚拟机中进行的某些特定操作；</li>
<li>限制特权虚拟机对其他虚拟机的任意内存映射；</li>
<li>将hypervisor中的不同模块（比如qemu和xenstore）进行隔离，防止它们之间互相影响。</li>
</ul>


<p>以上是一些基本说明，下面会具体介绍如何使用FLASK，以及FLASK中规则的一些语法定义。</p>

<!-- more -->


<hr />

<h3>FLASK及其policy的编译流程</h3>

<p>在Xen 4.3之后的版本都对FLASK进行了比较全面的支持，如果要开启FLASK，需要在编译Xen之前修改<code>Config.mk</code>文件，将<code>XSM_ENABLE</code>和<code>FLASK_ENABLE</code>设成<code>y</code>，然后再开始编译。</p>

<p>编译完Xen之后，需要编译FLASK的policy，在这之前需要先安装checkpolicy：</p>

<pre><code>$ aptitude install checkpolicy
</code></pre>

<p>然后编译：</p>

<pre><code>$ cd $XEN
$ make -C tools/flask/policy
</code></pre>

<p>之后会在<code>$XEN/tools/flask/policy</code>目录下生成一个叫做<code>xenpolicy-$XEN_FULLVESION</code>的文件，这个就是生成的flask policy。</p>

<hr />

<h3>启动Xen（with FLASK）</h3>

<p>在重启机器之前，我们需要在grub的配置中加上flask的选项，修改<code>/etc/default/grub</code>文件：</p>

<pre><code>GRUB_CMDLINE_XEN_DEFAULT="flask=&lt;OPTION&gt;"
</code></pre>

<p>其中，OPTIONs包括：</p>

<ul>
<li><code>permissive</code>表示：如果在bootloader阶段找到了一个policy，则会被加载；如果没有，或者发生错误，错误报告会被写到一个buffer，但是不会阻止系统启动。该模式可以通过<code>xl setenforce</code>改为<code>enforcing</code>模式；</li>
<li><code>enforcing</code>表示：在创建domain0之前会强制要求提供一个policy，否则无法启动系统；</li>
<li><code>late</code>表示：在bootloader阶段不会load相关的policy，可以在系统启动之后通过<code>xl loadpolicy</code>加载相应的policy，一旦policy被加载则进入enforcing模式；</li>
<li><code>disabled</code>表示：XSM会被设成dummy module，该模块和没有编译XSM所产生的效果是一样的，另外，一旦采用这个模式之后，FLASK是无法被重新加载的。</li>
</ul>


<p>需要注意的一点是，FLASK的policy需要被放在一个grub可以访问的目录下，如<code>/boot/flask/</code>，否则FLASK不会开启。另外，该policy选项需要写入grub的配置中，放在multiboot下面，如下所示：</p>

<pre><code>multiboot /boot/xen-VERSION.gz dom0_mem=1024M,max:1024M flask=enforcing
module /boot/vmlinuz-X.Y-amd64 root=/dev/mapper/vg_system-root ro quiet
module /boot/initrd.img-X.Y
module /boot/flask/xenpolicy-VERSION
</code></pre>

<hr />

<h3>利用XSM security label创建虚拟机</h3>

<p>当通过上面所提到的方式启动Xen之后，FLASK也就开启了，那么我们在创建虚拟机的时候就需要在其配置中增加一个security label（安全标签），否则，该虚拟机会被标记为“unlabeled”，例子如下所示：</p>

<pre><code>seclabel='system_u:system_r:domU_t'
</code></pre>

<p>安全标签有<code>user</code>,<code>role</code>和<code>type</code>表示，这些会在之后进行介绍。另外我们需要在policy中对相应的主体进行正确的权限设置。对于“unlabeled”的虚拟机，如果FLASK并没进入enforcing模式，或者进入了enforcing模式但定义了相关标签的权限，则不会有问题，否则，在其调用某些操作的时候会被禁止。</p>

<p>通过<code>xl list -Z</code>命令可以查看当前虚拟机所具有的安全标签。</p>

<p>通过<code>xl dmesg | grep avc</code>命令可以查看FLASK相关的log记录。</p>

<hr />

<h3>FLASK policies</h3>

<h4>增加一个security module</h4>

<p>我们可以把<strong>security module（安全模块）</strong>当做将一系列规则进行封装所产生的集合，如果要增加一个自定义的安全模块，我们需要在<code>$XEN/tools/flask/policy/policy/modules.conf</code>文件中加一行：</p>

<pre><code>&lt;module_name&gt; = on
</code></pre>

<p>同时在<code>$XEN/tools/flask/policy/policy/modules/&lt;module_name&gt;</code>目录下增加两个文件：</p>

<pre><code>&lt;module_name&gt;.te
&lt;module_name&gt;.if
</code></pre>

<p>其中<code>.te</code>文件定义了相应规则的的描述，而<code>.if</code>文件定义了一系列在<code>.te</code>文件中会被用到的宏（macros）。</p>

<p>在XSM-FLASK中有一个默认的模块：xen。如果存在多个模块（比如用户自己定义了多个模块），那么这些模块中不能有重复的<code>type</code>和<code>role</code>的定义。当模块定义好之后，可以参照&#8217;FLASK policy的编译流程&#8217;进行编译，并将其放在目标目录中（如<code>/boot/flask</code>)，这样在xen启动的时候就会加载，或者通过<code>xl loadpolicy</code>进行手动加载。</p>

<h4>定义Types, roles, users和attributes</h4>

<p>在安全模块中会定义许多规则，对于一个特定的规则，说白了就是规定了某个主体（source subject）对另一个主体（target subject）进行的一系列访问和操作（如hypercall）的权限（deny or allow），比如规定：</p>

<pre><code>某个集合中的虚拟机（source）不能向（deny）虚拟机监控器Xen（target）调用某个hypercall（operation）
</code></pre>

<p>那么这些集合就需要通过一系列的层级进行定义，也就引入了接下来需要讨论的<code>type</code>, <code>role</code>, <code>users</code>和<code>attributes</code>。可以结合<code>$XEN/tools/flask/policy/policy/modules/xen.te</code>文件中的例子进行更具体的了解。</p>

<p><strong>Policy Attribute</strong></p>

<p><code>attribute</code>定义了一个抽象的属性，它可以被附属在接下来要介绍的<code>type</code>主体上，即表示某个<code>type</code>具备哪些<code>attributes</code>。</p>

<p><strong>Policy Type</strong></p>

<p><code>type</code>是整个policy定义规范中最低的一个主体级别，它可以被用来在某个规则中指定source和target的类型。定义<code>type</code>的方式是：</p>

<pre><code>type new_type_t &lt;attributes&gt;;
</code></pre>

<p>比如在示例文件中，定义了一个<code>type</code>：</p>

<pre><code>type xen_t, xen_type, mls_priv;
</code></pre>

<p>其中<code>xen_t</code>即为<code>type</code>的标示符，而后面的<code>xen_type</code>和<code>mls_priv</code>则是相应的<code>attribute</code>，也就是说每个<code>type</code>可能会带有多个不同的<code>attributes</code>。</p>

<p>当我们需要定义一个规则的时候，可以通过<code>type</code>来指定对应的源和目标主体。比如需要定义某个hypercall的调用是被允许的，可以这么写：</p>

<pre><code>allow &lt;source type&gt; &lt;target type&gt;:&lt;security class&gt; &lt;hypercall&gt;;
</code></pre>

<p>其中，<code>security class</code>会在之后介绍，简单来说，它定义了一系列具有相关性的hypercall的集合。一个具体的例子：</p>

<pre><code>allow dom0_t security_t:security check_context;
</code></pre>

<p>定义了<code>dom0_t</code> type的主体可以向<code>security_t</code> type主体调用<code>security class</code>中的<code>check_context</code> hypercall。</p>

<p>另外，如果同时定义多个同一个class中的hypercall，可以用<code>{}</code>将其括起来，例如：</p>

<pre><code>allow dom0_t dom0_t:resource { add remove };
</code></pre>

<p>除了用<code>type</code>表示的主体，我们也可以直接用<code>attribute</code>来表示主体，如：</p>

<pre><code>allow domain_type xen_t:xen tmem_op;
</code></pre>

<p>即表示所有具有domain_type属性的type主体都可以向<code>xen_t</code> type主体调用<code>xen class</code>中的<code>tmem_op</code> hypercall。</p>

<p><strong>Policy Role</strong></p>

<p><code>role</code>是处于<code>type</code>上一层级的主体级别，用户可以定义某个<code>role</code>由多个<code>types</code>组成，比如：</p>

<pre><code>role system_r
role system_r types { xen_type domain_type };
</code></pre>

<p>可以看到，<code>role</code>的<code>types</code>是采用<code>attribute</code>的方式定义的，即定义具有某个<code>attribute</code>的所有<code>types</code>都属于这个<code>role</code>。如果要定义具有某个<code>attribute</code>的除掉某个<code>type</code>的所有<code>types</code>，则通过在该<code>type</code>之前加上一个<code>-</code>进行标示，如：</p>

<pre><code>role vm_r
role vm_r types {domain_type -dom0_t };
</code></pre>

<p><strong>Policy Users</strong></p>

<p><code>user</code>作为policy中的最高层级的主体级别，它并不被定义在<code>.te</code>文件中，它们是被定义在<code>$XEN/tools/flask/policy/policy/users</code>文件中。因此我们可以跨安全模块共用同一个<code>user</code>。在默认情况下，FLASK定义了三个users：system_u, customer_t和customer_2。</p>

<h4>增加Policy constraints</h4>

<p>FLASK可以通过在<code>$XEN/tools/flask/policy/policy/constraints</code>文件中定义规则来限制某些操作。在默认的情况下，FLASK规则定义了两条constraints（限制规则）来防止不同用户之间event channel和grant table的交互。一条限制规则语法如下：</p>

<pre><code>constrain &lt;security class&gt; { &lt;hypercall&gt; } ( expression );
</code></pre>

<p>比如例子中的：</p>

<pre><code>constrain grant { map_read map_write copy } (
  u1 == system_u or
  u2 == system_u or
  u1 == u2
);
</code></pre>

<p>这条限制规则表示如果属于<code>grant class</code>的这些hypercall可以被执行，当且仅当expression中的条件成立。其中，expression可以包含之前定义好的所有<code>user</code>, <code>role</code>和<code>type</code>主体，其语法规则如下：</p>

<pre><code>expression : (expresion)
      | not expression
      | expression and expression
      | expression or expression
      | u1 op u2
      | r1 role_op r2
      | t1 op t2
      | u1 op names
      | u2 op names
      | r1 op names
      | r2 op names
      | t1 op names
      | t2 op names

op : == | !=
role_op : == | != | eq | dom | domby | incomp

names : name | { name_list }
name_list : name | name_list name
</code></pre>

<h3>Security classes</h3>

<p><code>security class</code>被定义在<code>$XEN/xen/xsm/flask/policy/access_vectors</code>文件中，每个hypercall被分配在了其中一个class中，需要注意的是，每一个class最多只能有32个hypercalls。下面简单介绍下默认的几个classes，相关的hypercall的描述可以直接看<a href="http://wiki.xen.org/wiki/Xen_Security_Modules_:_XSM-FLASK#Security_classes">这里</a>。</p>

<ul>
<li><code>class xen</code>包含了所有在hypervisor中进行的操作，其source为执行hypercall的domain，target为xen (<code>xen_t</code> type);</li>
<li><code>class domain &amp; class domain2</code>包含了某个domain调用另一个domain或者调用自己的操作，source为执行hypercall的domain，target为被调用的domain（包括<code>_self</code>和<code>_target</code>的type）;</li>
<li><code>class hvm</code>类似于<code>domain</code>，除了它是针对HVM domain；</li>
<li><code>class event</code>用于描述event channels；</li>
<li><code>class grant</code>用于描述grant mapping；</li>
<li><code>class mmu</code>用于描述不是采用grant机制映射的内存页；</li>
<li><code>class shadow</code>（这个不清楚是干嘛的）；</li>
<li><code>class resource</code>用于描述硬件设备passthrough所使用的资源，包括IRQ, MMIO regions, I/O ports, PCI device等；</li>
<li><code>class security</code>用于描述和FLASK相关的操作。</li>
</ul>


<hr />

<p>以上即为XSM-FLASK最基本的介绍，我也还正处于学习阶段，其它更细节的部分和更直观的实例会在以后的博文中进行说明。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ChinaSys小记（2015.6）]]></title>
    <link href="http://ytliu.github.io/blog/2015/06/08/chinasysxiao-ji-2015-dot-6/"/>
    <updated>2015-06-08T21:14:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/06/08/chinasysxiao-ji-2015-dot-6</id>
    <content type="html"><![CDATA[<p>今年上半年的ChinaSys选择了在厦门举办，真是深得我心。顺便见了父母一趟，吃了好多海鲜，和亲人喝了几杯白酒，和几个闷骚程序员去鼓浪屿弱弱地游玩了一趟，还走了走厦门大学，白城沙滩，总的来说还是非常惬意的。不过两天会议下来，我越发觉得程序员与程序员之间的交流还是很局限的，特别是当我发现大部分人和talk都和我方向并不相同的时候，我就不知道聊天的时候该聊些什么。所以在两天会议的过程中其实并没有太多的和外界的交流，这也是我这次参加ChinaSys比较遗憾的一点。</p>

<p>废话说到这里，开始进入正题。根据主办方的介绍，这次ChinaSys注册105人次，放眼望去大部分都还是老面孔，来自清华，北大，计算所，上交，复旦，中科大，华科，北理工等高校，以及MSRA，百度等公司。从会议的整个过程来看，国内各大高校和公司的研究水平都很高，在各个的领域都有比较深入的探究，但是由于本人水平的原因，很多关键点并没有get到，所以笔记也就显得比较混乱，这次ChinaSys回来让我最大的感受就是要多了解一些各个领域的知识，对整个计算机发展的各个方向有一个大方向的了解，知道相应的问题，挑战，主要技术等，这样在每次参加这些会议的时候收获的就不只是这些皮毛的东西了。</p>

<p>接下来是我的笔记，基本没有太细节的点，因为很多也是别人正在做的工作，不能透露太多，当然更重要的原因其实是那些细节我自己并不了解。这次会议上用的是markdown直接记的一些印象比较深刻的点，这里也就直接整理一下记录在博客里面，留作纪念。另外这次会议没有很明确的分session，记录顺序就完全按演讲的时间顺序，另外非常不好意思的是由于某些客观原因，有好多个talk我都没有听到，所以也就不再这里记录了。这次ChinaSys共有28个talk，1个华科的金海教授keynote，以及一个讨论“如何在国内做出世界级研究”的panel。</p>

<!-- more -->


<hr />

<h2>ChinaSys 2015.6</h2>

<blockquote><p>105 registrations</p></blockquote>

<hr />

<h4>Persistent B+ trees in Non-Volatile Main Memory</h4>

<blockquote><p>陈世敏 from 中科院计算所</p></blockquote>

<p><strong>problem:</strong> B+ tree one operation -> multiple inconsistency states in cache when crash</p>

<p><strong>existing solution:</strong></p>

<ul>
<li>write-ahead log, 4 times (clflush &amp; mfence) cost</li>
<li>shadowing (like RCU?), B+ tree need to change 2 pointer, not atomic one.</li>
</ul>


<p><strong>solution:</strong> re-design B+ tree node.</p>

<ul>
<li>unsorted + slot array/bitmatp B+ node structure.</li>
<li>use empty slot to store newly inserted one</li>
<li>atomically update slot array &amp; bitmap</li>
</ul>


<hr />

<h4>Twin-Load: 一种在同步内存接口上构建异步内存扩展的方法</h4>

<blockquote><p>陈明宇 from 中科院计算所</p></blockquote>

<p><strong>problem:</strong> capacity wall (vs. memory wall) 扩容困难 (封装，结构，工艺）</p>

<blockquote><p>DRAM系统容量 = 通道数 * 通道内颗粒数 * 颗粒容量</p></blockquote>

<p><strong>goal:</strong> 不修改通用处理器，支持异步扩展： 同步接口（通用）+异步协议（扩展性）</p>

<p><strong>solution:</strong> 把一次访存分为一次预取和一次读取</p>

<hr />

<h4>RecFS: Building Reliable and Efficient Cloud Storage Services with File System in User Space</h4>

<blockquote><p>杨智  from 北大</p></blockquote>

<p><strong>background:</strong> storage synchronization approaches (dropbox?): inotify + rsync， 校验匹配</p>

<p><strong>problem:</strong> high cost + inconsistency</p>

<p><strong>solution:</strong> 利用用户态文件系统（fuse）截获写操作，获得相关信息 (relation table)，</p>

<hr />

<h4>Computational Memory Architecture</h4>

<blockquote><p>王颖 from 中科院计算所</p></blockquote>

<p>Processing in Memory (PIM)：直接在内存中进行计算。 (NDC, NDA &#8230;)，将通用处理器、流处理器等集成到内存。</p>

<p><strong>problem:</strong> PIM returns (enabling technique + demanding app).</p>

<p><strong>proposal:</strong> computational memory (ProPRAM)</p>

<ul>
<li>in-memory computation application</li>
<li>COMS-computible memory technique</li>
</ul>


<p>重用内存内资源，不需要integrate新的处理器等，内存加速器。</p>

<hr />

<h4>GraM: Scaling Graph Computation to the Trillions</h4>

<blockquote><p>杨凡 from MSRA</p></blockquote>

<p><strong>backgroud:</strong> graph engine, large graph computing</p>

<p>GraM: graph engine - focus on <strong>Scalability and Efficiency</strong></p>

<p><strong>design:</strong></p>

<ul>
<li>simple model - message passing</li>
<li>multi-core aware RDMA stack</li>
</ul>


<hr />

<h4>GridGraph: Large-Scale Graph Processing on a Single Machine Using 2-Level Hierarchical Partitioning</h4>

<blockquote><p>朱晓伟 from 清华</p></blockquote>

<p><strong>background:</strong> out-of-core - use disk, guarantee locality by partition.</p>

<p><strong>insight:</strong> if we can guarantee the locality of both source (gather) and destination (scatter) vertex, we are able to merge the 2 phases into 1!</p>

<p><strong>design:</strong> 2 phases -> 1 phase</p>

<hr />

<h4>Hardware Isolation is coming, What’s Next for System Software?</h4>

<blockquote><p>徐天妮 from 中科院计算所</p></blockquote>

<p><strong>problem:</strong> sharing cause inteference, &#8230; isolate programs from each other on a shared server is hard.</p>

<p><strong>insight:</strong> a computer is inherently a network, design of network (tag) can be utilized to system.</p>

<p><strong>PARD</strong> Programmable Architecture for Resourcing-on-Demand</p>

<p><strong>challenge:</strong></p>

<ul>
<li>hardware differentiate application request: taggging each app</li>
<li>how to design control plane for a diversity of app: table + programming interface + interrupt line</li>
</ul>


<p>like full-system SRIOV (via tagging in hardware)</p>

<hr />

<h4>云游戏细粒度资源调度</h4>

<blockquote><p>张伟 from 华科</p></blockquote>

<p><strong>background:</strong> 视频流 （并发度低，资源利用率低） &amp; 图形流（终端要求高，跨平台难）</p>

<blockquote><p>负载：逻辑 + 渲染 + 压缩</p></blockquote>

<p><strong>problem:</strong> 云游戏资源调度</p>

<p><strong>solution：</strong></p>

<ul>
<li>任务解耦：逻辑-渲染分离</li>
<li>多资源融合调度</li>
<li>轻量级负载迁移</li>
</ul>


<hr />

<h4>Efficient Deterministic Replay with Hardware Virtualization Extensions</h4>

<blockquote><p>任仕儒 from 北大</p></blockquote>

<p><strong>motivation:</strong> software only deterministic replay</p>

<p>R&amp;R the Memory interleaving with HAV extension?</p>

<p>当虚拟机下陷的时候通过EPT里面的dirty|access bit来记录对应的访问。</p>

<p>truncate chunk using performance counter (BTS)</p>

<hr />

<h4>An effective correlation-aware VM placement scheme for reducing SLA violation in data center</h4>

<blockquote><p>许胜 from 中科院计算所</p></blockquote>

<p><strong>background:</strong> data center power and utilization.</p>

<p><strong>motivation:</strong> 虚拟机部署算法（分布式部署）：既保证SLA性能，同时降低物理服务器数量。</p>

<p><strong>solution:</strong> 通过对服务器部署能力进行约束的策略，采用SSP优化部署算法， 考虑应用的资源需求特性。</p>

<hr />

<h4>Linux内核数据竞争统计与分析</h4>

<blockquote><p>石剑君 from 北理工</p></blockquote>

<p><strong>motivation:</strong> summary of linux kernel data race</p>

<p><strong>approach:</strong></p>

<ul>
<li>sources: BugZilla, linux mailing list, changlog</li>
<li>归类patterns: use before initialization , use after free, access without sync, access with improper sync</li>
</ul>


<hr />

<h4>Robust Distributed System Nucleus (rDSN) for Distributed System Study and Research</h4>

<blockquote><p>郭振宇 from MSRA</p></blockquote>

<p><strong>problem:</strong> robustness cannot be achieved in a single point, many research tools failed to be adopted in production.</p>

<p><strong>proposal:</strong> come up a new development framework.</p>

<ul>
<li>need to be able to monitor and manipulate all dependencies and non-determinisms in the system, with good semantic level.</li>
<li>well-defined interface for apps, reusable.</li>
<li>be practical, do not deviate from existing programming model too far.</li>
</ul>


<hr />

<h4>Keynote: 图计算</h4>

<blockquote><p>金海 from 华科</p></blockquote>

<p>网络空间实体关联</p>

<p><strong>数据在哪里</strong></p>

<ul>
<li>1% Web化数据: 1/500可爬（网站主观（主动屏蔽）、非主观（不符合规范等）原因不可爬）</li>
<li>99%非Web化数据: 人工生成，qq，邮件，物联网&#8230;</li>
</ul>


<hr />

<h4>Accelerating distributed graph processing with RDMA</h4>

<blockquote><p>高品 from 清华</p></blockquote>

<p><strong>motivation:</strong> data locality vs. load balance</p>

<hr />

<h4>Efficient Concurrent Search Tree for Epoch-based In-memory Database</h4>

<blockquote><p>张凯源 from 上海交大</p></blockquote>

<p><strong>insight:</strong> batch B+ tree node insert, search&#8230;</p>

<p><strong>proposal:</strong> buffered B+ tree</p>

<p><strong>problem:</strong> good insert, but bad search</p>

<hr />

<h4>Toward Optimized Array-based Computing Framework</h4>

<blockquote><p>章明星 from 清华</p></blockquote>

<p><strong>background:</strong> array-based languages: cannot scale-out</p>

<p><strong>motivation:</strong> array-based program - (front end) -> array primitive - (back end) -></p>

<p>中间缺少一个optimizer</p>

<p><strong>design</strong>:</p>

<ul>
<li>distinguish local and distributed data</li>
<li>separate computation and communication</li>
<li>optimize each locally-computing period</li>
</ul>


<hr />

<h4>开源硬件加速创新设计</h4>

<blockquote><p>刘兴华 from LeMaker</p></blockquote>

<p>大学创客创新计划</p>

<p>创客 vs. DIY</p>

<p>开源硬件 vs. 开发板</p>

<hr />

<h4>ShiDianNao: Shifting Vision Processing Closer to the Sensor</h4>

<blockquote><p>杜子东 from 中科院计算所</p></blockquote>

<p>Diannao series : 硬件用于神经网络的加速器</p>

<p><strong>background:</strong> 为什么要在sensor旁边用加速器: 功耗主要消耗在内存</p>

<hr />

<h4>Hi-fi Playback: Tolerating Position Errors in Shift Operations of Racetrack Memory</h4>

<blockquote><p>张超 from 北大</p></blockquote>

<p><strong>background:</strong> Racetrack memory (latency vs. capacity) proposed by IBM</p>

<p>shift position error （只移到一半，或者移多了）</p>

<hr />

<p>总之，这次ChinaSys笔记记得比较浅，希望下次能做的更好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夏天到了]]></title>
    <link href="http://ytliu.github.io/blog/2015/05/19/xia-tian-dao-liao/"/>
    <updated>2015-05-19T19:48:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/05/19/xia-tian-dao-liao</id>
    <content type="html"><![CDATA[<p>其实夏天早就到了，只不过是莫名其妙地选了一个标题罢了。</p>

<p>从2月4号一直到现在，已经有3个半月没有写过东西了，上周日赶完CCS，虽然被海波嫌弃论文写得太差，但毕竟是自己进实验室以来第一次依靠自己从idea到实现到写成论文所完成的一个项目，而且从最后的结果来看还算是比较满意的一个工作，投完论文的那一刹那有一种无法言喻的轻松感袭来。那天晚上请小弟小妹吃饭，喝了几瓶酒，聊了一晚上天，感觉很久都没有那么放松了。这两天似乎有点懒散，刻意让自己好好放松了下，想想明天还是得开始正常地工作了，就写个杂记，记录下这段时间的心情吧。</p>

<!-- more -->


<p>这段时间每天早晨6点前都会醒过来，不知道是压力太大，还是已经形成了生物钟，由于白天也没有很疲惫的感觉，也就没有太当回事，想着顺势就早起早工作，已经慢慢成为每天第一个到实验室开门的男人了。感觉自己还是很享受每天早上七点半到九点半实验室一个人干活的这段时间的，很安静，效率也高，加上每天下午都会花1~2个小时锻炼身体，一天下来，总能有一种充实的感觉。我现在越来越强烈地感觉到，以前自己那些“没有时间去锻炼”什么的措辞都是借口，对于我来说，完全有能力在保证工作时间的前提下锻炼好自己的身体。另外，我也渐渐体会到身体强壮之后的各种美好的感觉。强壮之后去打篮球羽毛球什么的都感觉特别惬意，体力足够，打的爽，也不会特别累。
早起+运动，已经渐渐成为习惯，早晨微风拂脸的舒适，夏天挥汗如雨的感觉，是我觉得自己每天最有存在感最惬意的时刻，相信在尝到这些甜头之后，自己也能够一直这么坚持下去！</p>

<p>博士生涯已经快过去三年了，很多事情在慢慢想通，信心也一点一点地被找回。对于现在的状态，我相信自己以后不管做什么都不会做的太差，但是也还无法做到最好，依旧在寻找自己的核心竞争力，有方向，但是依然有些许迷茫。很享受现在读博充实、自由的时光。当然，我是幸运的，付出的基本上都会有收获，不过其实回头想想，很多收获并不是一开始就有的，需要在很多次的失败中慢慢地等待，时间长短罢了，我向来比较有耐心和恒心，做很多东西的时间也比较长，所以看上去收获比较大。另外，我也在一天天的成长中学会去选择，选择一些自己真正在意的东西，放弃一些看上去很美好但是并非自己真正想要的东西。这个过程有时候很痛苦，但是没有必要过于纠结。作为一个有思想的人，得学着在生活中寻找自己，我还没完全找到，但是我相信应该不远了。</p>

<p>这段时间看了蛮多书的，特别是冯唐和马亲王的文字，异常佩服他们的思想和知识面，还有那些天马行空但是又如此深入人心的言语。我一直期望自己能够成为一个有趣的人，超出别人对我的期待，拥有属于自己的思想。相比于那个刚入大学的自己，显然有了很大的成长，但是离自己的目标依旧很远，我很开心，因为自己还有好长好长可以奋斗的距离。</p>

<p>这段时间也看了很多电影，想看的都没有拉下，不想看的也忍受着看了许多。最近似乎有点审美疲劳，打算先放一回儿，看看美剧吧。HBO的冰与火，我攒了6集了，又挖出一个同样HBO的硅谷，充满能戳中笑点的梗，特别期待。</p>

<p>前段时间和小呆聊了好多我们今后的打算，畅想了那些我们都特别期待的生活，现在缺的是钱和时间，当然，我相信这些很快就都会有的，特别特别地期待！当然，期待的还有一刀，这个还是我们的秘密，以后再说吧。</p>

<p>关于父母，我其实很开心地看到他们在去寻找自己的生活，在努力去享受自己的人生。我一直觉得我的母亲是一个很伟大的人，也一直觉得自己和她真的是心有灵犀。我特别感激她对我那份充满默契的理解，无需多言。</p>

<p>六月份要和实验室另外七个博士或者即将成为博士的同学去厦门开ChinaSys，相信一定会是一个愉快的旅程，</p>

<p>六月份还要搬家，和小呆一起过属于我们的两人世界，或许搬家的过程会比较辛苦，但是对生活同样充满期待。</p>

<p>七月份要去参加自己最好的朋友的婚礼，那种弯道超车的惊喜，那种发至朋友间最最诚挚的祝福与祝愿，又是一次相聚的狂欢。</p>

<p>&#8230;&#8230;</p>

<p>太多的期待，生活本该这样。</p>

<p>夏天来了，虽然有炎日的暴晒，我依然享受挥汗如雨的淋漓畅快，就算生活有些不如所愿，我相信那些本来属于你的期待，总能吹去拂尘于身心的纠结和遗憾。</p>

<p>夏天来了，这就是我现在的状态。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Driver Domain on Xen]]></title>
    <link href="http://ytliu.github.io/blog/2015/02/04/running-driver-domain-on-xen/"/>
    <updated>2015-02-04T22:27:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/02/04/running-driver-domain-on-xen</id>
    <content type="html"><![CDATA[<p>又是一篇和Xen相关的教程，主要介绍如何在Xen里面启动一个网卡的<code>driver domain</code>（也被称为<code>stub domain</code>），也就是说，该虚拟机专门用来为其它虚拟机提供网络服务（而不是把所有这些服务都交给<code>Domain 0</code>来做）。</p>

<p>说句题外话，为什么最近这么多教程类型的博客，原因在于我发现每次我把这些东西记在博客里面的话，自己都会记得很深，但是记在Evernote里面经常就会忘记掉，况且记在博客里面还有可能为别人提供帮助，所以何乐而不为呢？</p>

<!-- more -->


<p>好了，废话说到这，开始进入正题。</p>

<h3>为什么要使用<code>driver domain</code></h3>

<p>可以参看<a href="http://wiki.xen.org/wiki/Device_Model_Stub_Domains">Xen的wiki</a>。</p>

<p>主要有四点原因：</p>

<ul>
<li>安全性：把权限从<code>domain 0</code>里面剥离出来，也就是说就算客户虚拟机控制了<code>driver domain</code>，也不能拿<code>domain 0</code>如何；</li>
<li>可扩展性：<code>driver domain</code>的资源不受<code>domain 0</code>的限制，所有和设备相关的资源都和该<code>driver domain</code>相关；</li>
<li>隔离性：其实和安全性有点重复，主要是说<code>driver domain</code>里面的进程不会和<code>domain 0</code>里面的进程产生竞争关系，不管从安全性还是性能方面都能提供比较好的隔离性；</li>
<li>高性能：如果在<code>domain 0</code>里面运行driver的进程，那么会产生<code>double scheduling</code>的问题，即driver要工作，必须首先等<code>domain 0</code>被调度，然后等<code>domain 0</code>中和driver相关的进程被调度；但是如果用了<code>driver domain</code>的话就没有这个问题了，只要等<code>driver domain</code>被调度就可以了（因为在<code>driver domain</code>里面只有一个进程）。</li>
</ul>


<p>使用<code>driver domain</code>可以提供多大的性能提升呢？可以参看<a href="http://www-archive.xenproject.org/files/xensummitboston08/SamThibault_XenSummit.pdf">这个slide</a>。</p>

<h3>配置和启动<code>driver domain</code></h3>

<p>好，下面开始进入教程。</p>

<p>首先我们来一张使用网卡<code>driver domain</code>的架构图吧：</p>

<p><img src="http://ytliu.info/images/2015-02-04-1.png" title="driver domain" alt="driver domain" /></p>

<p>其实主要就是如何进行网卡的passthrough，以及如何让客户虚拟机和<code>driver domain</code>进行匹配。</p>

<p>至于相关的参考资料嘛，可以参考<a href="http://wiki.xen.org/wiki/Driver_Domain">这里</a>。</p>

<h4>安装Xen和客户虚拟机</h4>

<p>这个就不说了，参照<a href="http://ytliu.info/blog/2015/02/02/running-xen-on-xen%3Axende-qian-tao-xu-ni-hua-ji-zhu/">上篇博客</a></p>

<h4>Xen PCI Passthrough</h4>

<p>参考资料来自<a href="http://wiki.xen.org/wiki/Xen_PCI_Passthrough">这里</a>。</p>

<p>首先提一下IOMMU和PCI passthrough的关系：</p>

<p>在正常情况下，一个设备可被配置成DMA到任意的宿主机的物理内存，但是这样会有两个问题：</p>

<ul>
<li>第一，客户虚拟机可以利用它来任意写Xen的内存，这样会有安全问题；</li>
<li>第二，对于HVM模式的客户虚拟机来说，它看到的内存是被虚拟化的，但是对于设备来说却不是这样的，也就是说正常情况下HVM的虚拟机是看不到被设备访问的那块内存的，也就无法使用那块内存。</li>
</ul>


<p>那么如何让客户虚拟机的driver来操作真实硬件呢？这就引入了IOMMU，这套机制运行Xen来配置一个设备可以访问哪些内存，以及将这些内存也让客户虚拟机看到。</p>

<p>所以说，在有IOMMU支持的硬件上，设备可以被passthrough给HVM和PV虚拟机，而在没有IOMMU支持的设备上，如果设备被passthrough给PV虚拟机，虽然可以正常运行，但是会有安全问题，另外，设备不能被passthrough给HVM虚拟机，因为HVM虚拟机看不到设备访问的那块内存。</p>

<p>接下来我们就来看如何passthrough。</p>

<p>简单来说，我们需要先把网卡和<code>domain 0</code>的连接先给取消掉，然后再把它分配给<code>driver domain</code>。</p>

<p>首先我们得先知道我们的网卡设备是哪一个，以及它所对应的<a href="http://wiki.xen.org/wiki/Bus:Device.Function_(BDF">BDF</a>_Notation)，这个可以通过:</p>

<pre><code>$ lspci
</code></pre>

<p>查看，得到它的BDF是<code>00:19.0</code>:</p>

<p><img src="http://ytliu.info/images/2015-02-04-2.png" title="nic bdf" alt="nic bdf" /></p>

<p>之后，就可以利用<code>xl</code>这套xen-tool里面提供的命令来将其从<code>domain 0</code>里面移除，并且加进Xen的<code>assignable</code>的设备集合里面：</p>

<pre><code>$ sudo xl pci-assignable-add 00:19.0
</code></pre>

<p>这个时候运行<code>sudo xl pci-assignable-list</code>就可以看到：</p>

<p><img src="http://ytliu.info/images/2015-02-04-3.png" title="xl pci-assignale-list" alt="xl pci-assignale-list" /></p>

<p>这之后，就可以启动我们的<code>driver domain</code>了。配置启动文件：</p>

<figure class='code'><figcaption><span>driver-domain.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">builder</span><span class="o">=</span><span class="s2">&quot;hvm&quot;</span>
</span><span class='line'><span class="nv">name</span> <span class="o">=</span> <span class="s2">&quot;driver-domain&quot;</span>
</span><span class='line'><span class="nv">memory</span> <span class="o">=</span> 1024
</span><span class='line'><span class="nv">vcpus</span> <span class="o">=</span> 2
</span><span class='line'><span class="nv">pci</span><span class="o">=[</span> <span class="s1">&#39;00:19.0&#39;</span> <span class="o">]</span>
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm.img,xvda,rw&#39;</span> <span class="o">]</span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;cd&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，这里主要就是增加了一行：</p>

<figure class='code'><figcaption><span>dd.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">pci</span><span class="o">=[</span> <span class="s1">&#39;00:19.0&#39;</span> <span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后启动虚拟机：</p>

<pre><code>$ sudo xl create driver-domain.cfg
</code></pre>

<p>这个时候如果进到虚拟机里面看，会发现它多了一个PCI设备，且可以联网：</p>

<p><img src="http://ytliu.info/images/2015-02-04-4.png" title="network in driver domain" alt="network in driver domain" /></p>

<p>而此时，宿主机已经连不上网了！</p>

<p>这里需要注意的是我们需要在这个<code>driver domain</code>里面安装xen-tools，以及配置桥接网络，取名为<code>xenbr0</code>，供之后的客户虚拟机使用。</p>

<p><img src="http://ytliu.info/images/2015-02-04-5.png" title="network in driver domain 2" alt="network in driver domain 2" /></p>

<p>这些配置和<code>domain 0</code>里面的差不多，具体的可以参照我的<a href="http://ytliu.info/blog/2015/02/02/running-xen-on-xen%3Axende-qian-tao-xu-ni-hua-ji-zhu/">上一篇博客</a>。</p>

<h4>配置客户虚拟机</h4>

<p>然后我们就可以配置客户虚拟机了，这一步非常简单，只需要在<code>vif</code>这个配置选项上的<code>backend</code>填上<code>driver-domain</code>（也就是<code>driver domain</code>的name），将<code>bridge</code>填上<code>xenbr0</code>（也就是driver domain的桥的名字）就可以了：</p>

<figure class='code'><figcaption><span>guest-vm.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">builder</span><span class="o">=</span><span class="s2">&quot;hvm&quot;</span>
</span><span class='line'><span class="nv">name</span> <span class="o">=</span> <span class="s2">&quot;guest vm&quot;</span>
</span><span class='line'><span class="nv">memory</span> <span class="o">=</span> 1024
</span><span class='line'><span class="nv">vcpus</span> <span class="o">=</span> 2
</span><span class='line'><span class="nv">vif</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;bridge=xenbr0, model=e1000, backend=driver-domain&#39;</span><span class="o">]</span>
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm2.img,xvda,rw&#39;</span> <span class="o">]</span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;cd&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后启动虚拟机：</p>

<pre><code>$ sudo xl create guest-vm.cfg
</code></pre>

<p>进入虚拟机之后试一下，发现它果然可以上网啦！</p>

<p><img src="http://ytliu.info/images/2015-02-04-6.png" title="guest vm" alt="guest vm" /></p>

<hr />

<p>到这里，这一篇博客的内容就结束啦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Xen on Xen：Xen的嵌套虚拟化技术]]></title>
    <link href="http://ytliu.github.io/blog/2015/02/02/running-xen-on-xen%3Axende-qian-tao-xu-ni-hua-ji-zhu/"/>
    <updated>2015-02-02T18:41:00+08:00</updated>
    <id>http://ytliu.github.io/blog/2015/02/02/running-xen-on-xen:xende-qian-tao-xu-ni-hua-ji-zhu</id>
    <content type="html"><![CDATA[<p>这篇博文是一个简单的教程，介绍如何在Xen的虚拟机中运行另外一个虚拟机，说白了，就是Xen的嵌套虚拟化技术。</p>

<!-- more -->


<h3>安装Xen</h3>

<p>关于如何安装Xen，首选的是看<a href="http://wiki.xenproject.org/wiki/Xen_Project_Beginners_Guide">Xen的官方教程</a>。</p>

<p>不过由于里面说的比较复杂，所以本教程就简单的把几个步骤列一下：</p>

<h4>直接安装</h4>

<p>这个我没试过，因为我都是用源码安装的。不过据说很简单，只要</p>

<pre><code>$ sudo aptitude -P install xen-linux-system
$ sudo dpkg-divert --divert /etc/grub.d/08_linux_xen --rename /etc/grub.d/20_linux_xen # change the order of the operating systems so that Xen is the default option.
$ sudo update-grub # regenerate the /boot/grub/grub.cfg file
</code></pre>

<p>就行了。如果不行再自己网上搜下吧，毕竟这个不是今天的重点。</p>

<h4>源码安装</h4>

<p>具体的参阅<a href="http://wiki.xenproject.org/wiki/Compiling_Xen_From_Source">这里</a>：</p>

<pre><code>$ sudo aptitude build-dep xen
$ git clone git://xenbits.xen.org/xen.git
$ cd xen
$ ./configure
$ make xen
$ make tools
$ make install-xen
$ make install-tools
$ sudo dpkg-divert --divert /etc/grub.d/08_linux_xen --rename /etc/grub.d/20_linux_xen
$ sudo update-grub
</code></pre>

<p>至于每一句话什么意思，这里就不阐述了，不懂的自己去google，另外还有一些别的需求的还是自己去看文档吧，这里就负责最基本的配置。</p>

<p>在这之后，在系统的<code>/boot</code>目录下会有几个<code>xen.*.gz</code>的镜像文件，如果看<code>/boot/grub/grub.cfg</code>，能够看到诸如这样的项：</p>

<figure class='code'><figcaption><span>/boot/grub/grub.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>menuentry <span class="s1">&#39;Debian GNU/Linux, with Xen xen and Linux 3.13.7+&#39;</span> --class debian --class gnu-linux --class gnu -ass os --class xen <span class="o">{</span>
</span><span class='line'>    insmod part_msdos
</span><span class='line'>    insmod ext2
</span><span class='line'>    <span class="nb">set </span><span class="nv">root</span><span class="o">=</span><span class="s1">&#39;(hd0,msdos1)&#39;</span>
</span><span class='line'>    search --no-floppy --fs-uuid --set<span class="o">=</span>root 23292666-0022-4e4b-8b4b-4ffcec168ee8
</span><span class='line'>    <span class="nb">echo</span>    <span class="s1">&#39;Loading Xen xen ...&#39;</span>
</span><span class='line'>    multiboot   /boot/xen.gz placeholder
</span><span class='line'>    <span class="nb">echo</span>    <span class="s1">&#39;Loading Linux 3.13.7+ ...&#39;</span>
</span><span class='line'>    module  /boot/vmlinuz-3.13.7+ placeholder <span class="nv">root</span><span class="o">=</span><span class="nv">UUID</span><span class="o">=</span>23292666-0022-4e4b-8b4b-4ffcec168ee8 ro nopat quiet
</span><span class='line'>    <span class="nb">echo</span>    <span class="s1">&#39;Loading initial ramdisk ...&#39;</span>
</span><span class='line'>    module  /boot/initrd.img-3.13.7+
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，<code>multiboot   /boot/xen.gz placeholder</code>是xen的镜像，<code>module  /boot/vmlinuz-3.13.7+</code>是domain 0的镜像，<code>module  /boot/initrd.img-3.13.7+</code>是initrd。</p>

<p>重启之后，由于我们之前改了grub的顺序，所以会默认起Xen，domain的内核就是系统最新的内核。当然这些都是可以配置的，这里就不多说了。</p>

<p>另外一点，由于我们在编译源码的时候同样编译安装了xen-tools，所以当Xen启动之后，就可以运行如下命令：</p>

<pre><code>$ sudo xl list
</code></pre>

<p>来看当前的虚拟机。如果出现问题，很可能是一些相关的daemon没有跑起来，这个时候只需要运行：</p>

<pre><code>$ sudo /etc/init.d/xendomains start
$ sudo /etc/init.d/xencommons start
</code></pre>

<p>就可以了。这个时候再运行<code>xl list</code>，就可以看到：</p>

<p><img src="http://ytliu.info/images/2015-02-02-1.png" title="xl list" alt="xl list" /></p>

<p>这就表明xen正常起来了。其中<code>Domain-0</code>表示的就是Xen里面的特权虚拟机，也就是当前的操作系统。</p>

<h3>启动虚拟机</h3>

<p>当Xen安装起来之后，就可以启动虚拟机了，Xen的虚拟机的管理也是通过刚刚提到的<code>xl</code>那一套工具。如果你已经有一个虚拟机的镜像，那你只需要准备一个配置文件配置好相应的镜像路径就行了，如果没有虚拟机镜像，那么准备一个<code>iso</code>文件，来安装一个镜像。具体如何做会在后面说明。</p>

<p>在Xen中有两种虚拟化的模式：半虚拟化（para-virtualization）和全虚拟化（full virtualization）。关于这两个虚拟化的概念，以及它们的发展历史，我强烈推荐这两篇博客：</p>

<p><a href="https://blog.xenproject.org/2012/10/23/the-paravirtualization-spectrum-part-1-the-ends-of-the-spectrum/">The Paravirtualization Spectrum, part 1: The Ends of the Spectrum</a></p>

<p><a href="https://blog.xenproject.org/2012/10/31/the-paravirtualization-spectrum-part-2-from-poles-to-a-spectrum/">The Paravirtualization Spectrum, Part 2: From poles to a spectrum</a></p>

<p>如果用一张图来表示的话，我选择里面的这张图：</p>

<p><img src="http://ytliu.info/images/2015-02-02-2.png" title="virtualization spectrum" alt="virtualization spectrum" /></p>

<p>由于到目前为止，Intel的VT-x硬件虚拟化技术已经能将CPU和内存的性能提高到真机的水平，但是由于设备（如磁盘、网卡）是有数目限制的，虽然VT-d技术已经可以做到一部分的硬件隔离，但是大部分情况下还是需要软件来对其进行模拟，在全虚拟化的情况下，是通过Qemu进行设备模拟的，而半虚拟化技术则可以通过虚拟机之间共享内存的方式利用特权级虚拟机的设备驱动直接访问硬件，从而达到更高效的性能水平。</p>

<p>当然不管怎么样，在虚拟机启动的时候我们还是可以指定要采用哪种方法来启动，如果采用半虚拟化的方法，那么起来的虚拟机的I/O、CPU和内存都是通过半虚拟化的机制。如果采用的是全虚拟化的方法，那么I/O应该用的就是Qemu的软件模拟了，而CPU和内存采用的是硬件虚拟化VT-x技术。</p>

<p>这里可以看到，如果我们采用PVHVM的方式，即CPU和内存采用VT-x技术，而I/O采用半虚拟化技术，那么性能就是最优的。其实现在linux的mainstream已经将其整合进去啦，默认情况下就可以在HVM里面采用半虚拟化的驱动，具体的可以看<a href="http://wiki.xen.org/wiki/Xen_Linux_PV_on_HVM_drivers">这篇文档</a>。其实主要就是在启动配置文件里面加上这句话：</p>

<figure class='code'><figcaption><span>pv.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">xen_platform_pci</span><span class="o">=</span>1
</span></code></pre></td></tr></table></div></figure>


<p>那么虚拟机启动的时候就会将Qemu的设备unplug，然后匹配半虚拟化的设备，如<code>xen-netfront</code>等。</p>

<h4>半虚拟化启动虚拟机</h4>

<p>准备配置文件：</p>

<figure class='code'><figcaption><span>pv.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">kernel</span> <span class="o">=</span> <span class="s2">&quot;/path/to/vmlinuz&quot;</span>
</span><span class='line'><span class="nv">ramdisk</span> <span class="o">=</span> <span class="s2">&quot;/path/to/initrd.img&quot;</span>
</span><span class='line'><span class="nv">extra</span> <span class="o">=</span> <span class="s2">&quot;root=/dev/xvda1&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">name</span> <span class="o">=</span> <span class="s2">&quot;pv-vm&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">memory</span> <span class="o">=</span> 1024
</span><span class='line'><span class="nv">vcpus</span> <span class="o">=</span> 2
</span><span class='line'>
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm.img,xvda,rw&#39;</span> <span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) </span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;cd&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>kernel</code>和<code>ramdisk</code>是自己编译出来的内核镜像和initrd镜像，这个最好在虚拟机里面编译，然后再拷贝出来，当然我也试过用在主机上编译生成的镜像，可以启动，但是会有一些其他的问题，这里就不展开了。</p>

<p>之后，就可以运行：</p>

<pre><code>$ sudo xl create -c pv.cfg
</code></pre>

<p>来启动虚拟机了，其中<code>-c</code>表示将虚拟机的输出打在console上，这样我们就可以直接看到虚拟机启动的信息了，然后登录进去，就可以操作虚拟机啦：</p>

<p><img src="http://ytliu.info/images/2015-02-02-3.png" title="pv vm" alt="pv vm" /></p>

<h4>全虚拟化启动虚拟机</h4>

<p>准备配置文件：</p>

<figure class='code'><figcaption><span>hvm.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">kernel</span> <span class="o">=</span> <span class="s2">&quot;hvmloader&quot;</span>
</span><span class='line'><span class="nv">builder</span><span class="o">=</span><span class="s2">&quot;hvm&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">name</span> <span class="o">=</span> <span class="s2">&quot;hvm-vm&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">memory</span> <span class="o">=</span> 1024
</span><span class='line'><span class="nv">vcpus</span> <span class="o">=</span> 2
</span><span class='line'>
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm.img,xvda,rw&#39;</span> <span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) </span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;cd&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>和半虚拟化的配置文件一样，除了<code>kernel</code>直接填写“hvmloader”，再增加一个<code>builder</code>，填上“hvm“就可以了。</p>

<p>之后，运行：</p>

<pre><code>$ sudo xl create hvm.cfg
</code></pre>

<p>来启动虚拟机，然后利用vnc来控制虚拟机：</p>

<pre><code>$ vncviewer localhost:0
</code></pre>

<p><img src="http://ytliu.info/images/2015-02-02-4.png" title="hvm vm" alt="hvm vm" /></p>

<h4>利用iso镜像安装虚拟机</h4>

<p>如果你没有虚拟机镜像，那么先用dd生成一个空的镜像，设置文件系统格式：</p>

<pre><code>$ dd if=/dev/zero of=/path/to/vm.img bs=1M count=10000
$ mkfs.ext4 /path/to/vm.img
</code></pre>

<p>这就相当于格式化了一个10G的ext4格式的硬盘，然后下载一个iso镜像，利用之前的配置文件，只需要多加一个disk选项，并将boot启动顺序做一个修改：</p>

<figure class='code'><figcaption><span>*.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>...
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm.img,xvda,rw&#39;</span>, <span class="s1">&#39;file:/path/to/iso,hdc:cdrom,r&#39;</span> <span class="o">]</span>
</span><span class='line'>...
</span><span class='line'><span class="c"># boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) </span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;dc&quot;</span>
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<p>然后启动，安装镜像就好了。</p>

<h3>运行嵌套虚拟机</h3>

<p>这个是这篇博文的重点。其实在当前最新的Xen的版本中，这个功能是默认就开启的，具体的参看<a href="http://wiki.xenproject.org/wiki/Nested_Virtualization_in_Xen">这个链接</a>。</p>

<p>在一般的嵌套虚拟化中，整个架构是这样子的：</p>

<p><img src="http://ytliu.info/images/2015-02-02-5.png" title="nested virtualization" alt="nested virtualization" /></p>

<p>其中，L1是第一层虚拟机，在这个虚拟机中会再运行一个hypervisor，里面运行嵌套的那个虚拟机，被称为L2层。由于我们在L1和L2层运行的都是Xen hypervisor，所以整个架构看起来是这样子的：</p>

<p><img src="http://ytliu.info/images/2015-02-02-6.png" title="xen nested virtualization" alt="xen nested virtualization" /></p>

<p>当然，在这种情况下，还可以分成4个子情况：</p>

<ul>
<li>L1运行PV Xen，L2运行PV Xen</li>
<li>L1运行PV Xen，L2运行HVM Xen</li>
<li>L1运行HVM Xen，L2运行PV Xen</li>
<li>L1运行HVM Xen，L2运行HVM Xen</li>
</ul>


<p>其实方法都大同小异，我就介绍最简单的一种吧：</p>

<h4>L1运行HVM Xen，L2运行PV Xen</h4>

<p>按照之前“全虚拟化启动虚拟机”的步骤做下来，在启动虚拟机的时候加两个选项<code>hap=1</code>和<code>nestedhvm=1</code>：</p>

<figure class='code'><figcaption><span>l1-guest.cfg </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">kernel</span> <span class="o">=</span> <span class="s2">&quot;hvmloader&quot;</span>
</span><span class='line'><span class="nv">builder</span><span class="o">=</span><span class="s2">&quot;hvm&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">name</span> <span class="o">=</span> <span class="s2">&quot;l1-guest&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">memory</span> <span class="o">=</span> 1024
</span><span class='line'><span class="nv">vcpus</span> <span class="o">=</span> 2
</span><span class='line'>
</span><span class='line'><span class="nv">disk</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;file:/path/to/vm.img,xvda,rw&#39;</span> <span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) </span>
</span><span class='line'><span class="nv">boot</span><span class="o">=</span><span class="s2">&quot;cd&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">hap</span><span class="o">=</span>1
</span><span class='line'><span class="nv">nestedhvm</span><span class="o">=</span>1
</span></code></pre></td></tr></table></div></figure>


<p>进入虚拟机之后，按照和之前一样的步骤：</p>

<ul>
<li>编译和安装xen和xen-tools</li>
<li>运行：sudo dpkg-divert &#8211;divert /etc/grub.d/08_linux_xen &#8211;rename /etc/grub.d/20_linux_xen</li>
<li>运行<code>update-grub</code>更新grub</li>
<li>重启虚拟机，进入Xen的镜像</li>
</ul>


<p>这个时候按照前面说的步骤启动L2虚拟机：</p>

<ul>
<li>准备虚拟机镜像；</li>
<li>启动<code>xendomains</code>和<code>xencommons</code>两个服务；</li>
<li>准备“半虚拟化启动虚拟机”的配置文件</li>
<li>利用<code>xl</code>启动虚拟机镜像</li>
</ul>


<p>就能成功在L1的HVM虚拟机里面启动L2的PV虚拟机了：</p>

<p><img src="http://ytliu.info/images/2015-02-02-7.png" title="l2 run in l1" alt="l2 run in l1" /></p>

<p>另外推荐大家看一个人的<a href="http://www2.math.technion.ac.il/~nyh/nested/Thesis_OlivierBerghmans_FinalVersion.pdf">毕业论文</a>，讲的是在不同的平台上运行嵌套虚拟化的虚拟机，以及相关的性能比较。</p>
]]></content>
  </entry>
  
</feed>
